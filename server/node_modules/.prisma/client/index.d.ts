
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Organization
 * 
 */
export type Organization = $Result.DefaultSelection<Prisma.$OrganizationPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model RefreshToken
 * 
 */
export type RefreshToken = $Result.DefaultSelection<Prisma.$RefreshTokenPayload>
/**
 * Model Group
 * 
 */
export type Group = $Result.DefaultSelection<Prisma.$GroupPayload>
/**
 * Model GroupMember
 * 
 */
export type GroupMember = $Result.DefaultSelection<Prisma.$GroupMemberPayload>
/**
 * Model ExternalIntegration
 * 
 */
export type ExternalIntegration = $Result.DefaultSelection<Prisma.$ExternalIntegrationPayload>
/**
 * Model ExternalGroupMapping
 * 
 */
export type ExternalGroupMapping = $Result.DefaultSelection<Prisma.$ExternalGroupMappingPayload>
/**
 * Model SyncLog
 * 
 */
export type SyncLog = $Result.DefaultSelection<Prisma.$SyncLogPayload>
/**
 * Model Lesson
 * 
 */
export type Lesson = $Result.DefaultSelection<Prisma.$LessonPayload>
/**
 * Model LessonGroup
 * 
 */
export type LessonGroup = $Result.DefaultSelection<Prisma.$LessonGroupPayload>
/**
 * Model AIFilterConfig
 * 
 */
export type AIFilterConfig = $Result.DefaultSelection<Prisma.$AIFilterConfigPayload>
/**
 * Model AIFilterMetric
 * 
 */
export type AIFilterMetric = $Result.DefaultSelection<Prisma.$AIFilterMetricPayload>
/**
 * Model ComparativeTheme
 * 
 */
export type ComparativeTheme = $Result.DefaultSelection<Prisma.$ComparativeThemePayload>
/**
 * Model ThemeMetric
 * 
 */
export type ThemeMetric = $Result.DefaultSelection<Prisma.$ThemeMetricPayload>
/**
 * Model NotificationPreference
 * 
 */
export type NotificationPreference = $Result.DefaultSelection<Prisma.$NotificationPreferencePayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model NotificationSchedule
 * 
 */
export type NotificationSchedule = $Result.DefaultSelection<Prisma.$NotificationSchedulePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  SUPER_ADMIN: 'SUPER_ADMIN',
  ORG_ADMIN: 'ORG_ADMIN',
  TEACHER: 'TEACHER',
  MEMBER: 'MEMBER'
};

export type Role = (typeof Role)[keyof typeof Role]


export const IntegrationProvider: {
  PLANNING_CENTER: 'PLANNING_CENTER',
  CCB: 'CCB',
  ELVANTO: 'ELVANTO',
  BREEZE: 'BREEZE',
  FELLOWSHIP_ONE: 'FELLOWSHIP_ONE',
  ROCK_RMS: 'ROCK_RMS'
};

export type IntegrationProvider = (typeof IntegrationProvider)[keyof typeof IntegrationProvider]


export const IntegrationStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  ERROR: 'ERROR',
  PENDING: 'PENDING',
  EXPIRED: 'EXPIRED'
};

export type IntegrationStatus = (typeof IntegrationStatus)[keyof typeof IntegrationStatus]


export const SyncFrequency: {
  HOURLY: 'HOURLY',
  DAILY: 'DAILY',
  WEEKLY: 'WEEKLY',
  MANUAL: 'MANUAL'
};

export type SyncFrequency = (typeof SyncFrequency)[keyof typeof SyncFrequency]


export const SyncStatus: {
  SUCCESS: 'SUCCESS',
  ERROR: 'ERROR',
  PARTIAL: 'PARTIAL'
};

export type SyncStatus = (typeof SyncStatus)[keyof typeof SyncStatus]


export const FilterCategory: {
  RELATIONSHIPS_SEXUALITY: 'RELATIONSHIPS_SEXUALITY',
  MENTAL_HEALTH: 'MENTAL_HEALTH',
  CONTROVERSIAL_DOCTRINE: 'CONTROVERSIAL_DOCTRINE',
  VIOLENCE_ABUSE: 'VIOLENCE_ABUSE',
  SUBSTANCE_USE: 'SUBSTANCE_USE',
  POLITICS: 'POLITICS',
  FAMILY_ISSUES: 'FAMILY_ISSUES',
  DEATH_GRIEF: 'DEATH_GRIEF',
  DOUBTS_FAITH: 'DOUBTS_FAITH',
  PEER_PRESSURE: 'PEER_PRESSURE',
  CUSTOM: 'CUSTOM'
};

export type FilterCategory = (typeof FilterCategory)[keyof typeof FilterCategory]


export const FilterAction: {
  REDIRECT: 'REDIRECT',
  GUIDANCE: 'GUIDANCE',
  BLOCK: 'BLOCK',
  MONITOR: 'MONITOR'
};

export type FilterAction = (typeof FilterAction)[keyof typeof FilterAction]


export const DigestFrequency: {
  DAILY: 'DAILY',
  WEEKLY: 'WEEKLY',
  BIWEEKLY: 'BIWEEKLY',
  MONTHLY: 'MONTHLY'
};

export type DigestFrequency = (typeof DigestFrequency)[keyof typeof DigestFrequency]


export const NotificationType: {
  LESSON_REMINDER: 'LESSON_REMINDER',
  EVENT_REMINDER: 'EVENT_REMINDER',
  ANNOUNCEMENT: 'ANNOUNCEMENT',
  GROUP_UPDATE: 'GROUP_UPDATE',
  LESSON_ASSIGNED: 'LESSON_ASSIGNED',
  COMMENT_REPLY: 'COMMENT_REPLY',
  MENTION: 'MENTION',
  SYNC_COMPLETE: 'SYNC_COMPLETE',
  SYNC_ERROR: 'SYNC_ERROR',
  CUSTOM: 'CUSTOM'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const NotificationDeliveryMethod: {
  EMAIL: 'EMAIL',
  IN_APP: 'IN_APP',
  BOTH: 'BOTH'
};

export type NotificationDeliveryMethod = (typeof NotificationDeliveryMethod)[keyof typeof NotificationDeliveryMethod]


export const NotificationPriority: {
  LOW: 'LOW',
  NORMAL: 'NORMAL',
  HIGH: 'HIGH',
  URGENT: 'URGENT'
};

export type NotificationPriority = (typeof NotificationPriority)[keyof typeof NotificationPriority]


export const NotificationStatus: {
  PENDING: 'PENDING',
  SCHEDULED: 'SCHEDULED',
  SENDING: 'SENDING',
  SENT: 'SENT',
  DELIVERED: 'DELIVERED',
  READ: 'READ',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED'
};

export type NotificationStatus = (typeof NotificationStatus)[keyof typeof NotificationStatus]


export const ScheduleFrequency: {
  ONCE: 'ONCE',
  DAILY: 'DAILY',
  WEEKLY: 'WEEKLY',
  BIWEEKLY: 'BIWEEKLY',
  MONTHLY: 'MONTHLY',
  BEFORE_LESSON: 'BEFORE_LESSON',
  BEFORE_EVENT: 'BEFORE_EVENT'
};

export type ScheduleFrequency = (typeof ScheduleFrequency)[keyof typeof ScheduleFrequency]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type IntegrationProvider = $Enums.IntegrationProvider

export const IntegrationProvider: typeof $Enums.IntegrationProvider

export type IntegrationStatus = $Enums.IntegrationStatus

export const IntegrationStatus: typeof $Enums.IntegrationStatus

export type SyncFrequency = $Enums.SyncFrequency

export const SyncFrequency: typeof $Enums.SyncFrequency

export type SyncStatus = $Enums.SyncStatus

export const SyncStatus: typeof $Enums.SyncStatus

export type FilterCategory = $Enums.FilterCategory

export const FilterCategory: typeof $Enums.FilterCategory

export type FilterAction = $Enums.FilterAction

export const FilterAction: typeof $Enums.FilterAction

export type DigestFrequency = $Enums.DigestFrequency

export const DigestFrequency: typeof $Enums.DigestFrequency

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type NotificationDeliveryMethod = $Enums.NotificationDeliveryMethod

export const NotificationDeliveryMethod: typeof $Enums.NotificationDeliveryMethod

export type NotificationPriority = $Enums.NotificationPriority

export const NotificationPriority: typeof $Enums.NotificationPriority

export type NotificationStatus = $Enums.NotificationStatus

export const NotificationStatus: typeof $Enums.NotificationStatus

export type ScheduleFrequency = $Enums.ScheduleFrequency

export const ScheduleFrequency: typeof $Enums.ScheduleFrequency

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Organizations
 * const organizations = await prisma.organization.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Organizations
   * const organizations = await prisma.organization.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.organization`: Exposes CRUD operations for the **Organization** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organizations
    * const organizations = await prisma.organization.findMany()
    * ```
    */
  get organization(): Prisma.OrganizationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.refreshToken`: Exposes CRUD operations for the **RefreshToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RefreshTokens
    * const refreshTokens = await prisma.refreshToken.findMany()
    * ```
    */
  get refreshToken(): Prisma.RefreshTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.group`: Exposes CRUD operations for the **Group** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Groups
    * const groups = await prisma.group.findMany()
    * ```
    */
  get group(): Prisma.GroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.groupMember`: Exposes CRUD operations for the **GroupMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GroupMembers
    * const groupMembers = await prisma.groupMember.findMany()
    * ```
    */
  get groupMember(): Prisma.GroupMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.externalIntegration`: Exposes CRUD operations for the **ExternalIntegration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExternalIntegrations
    * const externalIntegrations = await prisma.externalIntegration.findMany()
    * ```
    */
  get externalIntegration(): Prisma.ExternalIntegrationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.externalGroupMapping`: Exposes CRUD operations for the **ExternalGroupMapping** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExternalGroupMappings
    * const externalGroupMappings = await prisma.externalGroupMapping.findMany()
    * ```
    */
  get externalGroupMapping(): Prisma.ExternalGroupMappingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.syncLog`: Exposes CRUD operations for the **SyncLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SyncLogs
    * const syncLogs = await prisma.syncLog.findMany()
    * ```
    */
  get syncLog(): Prisma.SyncLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lesson`: Exposes CRUD operations for the **Lesson** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lessons
    * const lessons = await prisma.lesson.findMany()
    * ```
    */
  get lesson(): Prisma.LessonDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lessonGroup`: Exposes CRUD operations for the **LessonGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LessonGroups
    * const lessonGroups = await prisma.lessonGroup.findMany()
    * ```
    */
  get lessonGroup(): Prisma.LessonGroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aIFilterConfig`: Exposes CRUD operations for the **AIFilterConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AIFilterConfigs
    * const aIFilterConfigs = await prisma.aIFilterConfig.findMany()
    * ```
    */
  get aIFilterConfig(): Prisma.AIFilterConfigDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aIFilterMetric`: Exposes CRUD operations for the **AIFilterMetric** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AIFilterMetrics
    * const aIFilterMetrics = await prisma.aIFilterMetric.findMany()
    * ```
    */
  get aIFilterMetric(): Prisma.AIFilterMetricDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comparativeTheme`: Exposes CRUD operations for the **ComparativeTheme** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ComparativeThemes
    * const comparativeThemes = await prisma.comparativeTheme.findMany()
    * ```
    */
  get comparativeTheme(): Prisma.ComparativeThemeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.themeMetric`: Exposes CRUD operations for the **ThemeMetric** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ThemeMetrics
    * const themeMetrics = await prisma.themeMetric.findMany()
    * ```
    */
  get themeMetric(): Prisma.ThemeMetricDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificationPreference`: Exposes CRUD operations for the **NotificationPreference** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationPreferences
    * const notificationPreferences = await prisma.notificationPreference.findMany()
    * ```
    */
  get notificationPreference(): Prisma.NotificationPreferenceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificationSchedule`: Exposes CRUD operations for the **NotificationSchedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationSchedules
    * const notificationSchedules = await prisma.notificationSchedule.findMany()
    * ```
    */
  get notificationSchedule(): Prisma.NotificationScheduleDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.0
   * Query Engine version: 2ba551f319ab1df4bc874a89965d8b3641056773
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Organization: 'Organization',
    User: 'User',
    RefreshToken: 'RefreshToken',
    Group: 'Group',
    GroupMember: 'GroupMember',
    ExternalIntegration: 'ExternalIntegration',
    ExternalGroupMapping: 'ExternalGroupMapping',
    SyncLog: 'SyncLog',
    Lesson: 'Lesson',
    LessonGroup: 'LessonGroup',
    AIFilterConfig: 'AIFilterConfig',
    AIFilterMetric: 'AIFilterMetric',
    ComparativeTheme: 'ComparativeTheme',
    ThemeMetric: 'ThemeMetric',
    NotificationPreference: 'NotificationPreference',
    Notification: 'Notification',
    NotificationSchedule: 'NotificationSchedule'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "organization" | "user" | "refreshToken" | "group" | "groupMember" | "externalIntegration" | "externalGroupMapping" | "syncLog" | "lesson" | "lessonGroup" | "aIFilterConfig" | "aIFilterMetric" | "comparativeTheme" | "themeMetric" | "notificationPreference" | "notification" | "notificationSchedule"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Organization: {
        payload: Prisma.$OrganizationPayload<ExtArgs>
        fields: Prisma.OrganizationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganizationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganizationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findFirst: {
            args: Prisma.OrganizationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganizationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findMany: {
            args: Prisma.OrganizationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          create: {
            args: Prisma.OrganizationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          createMany: {
            args: Prisma.OrganizationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrganizationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          delete: {
            args: Prisma.OrganizationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          update: {
            args: Prisma.OrganizationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          deleteMany: {
            args: Prisma.OrganizationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganizationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrganizationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          upsert: {
            args: Prisma.OrganizationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          aggregate: {
            args: Prisma.OrganizationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganization>
          }
          groupBy: {
            args: Prisma.OrganizationGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganizationGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganizationCountArgs<ExtArgs>
            result: $Utils.Optional<OrganizationCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      RefreshToken: {
        payload: Prisma.$RefreshTokenPayload<ExtArgs>
        fields: Prisma.RefreshTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefreshTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefreshTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findFirst: {
            args: Prisma.RefreshTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefreshTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findMany: {
            args: Prisma.RefreshTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          create: {
            args: Prisma.RefreshTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          createMany: {
            args: Prisma.RefreshTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RefreshTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          delete: {
            args: Prisma.RefreshTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          update: {
            args: Prisma.RefreshTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          deleteMany: {
            args: Prisma.RefreshTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RefreshTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RefreshTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          upsert: {
            args: Prisma.RefreshTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          aggregate: {
            args: Prisma.RefreshTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefreshToken>
          }
          groupBy: {
            args: Prisma.RefreshTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.RefreshTokenCountArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenCountAggregateOutputType> | number
          }
        }
      }
      Group: {
        payload: Prisma.$GroupPayload<ExtArgs>
        fields: Prisma.GroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          findFirst: {
            args: Prisma.GroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          findMany: {
            args: Prisma.GroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>[]
          }
          create: {
            args: Prisma.GroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          createMany: {
            args: Prisma.GroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>[]
          }
          delete: {
            args: Prisma.GroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          update: {
            args: Prisma.GroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          deleteMany: {
            args: Prisma.GroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GroupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>[]
          }
          upsert: {
            args: Prisma.GroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          aggregate: {
            args: Prisma.GroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroup>
          }
          groupBy: {
            args: Prisma.GroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.GroupCountArgs<ExtArgs>
            result: $Utils.Optional<GroupCountAggregateOutputType> | number
          }
        }
      }
      GroupMember: {
        payload: Prisma.$GroupMemberPayload<ExtArgs>
        fields: Prisma.GroupMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GroupMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GroupMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>
          }
          findFirst: {
            args: Prisma.GroupMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GroupMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>
          }
          findMany: {
            args: Prisma.GroupMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>[]
          }
          create: {
            args: Prisma.GroupMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>
          }
          createMany: {
            args: Prisma.GroupMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GroupMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>[]
          }
          delete: {
            args: Prisma.GroupMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>
          }
          update: {
            args: Prisma.GroupMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>
          }
          deleteMany: {
            args: Prisma.GroupMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GroupMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GroupMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>[]
          }
          upsert: {
            args: Prisma.GroupMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMemberPayload>
          }
          aggregate: {
            args: Prisma.GroupMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroupMember>
          }
          groupBy: {
            args: Prisma.GroupMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroupMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.GroupMemberCountArgs<ExtArgs>
            result: $Utils.Optional<GroupMemberCountAggregateOutputType> | number
          }
        }
      }
      ExternalIntegration: {
        payload: Prisma.$ExternalIntegrationPayload<ExtArgs>
        fields: Prisma.ExternalIntegrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExternalIntegrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalIntegrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExternalIntegrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalIntegrationPayload>
          }
          findFirst: {
            args: Prisma.ExternalIntegrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalIntegrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExternalIntegrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalIntegrationPayload>
          }
          findMany: {
            args: Prisma.ExternalIntegrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalIntegrationPayload>[]
          }
          create: {
            args: Prisma.ExternalIntegrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalIntegrationPayload>
          }
          createMany: {
            args: Prisma.ExternalIntegrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExternalIntegrationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalIntegrationPayload>[]
          }
          delete: {
            args: Prisma.ExternalIntegrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalIntegrationPayload>
          }
          update: {
            args: Prisma.ExternalIntegrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalIntegrationPayload>
          }
          deleteMany: {
            args: Prisma.ExternalIntegrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExternalIntegrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExternalIntegrationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalIntegrationPayload>[]
          }
          upsert: {
            args: Prisma.ExternalIntegrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalIntegrationPayload>
          }
          aggregate: {
            args: Prisma.ExternalIntegrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExternalIntegration>
          }
          groupBy: {
            args: Prisma.ExternalIntegrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExternalIntegrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExternalIntegrationCountArgs<ExtArgs>
            result: $Utils.Optional<ExternalIntegrationCountAggregateOutputType> | number
          }
        }
      }
      ExternalGroupMapping: {
        payload: Prisma.$ExternalGroupMappingPayload<ExtArgs>
        fields: Prisma.ExternalGroupMappingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExternalGroupMappingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalGroupMappingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExternalGroupMappingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalGroupMappingPayload>
          }
          findFirst: {
            args: Prisma.ExternalGroupMappingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalGroupMappingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExternalGroupMappingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalGroupMappingPayload>
          }
          findMany: {
            args: Prisma.ExternalGroupMappingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalGroupMappingPayload>[]
          }
          create: {
            args: Prisma.ExternalGroupMappingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalGroupMappingPayload>
          }
          createMany: {
            args: Prisma.ExternalGroupMappingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExternalGroupMappingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalGroupMappingPayload>[]
          }
          delete: {
            args: Prisma.ExternalGroupMappingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalGroupMappingPayload>
          }
          update: {
            args: Prisma.ExternalGroupMappingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalGroupMappingPayload>
          }
          deleteMany: {
            args: Prisma.ExternalGroupMappingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExternalGroupMappingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExternalGroupMappingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalGroupMappingPayload>[]
          }
          upsert: {
            args: Prisma.ExternalGroupMappingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalGroupMappingPayload>
          }
          aggregate: {
            args: Prisma.ExternalGroupMappingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExternalGroupMapping>
          }
          groupBy: {
            args: Prisma.ExternalGroupMappingGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExternalGroupMappingGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExternalGroupMappingCountArgs<ExtArgs>
            result: $Utils.Optional<ExternalGroupMappingCountAggregateOutputType> | number
          }
        }
      }
      SyncLog: {
        payload: Prisma.$SyncLogPayload<ExtArgs>
        fields: Prisma.SyncLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SyncLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SyncLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload>
          }
          findFirst: {
            args: Prisma.SyncLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SyncLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload>
          }
          findMany: {
            args: Prisma.SyncLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload>[]
          }
          create: {
            args: Prisma.SyncLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload>
          }
          createMany: {
            args: Prisma.SyncLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SyncLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload>[]
          }
          delete: {
            args: Prisma.SyncLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload>
          }
          update: {
            args: Prisma.SyncLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload>
          }
          deleteMany: {
            args: Prisma.SyncLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SyncLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SyncLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload>[]
          }
          upsert: {
            args: Prisma.SyncLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncLogPayload>
          }
          aggregate: {
            args: Prisma.SyncLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSyncLog>
          }
          groupBy: {
            args: Prisma.SyncLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<SyncLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.SyncLogCountArgs<ExtArgs>
            result: $Utils.Optional<SyncLogCountAggregateOutputType> | number
          }
        }
      }
      Lesson: {
        payload: Prisma.$LessonPayload<ExtArgs>
        fields: Prisma.LessonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LessonFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LessonFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          findFirst: {
            args: Prisma.LessonFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LessonFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          findMany: {
            args: Prisma.LessonFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>[]
          }
          create: {
            args: Prisma.LessonCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          createMany: {
            args: Prisma.LessonCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LessonCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>[]
          }
          delete: {
            args: Prisma.LessonDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          update: {
            args: Prisma.LessonUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          deleteMany: {
            args: Prisma.LessonDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LessonUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LessonUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>[]
          }
          upsert: {
            args: Prisma.LessonUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          aggregate: {
            args: Prisma.LessonAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLesson>
          }
          groupBy: {
            args: Prisma.LessonGroupByArgs<ExtArgs>
            result: $Utils.Optional<LessonGroupByOutputType>[]
          }
          count: {
            args: Prisma.LessonCountArgs<ExtArgs>
            result: $Utils.Optional<LessonCountAggregateOutputType> | number
          }
        }
      }
      LessonGroup: {
        payload: Prisma.$LessonGroupPayload<ExtArgs>
        fields: Prisma.LessonGroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LessonGroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonGroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LessonGroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonGroupPayload>
          }
          findFirst: {
            args: Prisma.LessonGroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonGroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LessonGroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonGroupPayload>
          }
          findMany: {
            args: Prisma.LessonGroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonGroupPayload>[]
          }
          create: {
            args: Prisma.LessonGroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonGroupPayload>
          }
          createMany: {
            args: Prisma.LessonGroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LessonGroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonGroupPayload>[]
          }
          delete: {
            args: Prisma.LessonGroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonGroupPayload>
          }
          update: {
            args: Prisma.LessonGroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonGroupPayload>
          }
          deleteMany: {
            args: Prisma.LessonGroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LessonGroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LessonGroupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonGroupPayload>[]
          }
          upsert: {
            args: Prisma.LessonGroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonGroupPayload>
          }
          aggregate: {
            args: Prisma.LessonGroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLessonGroup>
          }
          groupBy: {
            args: Prisma.LessonGroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<LessonGroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.LessonGroupCountArgs<ExtArgs>
            result: $Utils.Optional<LessonGroupCountAggregateOutputType> | number
          }
        }
      }
      AIFilterConfig: {
        payload: Prisma.$AIFilterConfigPayload<ExtArgs>
        fields: Prisma.AIFilterConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AIFilterConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIFilterConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AIFilterConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIFilterConfigPayload>
          }
          findFirst: {
            args: Prisma.AIFilterConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIFilterConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AIFilterConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIFilterConfigPayload>
          }
          findMany: {
            args: Prisma.AIFilterConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIFilterConfigPayload>[]
          }
          create: {
            args: Prisma.AIFilterConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIFilterConfigPayload>
          }
          createMany: {
            args: Prisma.AIFilterConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AIFilterConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIFilterConfigPayload>[]
          }
          delete: {
            args: Prisma.AIFilterConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIFilterConfigPayload>
          }
          update: {
            args: Prisma.AIFilterConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIFilterConfigPayload>
          }
          deleteMany: {
            args: Prisma.AIFilterConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AIFilterConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AIFilterConfigUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIFilterConfigPayload>[]
          }
          upsert: {
            args: Prisma.AIFilterConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIFilterConfigPayload>
          }
          aggregate: {
            args: Prisma.AIFilterConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAIFilterConfig>
          }
          groupBy: {
            args: Prisma.AIFilterConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<AIFilterConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.AIFilterConfigCountArgs<ExtArgs>
            result: $Utils.Optional<AIFilterConfigCountAggregateOutputType> | number
          }
        }
      }
      AIFilterMetric: {
        payload: Prisma.$AIFilterMetricPayload<ExtArgs>
        fields: Prisma.AIFilterMetricFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AIFilterMetricFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIFilterMetricPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AIFilterMetricFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIFilterMetricPayload>
          }
          findFirst: {
            args: Prisma.AIFilterMetricFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIFilterMetricPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AIFilterMetricFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIFilterMetricPayload>
          }
          findMany: {
            args: Prisma.AIFilterMetricFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIFilterMetricPayload>[]
          }
          create: {
            args: Prisma.AIFilterMetricCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIFilterMetricPayload>
          }
          createMany: {
            args: Prisma.AIFilterMetricCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AIFilterMetricCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIFilterMetricPayload>[]
          }
          delete: {
            args: Prisma.AIFilterMetricDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIFilterMetricPayload>
          }
          update: {
            args: Prisma.AIFilterMetricUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIFilterMetricPayload>
          }
          deleteMany: {
            args: Prisma.AIFilterMetricDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AIFilterMetricUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AIFilterMetricUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIFilterMetricPayload>[]
          }
          upsert: {
            args: Prisma.AIFilterMetricUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIFilterMetricPayload>
          }
          aggregate: {
            args: Prisma.AIFilterMetricAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAIFilterMetric>
          }
          groupBy: {
            args: Prisma.AIFilterMetricGroupByArgs<ExtArgs>
            result: $Utils.Optional<AIFilterMetricGroupByOutputType>[]
          }
          count: {
            args: Prisma.AIFilterMetricCountArgs<ExtArgs>
            result: $Utils.Optional<AIFilterMetricCountAggregateOutputType> | number
          }
        }
      }
      ComparativeTheme: {
        payload: Prisma.$ComparativeThemePayload<ExtArgs>
        fields: Prisma.ComparativeThemeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComparativeThemeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComparativeThemePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComparativeThemeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComparativeThemePayload>
          }
          findFirst: {
            args: Prisma.ComparativeThemeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComparativeThemePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComparativeThemeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComparativeThemePayload>
          }
          findMany: {
            args: Prisma.ComparativeThemeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComparativeThemePayload>[]
          }
          create: {
            args: Prisma.ComparativeThemeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComparativeThemePayload>
          }
          createMany: {
            args: Prisma.ComparativeThemeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ComparativeThemeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComparativeThemePayload>[]
          }
          delete: {
            args: Prisma.ComparativeThemeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComparativeThemePayload>
          }
          update: {
            args: Prisma.ComparativeThemeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComparativeThemePayload>
          }
          deleteMany: {
            args: Prisma.ComparativeThemeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ComparativeThemeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ComparativeThemeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComparativeThemePayload>[]
          }
          upsert: {
            args: Prisma.ComparativeThemeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComparativeThemePayload>
          }
          aggregate: {
            args: Prisma.ComparativeThemeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComparativeTheme>
          }
          groupBy: {
            args: Prisma.ComparativeThemeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComparativeThemeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComparativeThemeCountArgs<ExtArgs>
            result: $Utils.Optional<ComparativeThemeCountAggregateOutputType> | number
          }
        }
      }
      ThemeMetric: {
        payload: Prisma.$ThemeMetricPayload<ExtArgs>
        fields: Prisma.ThemeMetricFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ThemeMetricFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemeMetricPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ThemeMetricFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemeMetricPayload>
          }
          findFirst: {
            args: Prisma.ThemeMetricFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemeMetricPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ThemeMetricFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemeMetricPayload>
          }
          findMany: {
            args: Prisma.ThemeMetricFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemeMetricPayload>[]
          }
          create: {
            args: Prisma.ThemeMetricCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemeMetricPayload>
          }
          createMany: {
            args: Prisma.ThemeMetricCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ThemeMetricCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemeMetricPayload>[]
          }
          delete: {
            args: Prisma.ThemeMetricDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemeMetricPayload>
          }
          update: {
            args: Prisma.ThemeMetricUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemeMetricPayload>
          }
          deleteMany: {
            args: Prisma.ThemeMetricDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ThemeMetricUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ThemeMetricUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemeMetricPayload>[]
          }
          upsert: {
            args: Prisma.ThemeMetricUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemeMetricPayload>
          }
          aggregate: {
            args: Prisma.ThemeMetricAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateThemeMetric>
          }
          groupBy: {
            args: Prisma.ThemeMetricGroupByArgs<ExtArgs>
            result: $Utils.Optional<ThemeMetricGroupByOutputType>[]
          }
          count: {
            args: Prisma.ThemeMetricCountArgs<ExtArgs>
            result: $Utils.Optional<ThemeMetricCountAggregateOutputType> | number
          }
        }
      }
      NotificationPreference: {
        payload: Prisma.$NotificationPreferencePayload<ExtArgs>
        fields: Prisma.NotificationPreferenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationPreferenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          findFirst: {
            args: Prisma.NotificationPreferenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationPreferenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          findMany: {
            args: Prisma.NotificationPreferenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[]
          }
          create: {
            args: Prisma.NotificationPreferenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          createMany: {
            args: Prisma.NotificationPreferenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationPreferenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[]
          }
          delete: {
            args: Prisma.NotificationPreferenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          update: {
            args: Prisma.NotificationPreferenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          deleteMany: {
            args: Prisma.NotificationPreferenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationPreferenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationPreferenceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[]
          }
          upsert: {
            args: Prisma.NotificationPreferenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          aggregate: {
            args: Prisma.NotificationPreferenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationPreference>
          }
          groupBy: {
            args: Prisma.NotificationPreferenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationPreferenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationPreferenceCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationPreferenceCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      NotificationSchedule: {
        payload: Prisma.$NotificationSchedulePayload<ExtArgs>
        fields: Prisma.NotificationScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationScheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationScheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSchedulePayload>
          }
          findFirst: {
            args: Prisma.NotificationScheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationScheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSchedulePayload>
          }
          findMany: {
            args: Prisma.NotificationScheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSchedulePayload>[]
          }
          create: {
            args: Prisma.NotificationScheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSchedulePayload>
          }
          createMany: {
            args: Prisma.NotificationScheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationScheduleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSchedulePayload>[]
          }
          delete: {
            args: Prisma.NotificationScheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSchedulePayload>
          }
          update: {
            args: Prisma.NotificationScheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSchedulePayload>
          }
          deleteMany: {
            args: Prisma.NotificationScheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationScheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationScheduleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSchedulePayload>[]
          }
          upsert: {
            args: Prisma.NotificationScheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSchedulePayload>
          }
          aggregate: {
            args: Prisma.NotificationScheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationSchedule>
          }
          groupBy: {
            args: Prisma.NotificationScheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationScheduleCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationScheduleCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    organization?: OrganizationOmit
    user?: UserOmit
    refreshToken?: RefreshTokenOmit
    group?: GroupOmit
    groupMember?: GroupMemberOmit
    externalIntegration?: ExternalIntegrationOmit
    externalGroupMapping?: ExternalGroupMappingOmit
    syncLog?: SyncLogOmit
    lesson?: LessonOmit
    lessonGroup?: LessonGroupOmit
    aIFilterConfig?: AIFilterConfigOmit
    aIFilterMetric?: AIFilterMetricOmit
    comparativeTheme?: ComparativeThemeOmit
    themeMetric?: ThemeMetricOmit
    notificationPreference?: NotificationPreferenceOmit
    notification?: NotificationOmit
    notificationSchedule?: NotificationScheduleOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type OrganizationCountOutputType
   */

  export type OrganizationCountOutputType = {
    users: number
    groups: number
    integrations: number
    lessons: number
    aiFilterConfigs: number
    comparativeThemes: number
  }

  export type OrganizationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | OrganizationCountOutputTypeCountUsersArgs
    groups?: boolean | OrganizationCountOutputTypeCountGroupsArgs
    integrations?: boolean | OrganizationCountOutputTypeCountIntegrationsArgs
    lessons?: boolean | OrganizationCountOutputTypeCountLessonsArgs
    aiFilterConfigs?: boolean | OrganizationCountOutputTypeCountAiFilterConfigsArgs
    comparativeThemes?: boolean | OrganizationCountOutputTypeCountComparativeThemesArgs
  }

  // Custom InputTypes
  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationCountOutputType
     */
    select?: OrganizationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountIntegrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExternalIntegrationWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountLessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountAiFilterConfigsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIFilterConfigWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountComparativeThemesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComparativeThemeWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    groupMemberships: number
    refreshTokens: number
    notifications: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    groupMemberships?: boolean | UserCountOutputTypeCountGroupMembershipsArgs
    refreshTokens?: boolean | UserCountOutputTypeCountRefreshTokensArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGroupMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRefreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type GroupCountOutputType
   */

  export type GroupCountOutputType = {
    members: number
    mappings: number
    lessons: number
  }

  export type GroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | GroupCountOutputTypeCountMembersArgs
    mappings?: boolean | GroupCountOutputTypeCountMappingsArgs
    lessons?: boolean | GroupCountOutputTypeCountLessonsArgs
  }

  // Custom InputTypes
  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupCountOutputType
     */
    select?: GroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupMemberWhereInput
  }

  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeCountMappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExternalGroupMappingWhereInput
  }

  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeCountLessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonGroupWhereInput
  }


  /**
   * Count Type ExternalIntegrationCountOutputType
   */

  export type ExternalIntegrationCountOutputType = {
    groupMappings: number
    syncLogs: number
  }

  export type ExternalIntegrationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    groupMappings?: boolean | ExternalIntegrationCountOutputTypeCountGroupMappingsArgs
    syncLogs?: boolean | ExternalIntegrationCountOutputTypeCountSyncLogsArgs
  }

  // Custom InputTypes
  /**
   * ExternalIntegrationCountOutputType without action
   */
  export type ExternalIntegrationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalIntegrationCountOutputType
     */
    select?: ExternalIntegrationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExternalIntegrationCountOutputType without action
   */
  export type ExternalIntegrationCountOutputTypeCountGroupMappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExternalGroupMappingWhereInput
  }

  /**
   * ExternalIntegrationCountOutputType without action
   */
  export type ExternalIntegrationCountOutputTypeCountSyncLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SyncLogWhereInput
  }


  /**
   * Count Type LessonCountOutputType
   */

  export type LessonCountOutputType = {
    groups: number
  }

  export type LessonCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    groups?: boolean | LessonCountOutputTypeCountGroupsArgs
  }

  // Custom InputTypes
  /**
   * LessonCountOutputType without action
   */
  export type LessonCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonCountOutputType
     */
    select?: LessonCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LessonCountOutputType without action
   */
  export type LessonCountOutputTypeCountGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonGroupWhereInput
  }


  /**
   * Count Type AIFilterConfigCountOutputType
   */

  export type AIFilterConfigCountOutputType = {
    metrics: number
  }

  export type AIFilterConfigCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    metrics?: boolean | AIFilterConfigCountOutputTypeCountMetricsArgs
  }

  // Custom InputTypes
  /**
   * AIFilterConfigCountOutputType without action
   */
  export type AIFilterConfigCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIFilterConfigCountOutputType
     */
    select?: AIFilterConfigCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AIFilterConfigCountOutputType without action
   */
  export type AIFilterConfigCountOutputTypeCountMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIFilterMetricWhereInput
  }


  /**
   * Count Type ComparativeThemeCountOutputType
   */

  export type ComparativeThemeCountOutputType = {
    metrics: number
  }

  export type ComparativeThemeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    metrics?: boolean | ComparativeThemeCountOutputTypeCountMetricsArgs
  }

  // Custom InputTypes
  /**
   * ComparativeThemeCountOutputType without action
   */
  export type ComparativeThemeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComparativeThemeCountOutputType
     */
    select?: ComparativeThemeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ComparativeThemeCountOutputType without action
   */
  export type ComparativeThemeCountOutputTypeCountMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ThemeMetricWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Organization
   */

  export type AggregateOrganization = {
    _count: OrganizationCountAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  export type OrganizationMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    timezone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    timezone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    timezone: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrganizationMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    timezone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganizationMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    timezone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganizationCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    timezone?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrganizationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organization to aggregate.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Organizations
    **/
    _count?: true | OrganizationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationMaxAggregateInputType
  }

  export type GetOrganizationAggregateType<T extends OrganizationAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganization[P]>
      : GetScalarType<T[P], AggregateOrganization[P]>
  }




  export type OrganizationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationWhereInput
    orderBy?: OrganizationOrderByWithAggregationInput | OrganizationOrderByWithAggregationInput[]
    by: OrganizationScalarFieldEnum[] | OrganizationScalarFieldEnum
    having?: OrganizationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationCountAggregateInputType | true
    _min?: OrganizationMinAggregateInputType
    _max?: OrganizationMaxAggregateInputType
  }

  export type OrganizationGroupByOutputType = {
    id: string
    name: string
    slug: string
    timezone: string
    createdAt: Date
    updatedAt: Date
    _count: OrganizationCountAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  type GetOrganizationGroupByPayload<T extends OrganizationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    timezone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Organization$usersArgs<ExtArgs>
    groups?: boolean | Organization$groupsArgs<ExtArgs>
    integrations?: boolean | Organization$integrationsArgs<ExtArgs>
    lessons?: boolean | Organization$lessonsArgs<ExtArgs>
    aiFilterConfigs?: boolean | Organization$aiFilterConfigsArgs<ExtArgs>
    comparativeThemes?: boolean | Organization$comparativeThemesArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    timezone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    timezone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    timezone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrganizationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "timezone" | "createdAt" | "updatedAt", ExtArgs["result"]["organization"]>
  export type OrganizationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Organization$usersArgs<ExtArgs>
    groups?: boolean | Organization$groupsArgs<ExtArgs>
    integrations?: boolean | Organization$integrationsArgs<ExtArgs>
    lessons?: boolean | Organization$lessonsArgs<ExtArgs>
    aiFilterConfigs?: boolean | Organization$aiFilterConfigsArgs<ExtArgs>
    comparativeThemes?: boolean | Organization$comparativeThemesArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrganizationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type OrganizationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $OrganizationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Organization"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      groups: Prisma.$GroupPayload<ExtArgs>[]
      integrations: Prisma.$ExternalIntegrationPayload<ExtArgs>[]
      lessons: Prisma.$LessonPayload<ExtArgs>[]
      aiFilterConfigs: Prisma.$AIFilterConfigPayload<ExtArgs>[]
      comparativeThemes: Prisma.$ComparativeThemePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      timezone: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["organization"]>
    composites: {}
  }

  type OrganizationGetPayload<S extends boolean | null | undefined | OrganizationDefaultArgs> = $Result.GetResult<Prisma.$OrganizationPayload, S>

  type OrganizationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrganizationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrganizationCountAggregateInputType | true
    }

  export interface OrganizationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Organization'], meta: { name: 'Organization' } }
    /**
     * Find zero or one Organization that matches the filter.
     * @param {OrganizationFindUniqueArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganizationFindUniqueArgs>(args: SelectSubset<T, OrganizationFindUniqueArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Organization that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrganizationFindUniqueOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganizationFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganizationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Organization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganizationFindFirstArgs>(args?: SelectSubset<T, OrganizationFindFirstArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Organization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganizationFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganizationFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Organizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organizations
     * const organizations = await prisma.organization.findMany()
     * 
     * // Get first 10 Organizations
     * const organizations = await prisma.organization.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationWithIdOnly = await prisma.organization.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrganizationFindManyArgs>(args?: SelectSubset<T, OrganizationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Organization.
     * @param {OrganizationCreateArgs} args - Arguments to create a Organization.
     * @example
     * // Create one Organization
     * const Organization = await prisma.organization.create({
     *   data: {
     *     // ... data to create a Organization
     *   }
     * })
     * 
     */
    create<T extends OrganizationCreateArgs>(args: SelectSubset<T, OrganizationCreateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Organizations.
     * @param {OrganizationCreateManyArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganizationCreateManyArgs>(args?: SelectSubset<T, OrganizationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Organizations and returns the data saved in the database.
     * @param {OrganizationCreateManyAndReturnArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrganizationCreateManyAndReturnArgs>(args?: SelectSubset<T, OrganizationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Organization.
     * @param {OrganizationDeleteArgs} args - Arguments to delete one Organization.
     * @example
     * // Delete one Organization
     * const Organization = await prisma.organization.delete({
     *   where: {
     *     // ... filter to delete one Organization
     *   }
     * })
     * 
     */
    delete<T extends OrganizationDeleteArgs>(args: SelectSubset<T, OrganizationDeleteArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Organization.
     * @param {OrganizationUpdateArgs} args - Arguments to update one Organization.
     * @example
     * // Update one Organization
     * const organization = await prisma.organization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganizationUpdateArgs>(args: SelectSubset<T, OrganizationUpdateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Organizations.
     * @param {OrganizationDeleteManyArgs} args - Arguments to filter Organizations to delete.
     * @example
     * // Delete a few Organizations
     * const { count } = await prisma.organization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganizationDeleteManyArgs>(args?: SelectSubset<T, OrganizationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganizationUpdateManyArgs>(args: SelectSubset<T, OrganizationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations and returns the data updated in the database.
     * @param {OrganizationUpdateManyAndReturnArgs} args - Arguments to update many Organizations.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrganizationUpdateManyAndReturnArgs>(args: SelectSubset<T, OrganizationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Organization.
     * @param {OrganizationUpsertArgs} args - Arguments to update or create a Organization.
     * @example
     * // Update or create a Organization
     * const organization = await prisma.organization.upsert({
     *   create: {
     *     // ... data to create a Organization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organization we want to update
     *   }
     * })
     */
    upsert<T extends OrganizationUpsertArgs>(args: SelectSubset<T, OrganizationUpsertArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationCountArgs} args - Arguments to filter Organizations to count.
     * @example
     * // Count the number of Organizations
     * const count = await prisma.organization.count({
     *   where: {
     *     // ... the filter for the Organizations we want to count
     *   }
     * })
    **/
    count<T extends OrganizationCountArgs>(
      args?: Subset<T, OrganizationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationAggregateArgs>(args: Subset<T, OrganizationAggregateArgs>): Prisma.PrismaPromise<GetOrganizationAggregateType<T>>

    /**
     * Group by Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Organization model
   */
  readonly fields: OrganizationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Organization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Organization$usersArgs<ExtArgs> = {}>(args?: Subset<T, Organization$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    groups<T extends Organization$groupsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$groupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    integrations<T extends Organization$integrationsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$integrationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExternalIntegrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lessons<T extends Organization$lessonsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$lessonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    aiFilterConfigs<T extends Organization$aiFilterConfigsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$aiFilterConfigsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIFilterConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comparativeThemes<T extends Organization$comparativeThemesArgs<ExtArgs> = {}>(args?: Subset<T, Organization$comparativeThemesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComparativeThemePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Organization model
   */
  interface OrganizationFieldRefs {
    readonly id: FieldRef<"Organization", 'String'>
    readonly name: FieldRef<"Organization", 'String'>
    readonly slug: FieldRef<"Organization", 'String'>
    readonly timezone: FieldRef<"Organization", 'String'>
    readonly createdAt: FieldRef<"Organization", 'DateTime'>
    readonly updatedAt: FieldRef<"Organization", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Organization findUnique
   */
  export type OrganizationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findUniqueOrThrow
   */
  export type OrganizationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findFirst
   */
  export type OrganizationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findFirstOrThrow
   */
  export type OrganizationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findMany
   */
  export type OrganizationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organizations to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization create
   */
  export type OrganizationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to create a Organization.
     */
    data: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
  }

  /**
   * Organization createMany
   */
  export type OrganizationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organization createManyAndReturn
   */
  export type OrganizationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organization update
   */
  export type OrganizationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to update a Organization.
     */
    data: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
    /**
     * Choose, which Organization to update.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization updateMany
   */
  export type OrganizationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to update.
     */
    limit?: number
  }

  /**
   * Organization updateManyAndReturn
   */
  export type OrganizationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to update.
     */
    limit?: number
  }

  /**
   * Organization upsert
   */
  export type OrganizationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The filter to search for the Organization to update in case it exists.
     */
    where: OrganizationWhereUniqueInput
    /**
     * In case the Organization found by the `where` argument doesn't exist, create a new Organization with this data.
     */
    create: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
    /**
     * In case the Organization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
  }

  /**
   * Organization delete
   */
  export type OrganizationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter which Organization to delete.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization deleteMany
   */
  export type OrganizationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organizations to delete
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to delete.
     */
    limit?: number
  }

  /**
   * Organization.users
   */
  export type Organization$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Organization.groups
   */
  export type Organization$groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    where?: GroupWhereInput
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    cursor?: GroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Organization.integrations
   */
  export type Organization$integrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalIntegration
     */
    select?: ExternalIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalIntegration
     */
    omit?: ExternalIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalIntegrationInclude<ExtArgs> | null
    where?: ExternalIntegrationWhereInput
    orderBy?: ExternalIntegrationOrderByWithRelationInput | ExternalIntegrationOrderByWithRelationInput[]
    cursor?: ExternalIntegrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExternalIntegrationScalarFieldEnum | ExternalIntegrationScalarFieldEnum[]
  }

  /**
   * Organization.lessons
   */
  export type Organization$lessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    where?: LessonWhereInput
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    cursor?: LessonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Organization.aiFilterConfigs
   */
  export type Organization$aiFilterConfigsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIFilterConfig
     */
    select?: AIFilterConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIFilterConfig
     */
    omit?: AIFilterConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIFilterConfigInclude<ExtArgs> | null
    where?: AIFilterConfigWhereInput
    orderBy?: AIFilterConfigOrderByWithRelationInput | AIFilterConfigOrderByWithRelationInput[]
    cursor?: AIFilterConfigWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AIFilterConfigScalarFieldEnum | AIFilterConfigScalarFieldEnum[]
  }

  /**
   * Organization.comparativeThemes
   */
  export type Organization$comparativeThemesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComparativeTheme
     */
    select?: ComparativeThemeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComparativeTheme
     */
    omit?: ComparativeThemeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComparativeThemeInclude<ExtArgs> | null
    where?: ComparativeThemeWhereInput
    orderBy?: ComparativeThemeOrderByWithRelationInput | ComparativeThemeOrderByWithRelationInput[]
    cursor?: ComparativeThemeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComparativeThemeScalarFieldEnum | ComparativeThemeScalarFieldEnum[]
  }

  /**
   * Organization without action
   */
  export type OrganizationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    firstName: string | null
    lastName: string | null
    role: $Enums.Role | null
    organizationId: string | null
    isActive: boolean | null
    externalId: string | null
    lastLoginAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    firstName: string | null
    lastName: string | null
    role: $Enums.Role | null
    organizationId: string | null
    isActive: boolean | null
    externalId: string | null
    lastLoginAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    passwordHash: number
    firstName: number
    lastName: number
    role: number
    organizationId: number
    isActive: number
    externalId: number
    externalData: number
    lastLoginAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    role?: true
    organizationId?: true
    isActive?: true
    externalId?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    role?: true
    organizationId?: true
    isActive?: true
    externalId?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    role?: true
    organizationId?: true
    isActive?: true
    externalId?: true
    externalData?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role: $Enums.Role
    organizationId: string
    isActive: boolean
    externalId: string | null
    externalData: JsonValue | null
    lastLoginAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    organizationId?: boolean
    isActive?: boolean
    externalId?: boolean
    externalData?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    groupMemberships?: boolean | User$groupMembershipsArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    notificationPreference?: boolean | User$notificationPreferenceArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    organizationId?: boolean
    isActive?: boolean
    externalId?: boolean
    externalData?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    organizationId?: boolean
    isActive?: boolean
    externalId?: boolean
    externalData?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    organizationId?: boolean
    isActive?: boolean
    externalId?: boolean
    externalData?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "passwordHash" | "firstName" | "lastName" | "role" | "organizationId" | "isActive" | "externalId" | "externalData" | "lastLoginAt" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    groupMemberships?: boolean | User$groupMembershipsArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    notificationPreference?: boolean | User$notificationPreferenceArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      groupMemberships: Prisma.$GroupMemberPayload<ExtArgs>[]
      refreshTokens: Prisma.$RefreshTokenPayload<ExtArgs>[]
      notificationPreference: Prisma.$NotificationPreferencePayload<ExtArgs> | null
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      passwordHash: string
      firstName: string
      lastName: string
      role: $Enums.Role
      organizationId: string
      isActive: boolean
      externalId: string | null
      externalData: Prisma.JsonValue | null
      lastLoginAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    groupMemberships<T extends User$groupMembershipsArgs<ExtArgs> = {}>(args?: Subset<T, User$groupMembershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    refreshTokens<T extends User$refreshTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$refreshTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notificationPreference<T extends User$notificationPreferenceArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationPreferenceArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly organizationId: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly externalId: FieldRef<"User", 'String'>
    readonly externalData: FieldRef<"User", 'Json'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.groupMemberships
   */
  export type User$groupMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    where?: GroupMemberWhereInput
    orderBy?: GroupMemberOrderByWithRelationInput | GroupMemberOrderByWithRelationInput[]
    cursor?: GroupMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupMemberScalarFieldEnum | GroupMemberScalarFieldEnum[]
  }

  /**
   * User.refreshTokens
   */
  export type User$refreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    cursor?: RefreshTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * User.notificationPreference
   */
  export type User$notificationPreferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    where?: NotificationPreferenceWhereInput
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model RefreshToken
   */

  export type AggregateRefreshToken = {
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  export type RefreshTokenMinAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type RefreshTokenMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type RefreshTokenCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type RefreshTokenMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
  }

  export type RefreshTokenMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
  }

  export type RefreshTokenCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type RefreshTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshToken to aggregate.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RefreshTokens
    **/
    _count?: true | RefreshTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefreshTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type GetRefreshTokenAggregateType<T extends RefreshTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateRefreshToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefreshToken[P]>
      : GetScalarType<T[P], AggregateRefreshToken[P]>
  }




  export type RefreshTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithAggregationInput | RefreshTokenOrderByWithAggregationInput[]
    by: RefreshTokenScalarFieldEnum[] | RefreshTokenScalarFieldEnum
    having?: RefreshTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefreshTokenCountAggregateInputType | true
    _min?: RefreshTokenMinAggregateInputType
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type RefreshTokenGroupByOutputType = {
    id: string
    userId: string
    token: string
    expiresAt: Date
    createdAt: Date
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  type GetRefreshTokenGroupByPayload<T extends RefreshTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefreshTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefreshTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
            : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
        }
      >
    >


  export type RefreshTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type RefreshTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "token" | "expiresAt" | "createdAt", ExtArgs["result"]["refreshToken"]>
  export type RefreshTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RefreshTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RefreshToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      token: string
      expiresAt: Date
      createdAt: Date
    }, ExtArgs["result"]["refreshToken"]>
    composites: {}
  }

  type RefreshTokenGetPayload<S extends boolean | null | undefined | RefreshTokenDefaultArgs> = $Result.GetResult<Prisma.$RefreshTokenPayload, S>

  type RefreshTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RefreshTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RefreshTokenCountAggregateInputType | true
    }

  export interface RefreshTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RefreshToken'], meta: { name: 'RefreshToken' } }
    /**
     * Find zero or one RefreshToken that matches the filter.
     * @param {RefreshTokenFindUniqueArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefreshTokenFindUniqueArgs>(args: SelectSubset<T, RefreshTokenFindUniqueArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RefreshToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RefreshTokenFindUniqueOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefreshTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, RefreshTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefreshToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefreshTokenFindFirstArgs>(args?: SelectSubset<T, RefreshTokenFindFirstArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefreshToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefreshTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, RefreshTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RefreshTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany()
     * 
     * // Get first 10 RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RefreshTokenFindManyArgs>(args?: SelectSubset<T, RefreshTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RefreshToken.
     * @param {RefreshTokenCreateArgs} args - Arguments to create a RefreshToken.
     * @example
     * // Create one RefreshToken
     * const RefreshToken = await prisma.refreshToken.create({
     *   data: {
     *     // ... data to create a RefreshToken
     *   }
     * })
     * 
     */
    create<T extends RefreshTokenCreateArgs>(args: SelectSubset<T, RefreshTokenCreateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RefreshTokens.
     * @param {RefreshTokenCreateManyArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RefreshTokenCreateManyArgs>(args?: SelectSubset<T, RefreshTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RefreshTokens and returns the data saved in the database.
     * @param {RefreshTokenCreateManyAndReturnArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RefreshTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, RefreshTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RefreshToken.
     * @param {RefreshTokenDeleteArgs} args - Arguments to delete one RefreshToken.
     * @example
     * // Delete one RefreshToken
     * const RefreshToken = await prisma.refreshToken.delete({
     *   where: {
     *     // ... filter to delete one RefreshToken
     *   }
     * })
     * 
     */
    delete<T extends RefreshTokenDeleteArgs>(args: SelectSubset<T, RefreshTokenDeleteArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RefreshToken.
     * @param {RefreshTokenUpdateArgs} args - Arguments to update one RefreshToken.
     * @example
     * // Update one RefreshToken
     * const refreshToken = await prisma.refreshToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RefreshTokenUpdateArgs>(args: SelectSubset<T, RefreshTokenUpdateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RefreshTokens.
     * @param {RefreshTokenDeleteManyArgs} args - Arguments to filter RefreshTokens to delete.
     * @example
     * // Delete a few RefreshTokens
     * const { count } = await prisma.refreshToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RefreshTokenDeleteManyArgs>(args?: SelectSubset<T, RefreshTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RefreshTokenUpdateManyArgs>(args: SelectSubset<T, RefreshTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens and returns the data updated in the database.
     * @param {RefreshTokenUpdateManyAndReturnArgs} args - Arguments to update many RefreshTokens.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RefreshTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, RefreshTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RefreshToken.
     * @param {RefreshTokenUpsertArgs} args - Arguments to update or create a RefreshToken.
     * @example
     * // Update or create a RefreshToken
     * const refreshToken = await prisma.refreshToken.upsert({
     *   create: {
     *     // ... data to create a RefreshToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RefreshToken we want to update
     *   }
     * })
     */
    upsert<T extends RefreshTokenUpsertArgs>(args: SelectSubset<T, RefreshTokenUpsertArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenCountArgs} args - Arguments to filter RefreshTokens to count.
     * @example
     * // Count the number of RefreshTokens
     * const count = await prisma.refreshToken.count({
     *   where: {
     *     // ... the filter for the RefreshTokens we want to count
     *   }
     * })
    **/
    count<T extends RefreshTokenCountArgs>(
      args?: Subset<T, RefreshTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefreshTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefreshTokenAggregateArgs>(args: Subset<T, RefreshTokenAggregateArgs>): Prisma.PrismaPromise<GetRefreshTokenAggregateType<T>>

    /**
     * Group by RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefreshTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefreshTokenGroupByArgs['orderBy'] }
        : { orderBy?: RefreshTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefreshTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefreshTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RefreshToken model
   */
  readonly fields: RefreshTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RefreshToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefreshTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RefreshToken model
   */
  interface RefreshTokenFieldRefs {
    readonly id: FieldRef<"RefreshToken", 'String'>
    readonly userId: FieldRef<"RefreshToken", 'String'>
    readonly token: FieldRef<"RefreshToken", 'String'>
    readonly expiresAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly createdAt: FieldRef<"RefreshToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RefreshToken findUnique
   */
  export type RefreshTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findUniqueOrThrow
   */
  export type RefreshTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findFirst
   */
  export type RefreshTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findFirstOrThrow
   */
  export type RefreshTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findMany
   */
  export type RefreshTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshTokens to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken create
   */
  export type RefreshTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a RefreshToken.
     */
    data: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
  }

  /**
   * RefreshToken createMany
   */
  export type RefreshTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RefreshToken createManyAndReturn
   */
  export type RefreshTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken update
   */
  export type RefreshTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a RefreshToken.
     */
    data: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
    /**
     * Choose, which RefreshToken to update.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken updateMany
   */
  export type RefreshTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to update.
     */
    limit?: number
  }

  /**
   * RefreshToken updateManyAndReturn
   */
  export type RefreshTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken upsert
   */
  export type RefreshTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the RefreshToken to update in case it exists.
     */
    where: RefreshTokenWhereUniqueInput
    /**
     * In case the RefreshToken found by the `where` argument doesn't exist, create a new RefreshToken with this data.
     */
    create: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
    /**
     * In case the RefreshToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
  }

  /**
   * RefreshToken delete
   */
  export type RefreshTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter which RefreshToken to delete.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken deleteMany
   */
  export type RefreshTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshTokens to delete
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to delete.
     */
    limit?: number
  }

  /**
   * RefreshToken without action
   */
  export type RefreshTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
  }


  /**
   * Model Group
   */

  export type AggregateGroup = {
    _count: GroupCountAggregateOutputType | null
    _avg: GroupAvgAggregateOutputType | null
    _sum: GroupSumAggregateOutputType | null
    _min: GroupMinAggregateOutputType | null
    _max: GroupMaxAggregateOutputType | null
  }

  export type GroupAvgAggregateOutputType = {
    ageMin: number | null
    ageMax: number | null
  }

  export type GroupSumAggregateOutputType = {
    ageMin: number | null
    ageMax: number | null
  }

  export type GroupMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    organizationId: string | null
    externalId: string | null
    ageMin: number | null
    ageMax: number | null
    grade: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GroupMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    organizationId: string | null
    externalId: string | null
    ageMin: number | null
    ageMax: number | null
    grade: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GroupCountAggregateOutputType = {
    id: number
    name: number
    description: number
    organizationId: number
    externalId: number
    externalData: number
    ageMin: number
    ageMax: number
    grade: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GroupAvgAggregateInputType = {
    ageMin?: true
    ageMax?: true
  }

  export type GroupSumAggregateInputType = {
    ageMin?: true
    ageMax?: true
  }

  export type GroupMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    organizationId?: true
    externalId?: true
    ageMin?: true
    ageMax?: true
    grade?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GroupMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    organizationId?: true
    externalId?: true
    ageMin?: true
    ageMax?: true
    grade?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GroupCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    organizationId?: true
    externalId?: true
    externalData?: true
    ageMin?: true
    ageMax?: true
    grade?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Group to aggregate.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Groups
    **/
    _count?: true | GroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupMaxAggregateInputType
  }

  export type GetGroupAggregateType<T extends GroupAggregateArgs> = {
        [P in keyof T & keyof AggregateGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroup[P]>
      : GetScalarType<T[P], AggregateGroup[P]>
  }




  export type GroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupWhereInput
    orderBy?: GroupOrderByWithAggregationInput | GroupOrderByWithAggregationInput[]
    by: GroupScalarFieldEnum[] | GroupScalarFieldEnum
    having?: GroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupCountAggregateInputType | true
    _avg?: GroupAvgAggregateInputType
    _sum?: GroupSumAggregateInputType
    _min?: GroupMinAggregateInputType
    _max?: GroupMaxAggregateInputType
  }

  export type GroupGroupByOutputType = {
    id: string
    name: string
    description: string | null
    organizationId: string
    externalId: string | null
    externalData: JsonValue | null
    ageMin: number | null
    ageMax: number | null
    grade: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: GroupCountAggregateOutputType | null
    _avg: GroupAvgAggregateOutputType | null
    _sum: GroupSumAggregateOutputType | null
    _min: GroupMinAggregateOutputType | null
    _max: GroupMaxAggregateOutputType | null
  }

  type GetGroupGroupByPayload<T extends GroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupGroupByOutputType[P]>
            : GetScalarType<T[P], GroupGroupByOutputType[P]>
        }
      >
    >


  export type GroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    organizationId?: boolean
    externalId?: boolean
    externalData?: boolean
    ageMin?: boolean
    ageMax?: boolean
    grade?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    members?: boolean | Group$membersArgs<ExtArgs>
    mappings?: boolean | Group$mappingsArgs<ExtArgs>
    lessons?: boolean | Group$lessonsArgs<ExtArgs>
    _count?: boolean | GroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["group"]>

  export type GroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    organizationId?: boolean
    externalId?: boolean
    externalData?: boolean
    ageMin?: boolean
    ageMax?: boolean
    grade?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["group"]>

  export type GroupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    organizationId?: boolean
    externalId?: boolean
    externalData?: boolean
    ageMin?: boolean
    ageMax?: boolean
    grade?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["group"]>

  export type GroupSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    organizationId?: boolean
    externalId?: boolean
    externalData?: boolean
    ageMin?: boolean
    ageMax?: boolean
    grade?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GroupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "organizationId" | "externalId" | "externalData" | "ageMin" | "ageMax" | "grade" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["group"]>
  export type GroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    members?: boolean | Group$membersArgs<ExtArgs>
    mappings?: boolean | Group$mappingsArgs<ExtArgs>
    lessons?: boolean | Group$lessonsArgs<ExtArgs>
    _count?: boolean | GroupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type GroupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $GroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Group"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      members: Prisma.$GroupMemberPayload<ExtArgs>[]
      mappings: Prisma.$ExternalGroupMappingPayload<ExtArgs>[]
      lessons: Prisma.$LessonGroupPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      organizationId: string
      externalId: string | null
      externalData: Prisma.JsonValue | null
      ageMin: number | null
      ageMax: number | null
      grade: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["group"]>
    composites: {}
  }

  type GroupGetPayload<S extends boolean | null | undefined | GroupDefaultArgs> = $Result.GetResult<Prisma.$GroupPayload, S>

  type GroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GroupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GroupCountAggregateInputType | true
    }

  export interface GroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Group'], meta: { name: 'Group' } }
    /**
     * Find zero or one Group that matches the filter.
     * @param {GroupFindUniqueArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GroupFindUniqueArgs>(args: SelectSubset<T, GroupFindUniqueArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Group that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GroupFindUniqueOrThrowArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GroupFindUniqueOrThrowArgs>(args: SelectSubset<T, GroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Group that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindFirstArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GroupFindFirstArgs>(args?: SelectSubset<T, GroupFindFirstArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Group that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindFirstOrThrowArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GroupFindFirstOrThrowArgs>(args?: SelectSubset<T, GroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Groups
     * const groups = await prisma.group.findMany()
     * 
     * // Get first 10 Groups
     * const groups = await prisma.group.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupWithIdOnly = await prisma.group.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GroupFindManyArgs>(args?: SelectSubset<T, GroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Group.
     * @param {GroupCreateArgs} args - Arguments to create a Group.
     * @example
     * // Create one Group
     * const Group = await prisma.group.create({
     *   data: {
     *     // ... data to create a Group
     *   }
     * })
     * 
     */
    create<T extends GroupCreateArgs>(args: SelectSubset<T, GroupCreateArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Groups.
     * @param {GroupCreateManyArgs} args - Arguments to create many Groups.
     * @example
     * // Create many Groups
     * const group = await prisma.group.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GroupCreateManyArgs>(args?: SelectSubset<T, GroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Groups and returns the data saved in the database.
     * @param {GroupCreateManyAndReturnArgs} args - Arguments to create many Groups.
     * @example
     * // Create many Groups
     * const group = await prisma.group.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Groups and only return the `id`
     * const groupWithIdOnly = await prisma.group.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GroupCreateManyAndReturnArgs>(args?: SelectSubset<T, GroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Group.
     * @param {GroupDeleteArgs} args - Arguments to delete one Group.
     * @example
     * // Delete one Group
     * const Group = await prisma.group.delete({
     *   where: {
     *     // ... filter to delete one Group
     *   }
     * })
     * 
     */
    delete<T extends GroupDeleteArgs>(args: SelectSubset<T, GroupDeleteArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Group.
     * @param {GroupUpdateArgs} args - Arguments to update one Group.
     * @example
     * // Update one Group
     * const group = await prisma.group.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GroupUpdateArgs>(args: SelectSubset<T, GroupUpdateArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Groups.
     * @param {GroupDeleteManyArgs} args - Arguments to filter Groups to delete.
     * @example
     * // Delete a few Groups
     * const { count } = await prisma.group.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GroupDeleteManyArgs>(args?: SelectSubset<T, GroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Groups
     * const group = await prisma.group.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GroupUpdateManyArgs>(args: SelectSubset<T, GroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Groups and returns the data updated in the database.
     * @param {GroupUpdateManyAndReturnArgs} args - Arguments to update many Groups.
     * @example
     * // Update many Groups
     * const group = await prisma.group.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Groups and only return the `id`
     * const groupWithIdOnly = await prisma.group.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GroupUpdateManyAndReturnArgs>(args: SelectSubset<T, GroupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Group.
     * @param {GroupUpsertArgs} args - Arguments to update or create a Group.
     * @example
     * // Update or create a Group
     * const group = await prisma.group.upsert({
     *   create: {
     *     // ... data to create a Group
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Group we want to update
     *   }
     * })
     */
    upsert<T extends GroupUpsertArgs>(args: SelectSubset<T, GroupUpsertArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupCountArgs} args - Arguments to filter Groups to count.
     * @example
     * // Count the number of Groups
     * const count = await prisma.group.count({
     *   where: {
     *     // ... the filter for the Groups we want to count
     *   }
     * })
    **/
    count<T extends GroupCountArgs>(
      args?: Subset<T, GroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupAggregateArgs>(args: Subset<T, GroupAggregateArgs>): Prisma.PrismaPromise<GetGroupAggregateType<T>>

    /**
     * Group by Group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupGroupByArgs['orderBy'] }
        : { orderBy?: GroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Group model
   */
  readonly fields: GroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Group.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    members<T extends Group$membersArgs<ExtArgs> = {}>(args?: Subset<T, Group$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    mappings<T extends Group$mappingsArgs<ExtArgs> = {}>(args?: Subset<T, Group$mappingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExternalGroupMappingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lessons<T extends Group$lessonsArgs<ExtArgs> = {}>(args?: Subset<T, Group$lessonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Group model
   */
  interface GroupFieldRefs {
    readonly id: FieldRef<"Group", 'String'>
    readonly name: FieldRef<"Group", 'String'>
    readonly description: FieldRef<"Group", 'String'>
    readonly organizationId: FieldRef<"Group", 'String'>
    readonly externalId: FieldRef<"Group", 'String'>
    readonly externalData: FieldRef<"Group", 'Json'>
    readonly ageMin: FieldRef<"Group", 'Int'>
    readonly ageMax: FieldRef<"Group", 'Int'>
    readonly grade: FieldRef<"Group", 'String'>
    readonly isActive: FieldRef<"Group", 'Boolean'>
    readonly createdAt: FieldRef<"Group", 'DateTime'>
    readonly updatedAt: FieldRef<"Group", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Group findUnique
   */
  export type GroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group findUniqueOrThrow
   */
  export type GroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group findFirst
   */
  export type GroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Groups.
     */
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Group findFirstOrThrow
   */
  export type GroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Groups.
     */
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Group findMany
   */
  export type GroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Groups to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Group create
   */
  export type GroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * The data needed to create a Group.
     */
    data: XOR<GroupCreateInput, GroupUncheckedCreateInput>
  }

  /**
   * Group createMany
   */
  export type GroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Groups.
     */
    data: GroupCreateManyInput | GroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Group createManyAndReturn
   */
  export type GroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * The data used to create many Groups.
     */
    data: GroupCreateManyInput | GroupCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Group update
   */
  export type GroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * The data needed to update a Group.
     */
    data: XOR<GroupUpdateInput, GroupUncheckedUpdateInput>
    /**
     * Choose, which Group to update.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group updateMany
   */
  export type GroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Groups.
     */
    data: XOR<GroupUpdateManyMutationInput, GroupUncheckedUpdateManyInput>
    /**
     * Filter which Groups to update
     */
    where?: GroupWhereInput
    /**
     * Limit how many Groups to update.
     */
    limit?: number
  }

  /**
   * Group updateManyAndReturn
   */
  export type GroupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * The data used to update Groups.
     */
    data: XOR<GroupUpdateManyMutationInput, GroupUncheckedUpdateManyInput>
    /**
     * Filter which Groups to update
     */
    where?: GroupWhereInput
    /**
     * Limit how many Groups to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Group upsert
   */
  export type GroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * The filter to search for the Group to update in case it exists.
     */
    where: GroupWhereUniqueInput
    /**
     * In case the Group found by the `where` argument doesn't exist, create a new Group with this data.
     */
    create: XOR<GroupCreateInput, GroupUncheckedCreateInput>
    /**
     * In case the Group was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroupUpdateInput, GroupUncheckedUpdateInput>
  }

  /**
   * Group delete
   */
  export type GroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter which Group to delete.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group deleteMany
   */
  export type GroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Groups to delete
     */
    where?: GroupWhereInput
    /**
     * Limit how many Groups to delete.
     */
    limit?: number
  }

  /**
   * Group.members
   */
  export type Group$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    where?: GroupMemberWhereInput
    orderBy?: GroupMemberOrderByWithRelationInput | GroupMemberOrderByWithRelationInput[]
    cursor?: GroupMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupMemberScalarFieldEnum | GroupMemberScalarFieldEnum[]
  }

  /**
   * Group.mappings
   */
  export type Group$mappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalGroupMapping
     */
    select?: ExternalGroupMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalGroupMapping
     */
    omit?: ExternalGroupMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalGroupMappingInclude<ExtArgs> | null
    where?: ExternalGroupMappingWhereInput
    orderBy?: ExternalGroupMappingOrderByWithRelationInput | ExternalGroupMappingOrderByWithRelationInput[]
    cursor?: ExternalGroupMappingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExternalGroupMappingScalarFieldEnum | ExternalGroupMappingScalarFieldEnum[]
  }

  /**
   * Group.lessons
   */
  export type Group$lessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonGroup
     */
    select?: LessonGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonGroup
     */
    omit?: LessonGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonGroupInclude<ExtArgs> | null
    where?: LessonGroupWhereInput
    orderBy?: LessonGroupOrderByWithRelationInput | LessonGroupOrderByWithRelationInput[]
    cursor?: LessonGroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonGroupScalarFieldEnum | LessonGroupScalarFieldEnum[]
  }

  /**
   * Group without action
   */
  export type GroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
  }


  /**
   * Model GroupMember
   */

  export type AggregateGroupMember = {
    _count: GroupMemberCountAggregateOutputType | null
    _min: GroupMemberMinAggregateOutputType | null
    _max: GroupMemberMaxAggregateOutputType | null
  }

  export type GroupMemberMinAggregateOutputType = {
    id: string | null
    userId: string | null
    groupId: string | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GroupMemberMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    groupId: string | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GroupMemberCountAggregateOutputType = {
    id: number
    userId: number
    groupId: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GroupMemberMinAggregateInputType = {
    id?: true
    userId?: true
    groupId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GroupMemberMaxAggregateInputType = {
    id?: true
    userId?: true
    groupId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GroupMemberCountAggregateInputType = {
    id?: true
    userId?: true
    groupId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GroupMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupMember to aggregate.
     */
    where?: GroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupMembers to fetch.
     */
    orderBy?: GroupMemberOrderByWithRelationInput | GroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GroupMembers
    **/
    _count?: true | GroupMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupMemberMaxAggregateInputType
  }

  export type GetGroupMemberAggregateType<T extends GroupMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateGroupMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroupMember[P]>
      : GetScalarType<T[P], AggregateGroupMember[P]>
  }




  export type GroupMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupMemberWhereInput
    orderBy?: GroupMemberOrderByWithAggregationInput | GroupMemberOrderByWithAggregationInput[]
    by: GroupMemberScalarFieldEnum[] | GroupMemberScalarFieldEnum
    having?: GroupMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupMemberCountAggregateInputType | true
    _min?: GroupMemberMinAggregateInputType
    _max?: GroupMemberMaxAggregateInputType
  }

  export type GroupMemberGroupByOutputType = {
    id: string
    userId: string
    groupId: string
    role: string
    createdAt: Date
    updatedAt: Date
    _count: GroupMemberCountAggregateOutputType | null
    _min: GroupMemberMinAggregateOutputType | null
    _max: GroupMemberMaxAggregateOutputType | null
  }

  type GetGroupMemberGroupByPayload<T extends GroupMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupMemberGroupByOutputType[P]>
            : GetScalarType<T[P], GroupMemberGroupByOutputType[P]>
        }
      >
    >


  export type GroupMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    groupId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupMember"]>

  export type GroupMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    groupId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupMember"]>

  export type GroupMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    groupId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupMember"]>

  export type GroupMemberSelectScalar = {
    id?: boolean
    userId?: boolean
    groupId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GroupMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "groupId" | "role" | "createdAt" | "updatedAt", ExtArgs["result"]["groupMember"]>
  export type GroupMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }
  export type GroupMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }
  export type GroupMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }

  export type $GroupMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GroupMember"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      group: Prisma.$GroupPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      groupId: string
      role: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["groupMember"]>
    composites: {}
  }

  type GroupMemberGetPayload<S extends boolean | null | undefined | GroupMemberDefaultArgs> = $Result.GetResult<Prisma.$GroupMemberPayload, S>

  type GroupMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GroupMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GroupMemberCountAggregateInputType | true
    }

  export interface GroupMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GroupMember'], meta: { name: 'GroupMember' } }
    /**
     * Find zero or one GroupMember that matches the filter.
     * @param {GroupMemberFindUniqueArgs} args - Arguments to find a GroupMember
     * @example
     * // Get one GroupMember
     * const groupMember = await prisma.groupMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GroupMemberFindUniqueArgs>(args: SelectSubset<T, GroupMemberFindUniqueArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GroupMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GroupMemberFindUniqueOrThrowArgs} args - Arguments to find a GroupMember
     * @example
     * // Get one GroupMember
     * const groupMember = await prisma.groupMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GroupMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, GroupMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GroupMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMemberFindFirstArgs} args - Arguments to find a GroupMember
     * @example
     * // Get one GroupMember
     * const groupMember = await prisma.groupMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GroupMemberFindFirstArgs>(args?: SelectSubset<T, GroupMemberFindFirstArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GroupMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMemberFindFirstOrThrowArgs} args - Arguments to find a GroupMember
     * @example
     * // Get one GroupMember
     * const groupMember = await prisma.groupMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GroupMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, GroupMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GroupMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GroupMembers
     * const groupMembers = await prisma.groupMember.findMany()
     * 
     * // Get first 10 GroupMembers
     * const groupMembers = await prisma.groupMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupMemberWithIdOnly = await prisma.groupMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GroupMemberFindManyArgs>(args?: SelectSubset<T, GroupMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GroupMember.
     * @param {GroupMemberCreateArgs} args - Arguments to create a GroupMember.
     * @example
     * // Create one GroupMember
     * const GroupMember = await prisma.groupMember.create({
     *   data: {
     *     // ... data to create a GroupMember
     *   }
     * })
     * 
     */
    create<T extends GroupMemberCreateArgs>(args: SelectSubset<T, GroupMemberCreateArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GroupMembers.
     * @param {GroupMemberCreateManyArgs} args - Arguments to create many GroupMembers.
     * @example
     * // Create many GroupMembers
     * const groupMember = await prisma.groupMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GroupMemberCreateManyArgs>(args?: SelectSubset<T, GroupMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GroupMembers and returns the data saved in the database.
     * @param {GroupMemberCreateManyAndReturnArgs} args - Arguments to create many GroupMembers.
     * @example
     * // Create many GroupMembers
     * const groupMember = await prisma.groupMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GroupMembers and only return the `id`
     * const groupMemberWithIdOnly = await prisma.groupMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GroupMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, GroupMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GroupMember.
     * @param {GroupMemberDeleteArgs} args - Arguments to delete one GroupMember.
     * @example
     * // Delete one GroupMember
     * const GroupMember = await prisma.groupMember.delete({
     *   where: {
     *     // ... filter to delete one GroupMember
     *   }
     * })
     * 
     */
    delete<T extends GroupMemberDeleteArgs>(args: SelectSubset<T, GroupMemberDeleteArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GroupMember.
     * @param {GroupMemberUpdateArgs} args - Arguments to update one GroupMember.
     * @example
     * // Update one GroupMember
     * const groupMember = await prisma.groupMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GroupMemberUpdateArgs>(args: SelectSubset<T, GroupMemberUpdateArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GroupMembers.
     * @param {GroupMemberDeleteManyArgs} args - Arguments to filter GroupMembers to delete.
     * @example
     * // Delete a few GroupMembers
     * const { count } = await prisma.groupMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GroupMemberDeleteManyArgs>(args?: SelectSubset<T, GroupMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroupMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GroupMembers
     * const groupMember = await prisma.groupMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GroupMemberUpdateManyArgs>(args: SelectSubset<T, GroupMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroupMembers and returns the data updated in the database.
     * @param {GroupMemberUpdateManyAndReturnArgs} args - Arguments to update many GroupMembers.
     * @example
     * // Update many GroupMembers
     * const groupMember = await prisma.groupMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GroupMembers and only return the `id`
     * const groupMemberWithIdOnly = await prisma.groupMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GroupMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, GroupMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GroupMember.
     * @param {GroupMemberUpsertArgs} args - Arguments to update or create a GroupMember.
     * @example
     * // Update or create a GroupMember
     * const groupMember = await prisma.groupMember.upsert({
     *   create: {
     *     // ... data to create a GroupMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GroupMember we want to update
     *   }
     * })
     */
    upsert<T extends GroupMemberUpsertArgs>(args: SelectSubset<T, GroupMemberUpsertArgs<ExtArgs>>): Prisma__GroupMemberClient<$Result.GetResult<Prisma.$GroupMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GroupMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMemberCountArgs} args - Arguments to filter GroupMembers to count.
     * @example
     * // Count the number of GroupMembers
     * const count = await prisma.groupMember.count({
     *   where: {
     *     // ... the filter for the GroupMembers we want to count
     *   }
     * })
    **/
    count<T extends GroupMemberCountArgs>(
      args?: Subset<T, GroupMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GroupMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupMemberAggregateArgs>(args: Subset<T, GroupMemberAggregateArgs>): Prisma.PrismaPromise<GetGroupMemberAggregateType<T>>

    /**
     * Group by GroupMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupMemberGroupByArgs['orderBy'] }
        : { orderBy?: GroupMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GroupMember model
   */
  readonly fields: GroupMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GroupMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GroupMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    group<T extends GroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GroupDefaultArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GroupMember model
   */
  interface GroupMemberFieldRefs {
    readonly id: FieldRef<"GroupMember", 'String'>
    readonly userId: FieldRef<"GroupMember", 'String'>
    readonly groupId: FieldRef<"GroupMember", 'String'>
    readonly role: FieldRef<"GroupMember", 'String'>
    readonly createdAt: FieldRef<"GroupMember", 'DateTime'>
    readonly updatedAt: FieldRef<"GroupMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GroupMember findUnique
   */
  export type GroupMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which GroupMember to fetch.
     */
    where: GroupMemberWhereUniqueInput
  }

  /**
   * GroupMember findUniqueOrThrow
   */
  export type GroupMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which GroupMember to fetch.
     */
    where: GroupMemberWhereUniqueInput
  }

  /**
   * GroupMember findFirst
   */
  export type GroupMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which GroupMember to fetch.
     */
    where?: GroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupMembers to fetch.
     */
    orderBy?: GroupMemberOrderByWithRelationInput | GroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupMembers.
     */
    cursor?: GroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupMembers.
     */
    distinct?: GroupMemberScalarFieldEnum | GroupMemberScalarFieldEnum[]
  }

  /**
   * GroupMember findFirstOrThrow
   */
  export type GroupMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which GroupMember to fetch.
     */
    where?: GroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupMembers to fetch.
     */
    orderBy?: GroupMemberOrderByWithRelationInput | GroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupMembers.
     */
    cursor?: GroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupMembers.
     */
    distinct?: GroupMemberScalarFieldEnum | GroupMemberScalarFieldEnum[]
  }

  /**
   * GroupMember findMany
   */
  export type GroupMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which GroupMembers to fetch.
     */
    where?: GroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupMembers to fetch.
     */
    orderBy?: GroupMemberOrderByWithRelationInput | GroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GroupMembers.
     */
    cursor?: GroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupMembers.
     */
    skip?: number
    distinct?: GroupMemberScalarFieldEnum | GroupMemberScalarFieldEnum[]
  }

  /**
   * GroupMember create
   */
  export type GroupMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a GroupMember.
     */
    data: XOR<GroupMemberCreateInput, GroupMemberUncheckedCreateInput>
  }

  /**
   * GroupMember createMany
   */
  export type GroupMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GroupMembers.
     */
    data: GroupMemberCreateManyInput | GroupMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GroupMember createManyAndReturn
   */
  export type GroupMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * The data used to create many GroupMembers.
     */
    data: GroupMemberCreateManyInput | GroupMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GroupMember update
   */
  export type GroupMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a GroupMember.
     */
    data: XOR<GroupMemberUpdateInput, GroupMemberUncheckedUpdateInput>
    /**
     * Choose, which GroupMember to update.
     */
    where: GroupMemberWhereUniqueInput
  }

  /**
   * GroupMember updateMany
   */
  export type GroupMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GroupMembers.
     */
    data: XOR<GroupMemberUpdateManyMutationInput, GroupMemberUncheckedUpdateManyInput>
    /**
     * Filter which GroupMembers to update
     */
    where?: GroupMemberWhereInput
    /**
     * Limit how many GroupMembers to update.
     */
    limit?: number
  }

  /**
   * GroupMember updateManyAndReturn
   */
  export type GroupMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * The data used to update GroupMembers.
     */
    data: XOR<GroupMemberUpdateManyMutationInput, GroupMemberUncheckedUpdateManyInput>
    /**
     * Filter which GroupMembers to update
     */
    where?: GroupMemberWhereInput
    /**
     * Limit how many GroupMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GroupMember upsert
   */
  export type GroupMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the GroupMember to update in case it exists.
     */
    where: GroupMemberWhereUniqueInput
    /**
     * In case the GroupMember found by the `where` argument doesn't exist, create a new GroupMember with this data.
     */
    create: XOR<GroupMemberCreateInput, GroupMemberUncheckedCreateInput>
    /**
     * In case the GroupMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroupMemberUpdateInput, GroupMemberUncheckedUpdateInput>
  }

  /**
   * GroupMember delete
   */
  export type GroupMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
    /**
     * Filter which GroupMember to delete.
     */
    where: GroupMemberWhereUniqueInput
  }

  /**
   * GroupMember deleteMany
   */
  export type GroupMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupMembers to delete
     */
    where?: GroupMemberWhereInput
    /**
     * Limit how many GroupMembers to delete.
     */
    limit?: number
  }

  /**
   * GroupMember without action
   */
  export type GroupMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMember
     */
    select?: GroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMember
     */
    omit?: GroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMemberInclude<ExtArgs> | null
  }


  /**
   * Model ExternalIntegration
   */

  export type AggregateExternalIntegration = {
    _count: ExternalIntegrationCountAggregateOutputType | null
    _min: ExternalIntegrationMinAggregateOutputType | null
    _max: ExternalIntegrationMaxAggregateOutputType | null
  }

  export type ExternalIntegrationMinAggregateOutputType = {
    id: string | null
    organizationId: string | null
    provider: $Enums.IntegrationProvider | null
    status: $Enums.IntegrationStatus | null
    credentialsEncrypted: string | null
    credentialsIV: string | null
    credentialsTag: string | null
    accessToken: string | null
    refreshToken: string | null
    tokenExpiresAt: Date | null
    apiBaseUrl: string | null
    apiVersion: string | null
    syncEnabled: boolean | null
    syncFrequency: $Enums.SyncFrequency | null
    lastSyncAt: Date | null
    lastSyncStatus: $Enums.SyncStatus | null
    nextSyncAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExternalIntegrationMaxAggregateOutputType = {
    id: string | null
    organizationId: string | null
    provider: $Enums.IntegrationProvider | null
    status: $Enums.IntegrationStatus | null
    credentialsEncrypted: string | null
    credentialsIV: string | null
    credentialsTag: string | null
    accessToken: string | null
    refreshToken: string | null
    tokenExpiresAt: Date | null
    apiBaseUrl: string | null
    apiVersion: string | null
    syncEnabled: boolean | null
    syncFrequency: $Enums.SyncFrequency | null
    lastSyncAt: Date | null
    lastSyncStatus: $Enums.SyncStatus | null
    nextSyncAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExternalIntegrationCountAggregateOutputType = {
    id: number
    organizationId: number
    provider: number
    status: number
    credentialsEncrypted: number
    credentialsIV: number
    credentialsTag: number
    accessToken: number
    refreshToken: number
    tokenExpiresAt: number
    apiBaseUrl: number
    apiVersion: number
    syncEnabled: number
    syncFrequency: number
    lastSyncAt: number
    lastSyncStatus: number
    nextSyncAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExternalIntegrationMinAggregateInputType = {
    id?: true
    organizationId?: true
    provider?: true
    status?: true
    credentialsEncrypted?: true
    credentialsIV?: true
    credentialsTag?: true
    accessToken?: true
    refreshToken?: true
    tokenExpiresAt?: true
    apiBaseUrl?: true
    apiVersion?: true
    syncEnabled?: true
    syncFrequency?: true
    lastSyncAt?: true
    lastSyncStatus?: true
    nextSyncAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExternalIntegrationMaxAggregateInputType = {
    id?: true
    organizationId?: true
    provider?: true
    status?: true
    credentialsEncrypted?: true
    credentialsIV?: true
    credentialsTag?: true
    accessToken?: true
    refreshToken?: true
    tokenExpiresAt?: true
    apiBaseUrl?: true
    apiVersion?: true
    syncEnabled?: true
    syncFrequency?: true
    lastSyncAt?: true
    lastSyncStatus?: true
    nextSyncAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExternalIntegrationCountAggregateInputType = {
    id?: true
    organizationId?: true
    provider?: true
    status?: true
    credentialsEncrypted?: true
    credentialsIV?: true
    credentialsTag?: true
    accessToken?: true
    refreshToken?: true
    tokenExpiresAt?: true
    apiBaseUrl?: true
    apiVersion?: true
    syncEnabled?: true
    syncFrequency?: true
    lastSyncAt?: true
    lastSyncStatus?: true
    nextSyncAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExternalIntegrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExternalIntegration to aggregate.
     */
    where?: ExternalIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalIntegrations to fetch.
     */
    orderBy?: ExternalIntegrationOrderByWithRelationInput | ExternalIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExternalIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExternalIntegrations
    **/
    _count?: true | ExternalIntegrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExternalIntegrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExternalIntegrationMaxAggregateInputType
  }

  export type GetExternalIntegrationAggregateType<T extends ExternalIntegrationAggregateArgs> = {
        [P in keyof T & keyof AggregateExternalIntegration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExternalIntegration[P]>
      : GetScalarType<T[P], AggregateExternalIntegration[P]>
  }




  export type ExternalIntegrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExternalIntegrationWhereInput
    orderBy?: ExternalIntegrationOrderByWithAggregationInput | ExternalIntegrationOrderByWithAggregationInput[]
    by: ExternalIntegrationScalarFieldEnum[] | ExternalIntegrationScalarFieldEnum
    having?: ExternalIntegrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExternalIntegrationCountAggregateInputType | true
    _min?: ExternalIntegrationMinAggregateInputType
    _max?: ExternalIntegrationMaxAggregateInputType
  }

  export type ExternalIntegrationGroupByOutputType = {
    id: string
    organizationId: string
    provider: $Enums.IntegrationProvider
    status: $Enums.IntegrationStatus
    credentialsEncrypted: string
    credentialsIV: string
    credentialsTag: string
    accessToken: string | null
    refreshToken: string | null
    tokenExpiresAt: Date | null
    apiBaseUrl: string | null
    apiVersion: string | null
    syncEnabled: boolean
    syncFrequency: $Enums.SyncFrequency
    lastSyncAt: Date | null
    lastSyncStatus: $Enums.SyncStatus | null
    nextSyncAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ExternalIntegrationCountAggregateOutputType | null
    _min: ExternalIntegrationMinAggregateOutputType | null
    _max: ExternalIntegrationMaxAggregateOutputType | null
  }

  type GetExternalIntegrationGroupByPayload<T extends ExternalIntegrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExternalIntegrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExternalIntegrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExternalIntegrationGroupByOutputType[P]>
            : GetScalarType<T[P], ExternalIntegrationGroupByOutputType[P]>
        }
      >
    >


  export type ExternalIntegrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    provider?: boolean
    status?: boolean
    credentialsEncrypted?: boolean
    credentialsIV?: boolean
    credentialsTag?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    tokenExpiresAt?: boolean
    apiBaseUrl?: boolean
    apiVersion?: boolean
    syncEnabled?: boolean
    syncFrequency?: boolean
    lastSyncAt?: boolean
    lastSyncStatus?: boolean
    nextSyncAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    groupMappings?: boolean | ExternalIntegration$groupMappingsArgs<ExtArgs>
    syncLogs?: boolean | ExternalIntegration$syncLogsArgs<ExtArgs>
    _count?: boolean | ExternalIntegrationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["externalIntegration"]>

  export type ExternalIntegrationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    provider?: boolean
    status?: boolean
    credentialsEncrypted?: boolean
    credentialsIV?: boolean
    credentialsTag?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    tokenExpiresAt?: boolean
    apiBaseUrl?: boolean
    apiVersion?: boolean
    syncEnabled?: boolean
    syncFrequency?: boolean
    lastSyncAt?: boolean
    lastSyncStatus?: boolean
    nextSyncAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["externalIntegration"]>

  export type ExternalIntegrationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    provider?: boolean
    status?: boolean
    credentialsEncrypted?: boolean
    credentialsIV?: boolean
    credentialsTag?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    tokenExpiresAt?: boolean
    apiBaseUrl?: boolean
    apiVersion?: boolean
    syncEnabled?: boolean
    syncFrequency?: boolean
    lastSyncAt?: boolean
    lastSyncStatus?: boolean
    nextSyncAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["externalIntegration"]>

  export type ExternalIntegrationSelectScalar = {
    id?: boolean
    organizationId?: boolean
    provider?: boolean
    status?: boolean
    credentialsEncrypted?: boolean
    credentialsIV?: boolean
    credentialsTag?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    tokenExpiresAt?: boolean
    apiBaseUrl?: boolean
    apiVersion?: boolean
    syncEnabled?: boolean
    syncFrequency?: boolean
    lastSyncAt?: boolean
    lastSyncStatus?: boolean
    nextSyncAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExternalIntegrationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organizationId" | "provider" | "status" | "credentialsEncrypted" | "credentialsIV" | "credentialsTag" | "accessToken" | "refreshToken" | "tokenExpiresAt" | "apiBaseUrl" | "apiVersion" | "syncEnabled" | "syncFrequency" | "lastSyncAt" | "lastSyncStatus" | "nextSyncAt" | "createdAt" | "updatedAt", ExtArgs["result"]["externalIntegration"]>
  export type ExternalIntegrationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    groupMappings?: boolean | ExternalIntegration$groupMappingsArgs<ExtArgs>
    syncLogs?: boolean | ExternalIntegration$syncLogsArgs<ExtArgs>
    _count?: boolean | ExternalIntegrationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ExternalIntegrationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type ExternalIntegrationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $ExternalIntegrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExternalIntegration"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      groupMappings: Prisma.$ExternalGroupMappingPayload<ExtArgs>[]
      syncLogs: Prisma.$SyncLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organizationId: string
      provider: $Enums.IntegrationProvider
      status: $Enums.IntegrationStatus
      credentialsEncrypted: string
      credentialsIV: string
      credentialsTag: string
      accessToken: string | null
      refreshToken: string | null
      tokenExpiresAt: Date | null
      apiBaseUrl: string | null
      apiVersion: string | null
      syncEnabled: boolean
      syncFrequency: $Enums.SyncFrequency
      lastSyncAt: Date | null
      lastSyncStatus: $Enums.SyncStatus | null
      nextSyncAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["externalIntegration"]>
    composites: {}
  }

  type ExternalIntegrationGetPayload<S extends boolean | null | undefined | ExternalIntegrationDefaultArgs> = $Result.GetResult<Prisma.$ExternalIntegrationPayload, S>

  type ExternalIntegrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExternalIntegrationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExternalIntegrationCountAggregateInputType | true
    }

  export interface ExternalIntegrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExternalIntegration'], meta: { name: 'ExternalIntegration' } }
    /**
     * Find zero or one ExternalIntegration that matches the filter.
     * @param {ExternalIntegrationFindUniqueArgs} args - Arguments to find a ExternalIntegration
     * @example
     * // Get one ExternalIntegration
     * const externalIntegration = await prisma.externalIntegration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExternalIntegrationFindUniqueArgs>(args: SelectSubset<T, ExternalIntegrationFindUniqueArgs<ExtArgs>>): Prisma__ExternalIntegrationClient<$Result.GetResult<Prisma.$ExternalIntegrationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExternalIntegration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExternalIntegrationFindUniqueOrThrowArgs} args - Arguments to find a ExternalIntegration
     * @example
     * // Get one ExternalIntegration
     * const externalIntegration = await prisma.externalIntegration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExternalIntegrationFindUniqueOrThrowArgs>(args: SelectSubset<T, ExternalIntegrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExternalIntegrationClient<$Result.GetResult<Prisma.$ExternalIntegrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExternalIntegration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalIntegrationFindFirstArgs} args - Arguments to find a ExternalIntegration
     * @example
     * // Get one ExternalIntegration
     * const externalIntegration = await prisma.externalIntegration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExternalIntegrationFindFirstArgs>(args?: SelectSubset<T, ExternalIntegrationFindFirstArgs<ExtArgs>>): Prisma__ExternalIntegrationClient<$Result.GetResult<Prisma.$ExternalIntegrationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExternalIntegration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalIntegrationFindFirstOrThrowArgs} args - Arguments to find a ExternalIntegration
     * @example
     * // Get one ExternalIntegration
     * const externalIntegration = await prisma.externalIntegration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExternalIntegrationFindFirstOrThrowArgs>(args?: SelectSubset<T, ExternalIntegrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExternalIntegrationClient<$Result.GetResult<Prisma.$ExternalIntegrationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExternalIntegrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalIntegrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExternalIntegrations
     * const externalIntegrations = await prisma.externalIntegration.findMany()
     * 
     * // Get first 10 ExternalIntegrations
     * const externalIntegrations = await prisma.externalIntegration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const externalIntegrationWithIdOnly = await prisma.externalIntegration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExternalIntegrationFindManyArgs>(args?: SelectSubset<T, ExternalIntegrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExternalIntegrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExternalIntegration.
     * @param {ExternalIntegrationCreateArgs} args - Arguments to create a ExternalIntegration.
     * @example
     * // Create one ExternalIntegration
     * const ExternalIntegration = await prisma.externalIntegration.create({
     *   data: {
     *     // ... data to create a ExternalIntegration
     *   }
     * })
     * 
     */
    create<T extends ExternalIntegrationCreateArgs>(args: SelectSubset<T, ExternalIntegrationCreateArgs<ExtArgs>>): Prisma__ExternalIntegrationClient<$Result.GetResult<Prisma.$ExternalIntegrationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExternalIntegrations.
     * @param {ExternalIntegrationCreateManyArgs} args - Arguments to create many ExternalIntegrations.
     * @example
     * // Create many ExternalIntegrations
     * const externalIntegration = await prisma.externalIntegration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExternalIntegrationCreateManyArgs>(args?: SelectSubset<T, ExternalIntegrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExternalIntegrations and returns the data saved in the database.
     * @param {ExternalIntegrationCreateManyAndReturnArgs} args - Arguments to create many ExternalIntegrations.
     * @example
     * // Create many ExternalIntegrations
     * const externalIntegration = await prisma.externalIntegration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExternalIntegrations and only return the `id`
     * const externalIntegrationWithIdOnly = await prisma.externalIntegration.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExternalIntegrationCreateManyAndReturnArgs>(args?: SelectSubset<T, ExternalIntegrationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExternalIntegrationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ExternalIntegration.
     * @param {ExternalIntegrationDeleteArgs} args - Arguments to delete one ExternalIntegration.
     * @example
     * // Delete one ExternalIntegration
     * const ExternalIntegration = await prisma.externalIntegration.delete({
     *   where: {
     *     // ... filter to delete one ExternalIntegration
     *   }
     * })
     * 
     */
    delete<T extends ExternalIntegrationDeleteArgs>(args: SelectSubset<T, ExternalIntegrationDeleteArgs<ExtArgs>>): Prisma__ExternalIntegrationClient<$Result.GetResult<Prisma.$ExternalIntegrationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExternalIntegration.
     * @param {ExternalIntegrationUpdateArgs} args - Arguments to update one ExternalIntegration.
     * @example
     * // Update one ExternalIntegration
     * const externalIntegration = await prisma.externalIntegration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExternalIntegrationUpdateArgs>(args: SelectSubset<T, ExternalIntegrationUpdateArgs<ExtArgs>>): Prisma__ExternalIntegrationClient<$Result.GetResult<Prisma.$ExternalIntegrationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExternalIntegrations.
     * @param {ExternalIntegrationDeleteManyArgs} args - Arguments to filter ExternalIntegrations to delete.
     * @example
     * // Delete a few ExternalIntegrations
     * const { count } = await prisma.externalIntegration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExternalIntegrationDeleteManyArgs>(args?: SelectSubset<T, ExternalIntegrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExternalIntegrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalIntegrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExternalIntegrations
     * const externalIntegration = await prisma.externalIntegration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExternalIntegrationUpdateManyArgs>(args: SelectSubset<T, ExternalIntegrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExternalIntegrations and returns the data updated in the database.
     * @param {ExternalIntegrationUpdateManyAndReturnArgs} args - Arguments to update many ExternalIntegrations.
     * @example
     * // Update many ExternalIntegrations
     * const externalIntegration = await prisma.externalIntegration.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExternalIntegrations and only return the `id`
     * const externalIntegrationWithIdOnly = await prisma.externalIntegration.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExternalIntegrationUpdateManyAndReturnArgs>(args: SelectSubset<T, ExternalIntegrationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExternalIntegrationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ExternalIntegration.
     * @param {ExternalIntegrationUpsertArgs} args - Arguments to update or create a ExternalIntegration.
     * @example
     * // Update or create a ExternalIntegration
     * const externalIntegration = await prisma.externalIntegration.upsert({
     *   create: {
     *     // ... data to create a ExternalIntegration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExternalIntegration we want to update
     *   }
     * })
     */
    upsert<T extends ExternalIntegrationUpsertArgs>(args: SelectSubset<T, ExternalIntegrationUpsertArgs<ExtArgs>>): Prisma__ExternalIntegrationClient<$Result.GetResult<Prisma.$ExternalIntegrationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExternalIntegrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalIntegrationCountArgs} args - Arguments to filter ExternalIntegrations to count.
     * @example
     * // Count the number of ExternalIntegrations
     * const count = await prisma.externalIntegration.count({
     *   where: {
     *     // ... the filter for the ExternalIntegrations we want to count
     *   }
     * })
    **/
    count<T extends ExternalIntegrationCountArgs>(
      args?: Subset<T, ExternalIntegrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExternalIntegrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExternalIntegration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalIntegrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExternalIntegrationAggregateArgs>(args: Subset<T, ExternalIntegrationAggregateArgs>): Prisma.PrismaPromise<GetExternalIntegrationAggregateType<T>>

    /**
     * Group by ExternalIntegration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalIntegrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExternalIntegrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExternalIntegrationGroupByArgs['orderBy'] }
        : { orderBy?: ExternalIntegrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExternalIntegrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExternalIntegrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExternalIntegration model
   */
  readonly fields: ExternalIntegrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExternalIntegration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExternalIntegrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    groupMappings<T extends ExternalIntegration$groupMappingsArgs<ExtArgs> = {}>(args?: Subset<T, ExternalIntegration$groupMappingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExternalGroupMappingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    syncLogs<T extends ExternalIntegration$syncLogsArgs<ExtArgs> = {}>(args?: Subset<T, ExternalIntegration$syncLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExternalIntegration model
   */
  interface ExternalIntegrationFieldRefs {
    readonly id: FieldRef<"ExternalIntegration", 'String'>
    readonly organizationId: FieldRef<"ExternalIntegration", 'String'>
    readonly provider: FieldRef<"ExternalIntegration", 'IntegrationProvider'>
    readonly status: FieldRef<"ExternalIntegration", 'IntegrationStatus'>
    readonly credentialsEncrypted: FieldRef<"ExternalIntegration", 'String'>
    readonly credentialsIV: FieldRef<"ExternalIntegration", 'String'>
    readonly credentialsTag: FieldRef<"ExternalIntegration", 'String'>
    readonly accessToken: FieldRef<"ExternalIntegration", 'String'>
    readonly refreshToken: FieldRef<"ExternalIntegration", 'String'>
    readonly tokenExpiresAt: FieldRef<"ExternalIntegration", 'DateTime'>
    readonly apiBaseUrl: FieldRef<"ExternalIntegration", 'String'>
    readonly apiVersion: FieldRef<"ExternalIntegration", 'String'>
    readonly syncEnabled: FieldRef<"ExternalIntegration", 'Boolean'>
    readonly syncFrequency: FieldRef<"ExternalIntegration", 'SyncFrequency'>
    readonly lastSyncAt: FieldRef<"ExternalIntegration", 'DateTime'>
    readonly lastSyncStatus: FieldRef<"ExternalIntegration", 'SyncStatus'>
    readonly nextSyncAt: FieldRef<"ExternalIntegration", 'DateTime'>
    readonly createdAt: FieldRef<"ExternalIntegration", 'DateTime'>
    readonly updatedAt: FieldRef<"ExternalIntegration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExternalIntegration findUnique
   */
  export type ExternalIntegrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalIntegration
     */
    select?: ExternalIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalIntegration
     */
    omit?: ExternalIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which ExternalIntegration to fetch.
     */
    where: ExternalIntegrationWhereUniqueInput
  }

  /**
   * ExternalIntegration findUniqueOrThrow
   */
  export type ExternalIntegrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalIntegration
     */
    select?: ExternalIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalIntegration
     */
    omit?: ExternalIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which ExternalIntegration to fetch.
     */
    where: ExternalIntegrationWhereUniqueInput
  }

  /**
   * ExternalIntegration findFirst
   */
  export type ExternalIntegrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalIntegration
     */
    select?: ExternalIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalIntegration
     */
    omit?: ExternalIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which ExternalIntegration to fetch.
     */
    where?: ExternalIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalIntegrations to fetch.
     */
    orderBy?: ExternalIntegrationOrderByWithRelationInput | ExternalIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExternalIntegrations.
     */
    cursor?: ExternalIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExternalIntegrations.
     */
    distinct?: ExternalIntegrationScalarFieldEnum | ExternalIntegrationScalarFieldEnum[]
  }

  /**
   * ExternalIntegration findFirstOrThrow
   */
  export type ExternalIntegrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalIntegration
     */
    select?: ExternalIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalIntegration
     */
    omit?: ExternalIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which ExternalIntegration to fetch.
     */
    where?: ExternalIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalIntegrations to fetch.
     */
    orderBy?: ExternalIntegrationOrderByWithRelationInput | ExternalIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExternalIntegrations.
     */
    cursor?: ExternalIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExternalIntegrations.
     */
    distinct?: ExternalIntegrationScalarFieldEnum | ExternalIntegrationScalarFieldEnum[]
  }

  /**
   * ExternalIntegration findMany
   */
  export type ExternalIntegrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalIntegration
     */
    select?: ExternalIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalIntegration
     */
    omit?: ExternalIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which ExternalIntegrations to fetch.
     */
    where?: ExternalIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalIntegrations to fetch.
     */
    orderBy?: ExternalIntegrationOrderByWithRelationInput | ExternalIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExternalIntegrations.
     */
    cursor?: ExternalIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalIntegrations.
     */
    skip?: number
    distinct?: ExternalIntegrationScalarFieldEnum | ExternalIntegrationScalarFieldEnum[]
  }

  /**
   * ExternalIntegration create
   */
  export type ExternalIntegrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalIntegration
     */
    select?: ExternalIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalIntegration
     */
    omit?: ExternalIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalIntegrationInclude<ExtArgs> | null
    /**
     * The data needed to create a ExternalIntegration.
     */
    data: XOR<ExternalIntegrationCreateInput, ExternalIntegrationUncheckedCreateInput>
  }

  /**
   * ExternalIntegration createMany
   */
  export type ExternalIntegrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExternalIntegrations.
     */
    data: ExternalIntegrationCreateManyInput | ExternalIntegrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExternalIntegration createManyAndReturn
   */
  export type ExternalIntegrationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalIntegration
     */
    select?: ExternalIntegrationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalIntegration
     */
    omit?: ExternalIntegrationOmit<ExtArgs> | null
    /**
     * The data used to create many ExternalIntegrations.
     */
    data: ExternalIntegrationCreateManyInput | ExternalIntegrationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalIntegrationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExternalIntegration update
   */
  export type ExternalIntegrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalIntegration
     */
    select?: ExternalIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalIntegration
     */
    omit?: ExternalIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalIntegrationInclude<ExtArgs> | null
    /**
     * The data needed to update a ExternalIntegration.
     */
    data: XOR<ExternalIntegrationUpdateInput, ExternalIntegrationUncheckedUpdateInput>
    /**
     * Choose, which ExternalIntegration to update.
     */
    where: ExternalIntegrationWhereUniqueInput
  }

  /**
   * ExternalIntegration updateMany
   */
  export type ExternalIntegrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExternalIntegrations.
     */
    data: XOR<ExternalIntegrationUpdateManyMutationInput, ExternalIntegrationUncheckedUpdateManyInput>
    /**
     * Filter which ExternalIntegrations to update
     */
    where?: ExternalIntegrationWhereInput
    /**
     * Limit how many ExternalIntegrations to update.
     */
    limit?: number
  }

  /**
   * ExternalIntegration updateManyAndReturn
   */
  export type ExternalIntegrationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalIntegration
     */
    select?: ExternalIntegrationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalIntegration
     */
    omit?: ExternalIntegrationOmit<ExtArgs> | null
    /**
     * The data used to update ExternalIntegrations.
     */
    data: XOR<ExternalIntegrationUpdateManyMutationInput, ExternalIntegrationUncheckedUpdateManyInput>
    /**
     * Filter which ExternalIntegrations to update
     */
    where?: ExternalIntegrationWhereInput
    /**
     * Limit how many ExternalIntegrations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalIntegrationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExternalIntegration upsert
   */
  export type ExternalIntegrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalIntegration
     */
    select?: ExternalIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalIntegration
     */
    omit?: ExternalIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalIntegrationInclude<ExtArgs> | null
    /**
     * The filter to search for the ExternalIntegration to update in case it exists.
     */
    where: ExternalIntegrationWhereUniqueInput
    /**
     * In case the ExternalIntegration found by the `where` argument doesn't exist, create a new ExternalIntegration with this data.
     */
    create: XOR<ExternalIntegrationCreateInput, ExternalIntegrationUncheckedCreateInput>
    /**
     * In case the ExternalIntegration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExternalIntegrationUpdateInput, ExternalIntegrationUncheckedUpdateInput>
  }

  /**
   * ExternalIntegration delete
   */
  export type ExternalIntegrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalIntegration
     */
    select?: ExternalIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalIntegration
     */
    omit?: ExternalIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalIntegrationInclude<ExtArgs> | null
    /**
     * Filter which ExternalIntegration to delete.
     */
    where: ExternalIntegrationWhereUniqueInput
  }

  /**
   * ExternalIntegration deleteMany
   */
  export type ExternalIntegrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExternalIntegrations to delete
     */
    where?: ExternalIntegrationWhereInput
    /**
     * Limit how many ExternalIntegrations to delete.
     */
    limit?: number
  }

  /**
   * ExternalIntegration.groupMappings
   */
  export type ExternalIntegration$groupMappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalGroupMapping
     */
    select?: ExternalGroupMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalGroupMapping
     */
    omit?: ExternalGroupMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalGroupMappingInclude<ExtArgs> | null
    where?: ExternalGroupMappingWhereInput
    orderBy?: ExternalGroupMappingOrderByWithRelationInput | ExternalGroupMappingOrderByWithRelationInput[]
    cursor?: ExternalGroupMappingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExternalGroupMappingScalarFieldEnum | ExternalGroupMappingScalarFieldEnum[]
  }

  /**
   * ExternalIntegration.syncLogs
   */
  export type ExternalIntegration$syncLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncLog
     */
    omit?: SyncLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncLogInclude<ExtArgs> | null
    where?: SyncLogWhereInput
    orderBy?: SyncLogOrderByWithRelationInput | SyncLogOrderByWithRelationInput[]
    cursor?: SyncLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SyncLogScalarFieldEnum | SyncLogScalarFieldEnum[]
  }

  /**
   * ExternalIntegration without action
   */
  export type ExternalIntegrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalIntegration
     */
    select?: ExternalIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalIntegration
     */
    omit?: ExternalIntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalIntegrationInclude<ExtArgs> | null
  }


  /**
   * Model ExternalGroupMapping
   */

  export type AggregateExternalGroupMapping = {
    _count: ExternalGroupMappingCountAggregateOutputType | null
    _min: ExternalGroupMappingMinAggregateOutputType | null
    _max: ExternalGroupMappingMaxAggregateOutputType | null
  }

  export type ExternalGroupMappingMinAggregateOutputType = {
    id: string | null
    integrationId: string | null
    externalGroupId: string | null
    externalGroupName: string | null
    externalGroupType: string | null
    groupId: string | null
    syncMembers: boolean | null
    syncLeaders: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExternalGroupMappingMaxAggregateOutputType = {
    id: string | null
    integrationId: string | null
    externalGroupId: string | null
    externalGroupName: string | null
    externalGroupType: string | null
    groupId: string | null
    syncMembers: boolean | null
    syncLeaders: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExternalGroupMappingCountAggregateOutputType = {
    id: number
    integrationId: number
    externalGroupId: number
    externalGroupName: number
    externalGroupType: number
    groupId: number
    syncMembers: number
    syncLeaders: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExternalGroupMappingMinAggregateInputType = {
    id?: true
    integrationId?: true
    externalGroupId?: true
    externalGroupName?: true
    externalGroupType?: true
    groupId?: true
    syncMembers?: true
    syncLeaders?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExternalGroupMappingMaxAggregateInputType = {
    id?: true
    integrationId?: true
    externalGroupId?: true
    externalGroupName?: true
    externalGroupType?: true
    groupId?: true
    syncMembers?: true
    syncLeaders?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExternalGroupMappingCountAggregateInputType = {
    id?: true
    integrationId?: true
    externalGroupId?: true
    externalGroupName?: true
    externalGroupType?: true
    groupId?: true
    syncMembers?: true
    syncLeaders?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExternalGroupMappingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExternalGroupMapping to aggregate.
     */
    where?: ExternalGroupMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalGroupMappings to fetch.
     */
    orderBy?: ExternalGroupMappingOrderByWithRelationInput | ExternalGroupMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExternalGroupMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalGroupMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalGroupMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExternalGroupMappings
    **/
    _count?: true | ExternalGroupMappingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExternalGroupMappingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExternalGroupMappingMaxAggregateInputType
  }

  export type GetExternalGroupMappingAggregateType<T extends ExternalGroupMappingAggregateArgs> = {
        [P in keyof T & keyof AggregateExternalGroupMapping]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExternalGroupMapping[P]>
      : GetScalarType<T[P], AggregateExternalGroupMapping[P]>
  }




  export type ExternalGroupMappingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExternalGroupMappingWhereInput
    orderBy?: ExternalGroupMappingOrderByWithAggregationInput | ExternalGroupMappingOrderByWithAggregationInput[]
    by: ExternalGroupMappingScalarFieldEnum[] | ExternalGroupMappingScalarFieldEnum
    having?: ExternalGroupMappingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExternalGroupMappingCountAggregateInputType | true
    _min?: ExternalGroupMappingMinAggregateInputType
    _max?: ExternalGroupMappingMaxAggregateInputType
  }

  export type ExternalGroupMappingGroupByOutputType = {
    id: string
    integrationId: string
    externalGroupId: string
    externalGroupName: string
    externalGroupType: string | null
    groupId: string | null
    syncMembers: boolean
    syncLeaders: boolean
    createdAt: Date
    updatedAt: Date
    _count: ExternalGroupMappingCountAggregateOutputType | null
    _min: ExternalGroupMappingMinAggregateOutputType | null
    _max: ExternalGroupMappingMaxAggregateOutputType | null
  }

  type GetExternalGroupMappingGroupByPayload<T extends ExternalGroupMappingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExternalGroupMappingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExternalGroupMappingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExternalGroupMappingGroupByOutputType[P]>
            : GetScalarType<T[P], ExternalGroupMappingGroupByOutputType[P]>
        }
      >
    >


  export type ExternalGroupMappingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    integrationId?: boolean
    externalGroupId?: boolean
    externalGroupName?: boolean
    externalGroupType?: boolean
    groupId?: boolean
    syncMembers?: boolean
    syncLeaders?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    integration?: boolean | ExternalIntegrationDefaultArgs<ExtArgs>
    group?: boolean | ExternalGroupMapping$groupArgs<ExtArgs>
  }, ExtArgs["result"]["externalGroupMapping"]>

  export type ExternalGroupMappingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    integrationId?: boolean
    externalGroupId?: boolean
    externalGroupName?: boolean
    externalGroupType?: boolean
    groupId?: boolean
    syncMembers?: boolean
    syncLeaders?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    integration?: boolean | ExternalIntegrationDefaultArgs<ExtArgs>
    group?: boolean | ExternalGroupMapping$groupArgs<ExtArgs>
  }, ExtArgs["result"]["externalGroupMapping"]>

  export type ExternalGroupMappingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    integrationId?: boolean
    externalGroupId?: boolean
    externalGroupName?: boolean
    externalGroupType?: boolean
    groupId?: boolean
    syncMembers?: boolean
    syncLeaders?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    integration?: boolean | ExternalIntegrationDefaultArgs<ExtArgs>
    group?: boolean | ExternalGroupMapping$groupArgs<ExtArgs>
  }, ExtArgs["result"]["externalGroupMapping"]>

  export type ExternalGroupMappingSelectScalar = {
    id?: boolean
    integrationId?: boolean
    externalGroupId?: boolean
    externalGroupName?: boolean
    externalGroupType?: boolean
    groupId?: boolean
    syncMembers?: boolean
    syncLeaders?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExternalGroupMappingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "integrationId" | "externalGroupId" | "externalGroupName" | "externalGroupType" | "groupId" | "syncMembers" | "syncLeaders" | "createdAt" | "updatedAt", ExtArgs["result"]["externalGroupMapping"]>
  export type ExternalGroupMappingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    integration?: boolean | ExternalIntegrationDefaultArgs<ExtArgs>
    group?: boolean | ExternalGroupMapping$groupArgs<ExtArgs>
  }
  export type ExternalGroupMappingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    integration?: boolean | ExternalIntegrationDefaultArgs<ExtArgs>
    group?: boolean | ExternalGroupMapping$groupArgs<ExtArgs>
  }
  export type ExternalGroupMappingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    integration?: boolean | ExternalIntegrationDefaultArgs<ExtArgs>
    group?: boolean | ExternalGroupMapping$groupArgs<ExtArgs>
  }

  export type $ExternalGroupMappingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExternalGroupMapping"
    objects: {
      integration: Prisma.$ExternalIntegrationPayload<ExtArgs>
      group: Prisma.$GroupPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      integrationId: string
      externalGroupId: string
      externalGroupName: string
      externalGroupType: string | null
      groupId: string | null
      syncMembers: boolean
      syncLeaders: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["externalGroupMapping"]>
    composites: {}
  }

  type ExternalGroupMappingGetPayload<S extends boolean | null | undefined | ExternalGroupMappingDefaultArgs> = $Result.GetResult<Prisma.$ExternalGroupMappingPayload, S>

  type ExternalGroupMappingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExternalGroupMappingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExternalGroupMappingCountAggregateInputType | true
    }

  export interface ExternalGroupMappingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExternalGroupMapping'], meta: { name: 'ExternalGroupMapping' } }
    /**
     * Find zero or one ExternalGroupMapping that matches the filter.
     * @param {ExternalGroupMappingFindUniqueArgs} args - Arguments to find a ExternalGroupMapping
     * @example
     * // Get one ExternalGroupMapping
     * const externalGroupMapping = await prisma.externalGroupMapping.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExternalGroupMappingFindUniqueArgs>(args: SelectSubset<T, ExternalGroupMappingFindUniqueArgs<ExtArgs>>): Prisma__ExternalGroupMappingClient<$Result.GetResult<Prisma.$ExternalGroupMappingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExternalGroupMapping that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExternalGroupMappingFindUniqueOrThrowArgs} args - Arguments to find a ExternalGroupMapping
     * @example
     * // Get one ExternalGroupMapping
     * const externalGroupMapping = await prisma.externalGroupMapping.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExternalGroupMappingFindUniqueOrThrowArgs>(args: SelectSubset<T, ExternalGroupMappingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExternalGroupMappingClient<$Result.GetResult<Prisma.$ExternalGroupMappingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExternalGroupMapping that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalGroupMappingFindFirstArgs} args - Arguments to find a ExternalGroupMapping
     * @example
     * // Get one ExternalGroupMapping
     * const externalGroupMapping = await prisma.externalGroupMapping.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExternalGroupMappingFindFirstArgs>(args?: SelectSubset<T, ExternalGroupMappingFindFirstArgs<ExtArgs>>): Prisma__ExternalGroupMappingClient<$Result.GetResult<Prisma.$ExternalGroupMappingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExternalGroupMapping that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalGroupMappingFindFirstOrThrowArgs} args - Arguments to find a ExternalGroupMapping
     * @example
     * // Get one ExternalGroupMapping
     * const externalGroupMapping = await prisma.externalGroupMapping.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExternalGroupMappingFindFirstOrThrowArgs>(args?: SelectSubset<T, ExternalGroupMappingFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExternalGroupMappingClient<$Result.GetResult<Prisma.$ExternalGroupMappingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExternalGroupMappings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalGroupMappingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExternalGroupMappings
     * const externalGroupMappings = await prisma.externalGroupMapping.findMany()
     * 
     * // Get first 10 ExternalGroupMappings
     * const externalGroupMappings = await prisma.externalGroupMapping.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const externalGroupMappingWithIdOnly = await prisma.externalGroupMapping.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExternalGroupMappingFindManyArgs>(args?: SelectSubset<T, ExternalGroupMappingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExternalGroupMappingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExternalGroupMapping.
     * @param {ExternalGroupMappingCreateArgs} args - Arguments to create a ExternalGroupMapping.
     * @example
     * // Create one ExternalGroupMapping
     * const ExternalGroupMapping = await prisma.externalGroupMapping.create({
     *   data: {
     *     // ... data to create a ExternalGroupMapping
     *   }
     * })
     * 
     */
    create<T extends ExternalGroupMappingCreateArgs>(args: SelectSubset<T, ExternalGroupMappingCreateArgs<ExtArgs>>): Prisma__ExternalGroupMappingClient<$Result.GetResult<Prisma.$ExternalGroupMappingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExternalGroupMappings.
     * @param {ExternalGroupMappingCreateManyArgs} args - Arguments to create many ExternalGroupMappings.
     * @example
     * // Create many ExternalGroupMappings
     * const externalGroupMapping = await prisma.externalGroupMapping.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExternalGroupMappingCreateManyArgs>(args?: SelectSubset<T, ExternalGroupMappingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExternalGroupMappings and returns the data saved in the database.
     * @param {ExternalGroupMappingCreateManyAndReturnArgs} args - Arguments to create many ExternalGroupMappings.
     * @example
     * // Create many ExternalGroupMappings
     * const externalGroupMapping = await prisma.externalGroupMapping.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExternalGroupMappings and only return the `id`
     * const externalGroupMappingWithIdOnly = await prisma.externalGroupMapping.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExternalGroupMappingCreateManyAndReturnArgs>(args?: SelectSubset<T, ExternalGroupMappingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExternalGroupMappingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ExternalGroupMapping.
     * @param {ExternalGroupMappingDeleteArgs} args - Arguments to delete one ExternalGroupMapping.
     * @example
     * // Delete one ExternalGroupMapping
     * const ExternalGroupMapping = await prisma.externalGroupMapping.delete({
     *   where: {
     *     // ... filter to delete one ExternalGroupMapping
     *   }
     * })
     * 
     */
    delete<T extends ExternalGroupMappingDeleteArgs>(args: SelectSubset<T, ExternalGroupMappingDeleteArgs<ExtArgs>>): Prisma__ExternalGroupMappingClient<$Result.GetResult<Prisma.$ExternalGroupMappingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExternalGroupMapping.
     * @param {ExternalGroupMappingUpdateArgs} args - Arguments to update one ExternalGroupMapping.
     * @example
     * // Update one ExternalGroupMapping
     * const externalGroupMapping = await prisma.externalGroupMapping.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExternalGroupMappingUpdateArgs>(args: SelectSubset<T, ExternalGroupMappingUpdateArgs<ExtArgs>>): Prisma__ExternalGroupMappingClient<$Result.GetResult<Prisma.$ExternalGroupMappingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExternalGroupMappings.
     * @param {ExternalGroupMappingDeleteManyArgs} args - Arguments to filter ExternalGroupMappings to delete.
     * @example
     * // Delete a few ExternalGroupMappings
     * const { count } = await prisma.externalGroupMapping.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExternalGroupMappingDeleteManyArgs>(args?: SelectSubset<T, ExternalGroupMappingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExternalGroupMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalGroupMappingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExternalGroupMappings
     * const externalGroupMapping = await prisma.externalGroupMapping.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExternalGroupMappingUpdateManyArgs>(args: SelectSubset<T, ExternalGroupMappingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExternalGroupMappings and returns the data updated in the database.
     * @param {ExternalGroupMappingUpdateManyAndReturnArgs} args - Arguments to update many ExternalGroupMappings.
     * @example
     * // Update many ExternalGroupMappings
     * const externalGroupMapping = await prisma.externalGroupMapping.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExternalGroupMappings and only return the `id`
     * const externalGroupMappingWithIdOnly = await prisma.externalGroupMapping.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExternalGroupMappingUpdateManyAndReturnArgs>(args: SelectSubset<T, ExternalGroupMappingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExternalGroupMappingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ExternalGroupMapping.
     * @param {ExternalGroupMappingUpsertArgs} args - Arguments to update or create a ExternalGroupMapping.
     * @example
     * // Update or create a ExternalGroupMapping
     * const externalGroupMapping = await prisma.externalGroupMapping.upsert({
     *   create: {
     *     // ... data to create a ExternalGroupMapping
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExternalGroupMapping we want to update
     *   }
     * })
     */
    upsert<T extends ExternalGroupMappingUpsertArgs>(args: SelectSubset<T, ExternalGroupMappingUpsertArgs<ExtArgs>>): Prisma__ExternalGroupMappingClient<$Result.GetResult<Prisma.$ExternalGroupMappingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExternalGroupMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalGroupMappingCountArgs} args - Arguments to filter ExternalGroupMappings to count.
     * @example
     * // Count the number of ExternalGroupMappings
     * const count = await prisma.externalGroupMapping.count({
     *   where: {
     *     // ... the filter for the ExternalGroupMappings we want to count
     *   }
     * })
    **/
    count<T extends ExternalGroupMappingCountArgs>(
      args?: Subset<T, ExternalGroupMappingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExternalGroupMappingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExternalGroupMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalGroupMappingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExternalGroupMappingAggregateArgs>(args: Subset<T, ExternalGroupMappingAggregateArgs>): Prisma.PrismaPromise<GetExternalGroupMappingAggregateType<T>>

    /**
     * Group by ExternalGroupMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalGroupMappingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExternalGroupMappingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExternalGroupMappingGroupByArgs['orderBy'] }
        : { orderBy?: ExternalGroupMappingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExternalGroupMappingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExternalGroupMappingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExternalGroupMapping model
   */
  readonly fields: ExternalGroupMappingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExternalGroupMapping.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExternalGroupMappingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    integration<T extends ExternalIntegrationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExternalIntegrationDefaultArgs<ExtArgs>>): Prisma__ExternalIntegrationClient<$Result.GetResult<Prisma.$ExternalIntegrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    group<T extends ExternalGroupMapping$groupArgs<ExtArgs> = {}>(args?: Subset<T, ExternalGroupMapping$groupArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExternalGroupMapping model
   */
  interface ExternalGroupMappingFieldRefs {
    readonly id: FieldRef<"ExternalGroupMapping", 'String'>
    readonly integrationId: FieldRef<"ExternalGroupMapping", 'String'>
    readonly externalGroupId: FieldRef<"ExternalGroupMapping", 'String'>
    readonly externalGroupName: FieldRef<"ExternalGroupMapping", 'String'>
    readonly externalGroupType: FieldRef<"ExternalGroupMapping", 'String'>
    readonly groupId: FieldRef<"ExternalGroupMapping", 'String'>
    readonly syncMembers: FieldRef<"ExternalGroupMapping", 'Boolean'>
    readonly syncLeaders: FieldRef<"ExternalGroupMapping", 'Boolean'>
    readonly createdAt: FieldRef<"ExternalGroupMapping", 'DateTime'>
    readonly updatedAt: FieldRef<"ExternalGroupMapping", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExternalGroupMapping findUnique
   */
  export type ExternalGroupMappingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalGroupMapping
     */
    select?: ExternalGroupMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalGroupMapping
     */
    omit?: ExternalGroupMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalGroupMappingInclude<ExtArgs> | null
    /**
     * Filter, which ExternalGroupMapping to fetch.
     */
    where: ExternalGroupMappingWhereUniqueInput
  }

  /**
   * ExternalGroupMapping findUniqueOrThrow
   */
  export type ExternalGroupMappingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalGroupMapping
     */
    select?: ExternalGroupMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalGroupMapping
     */
    omit?: ExternalGroupMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalGroupMappingInclude<ExtArgs> | null
    /**
     * Filter, which ExternalGroupMapping to fetch.
     */
    where: ExternalGroupMappingWhereUniqueInput
  }

  /**
   * ExternalGroupMapping findFirst
   */
  export type ExternalGroupMappingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalGroupMapping
     */
    select?: ExternalGroupMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalGroupMapping
     */
    omit?: ExternalGroupMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalGroupMappingInclude<ExtArgs> | null
    /**
     * Filter, which ExternalGroupMapping to fetch.
     */
    where?: ExternalGroupMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalGroupMappings to fetch.
     */
    orderBy?: ExternalGroupMappingOrderByWithRelationInput | ExternalGroupMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExternalGroupMappings.
     */
    cursor?: ExternalGroupMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalGroupMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalGroupMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExternalGroupMappings.
     */
    distinct?: ExternalGroupMappingScalarFieldEnum | ExternalGroupMappingScalarFieldEnum[]
  }

  /**
   * ExternalGroupMapping findFirstOrThrow
   */
  export type ExternalGroupMappingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalGroupMapping
     */
    select?: ExternalGroupMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalGroupMapping
     */
    omit?: ExternalGroupMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalGroupMappingInclude<ExtArgs> | null
    /**
     * Filter, which ExternalGroupMapping to fetch.
     */
    where?: ExternalGroupMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalGroupMappings to fetch.
     */
    orderBy?: ExternalGroupMappingOrderByWithRelationInput | ExternalGroupMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExternalGroupMappings.
     */
    cursor?: ExternalGroupMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalGroupMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalGroupMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExternalGroupMappings.
     */
    distinct?: ExternalGroupMappingScalarFieldEnum | ExternalGroupMappingScalarFieldEnum[]
  }

  /**
   * ExternalGroupMapping findMany
   */
  export type ExternalGroupMappingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalGroupMapping
     */
    select?: ExternalGroupMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalGroupMapping
     */
    omit?: ExternalGroupMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalGroupMappingInclude<ExtArgs> | null
    /**
     * Filter, which ExternalGroupMappings to fetch.
     */
    where?: ExternalGroupMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalGroupMappings to fetch.
     */
    orderBy?: ExternalGroupMappingOrderByWithRelationInput | ExternalGroupMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExternalGroupMappings.
     */
    cursor?: ExternalGroupMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalGroupMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalGroupMappings.
     */
    skip?: number
    distinct?: ExternalGroupMappingScalarFieldEnum | ExternalGroupMappingScalarFieldEnum[]
  }

  /**
   * ExternalGroupMapping create
   */
  export type ExternalGroupMappingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalGroupMapping
     */
    select?: ExternalGroupMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalGroupMapping
     */
    omit?: ExternalGroupMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalGroupMappingInclude<ExtArgs> | null
    /**
     * The data needed to create a ExternalGroupMapping.
     */
    data: XOR<ExternalGroupMappingCreateInput, ExternalGroupMappingUncheckedCreateInput>
  }

  /**
   * ExternalGroupMapping createMany
   */
  export type ExternalGroupMappingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExternalGroupMappings.
     */
    data: ExternalGroupMappingCreateManyInput | ExternalGroupMappingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExternalGroupMapping createManyAndReturn
   */
  export type ExternalGroupMappingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalGroupMapping
     */
    select?: ExternalGroupMappingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalGroupMapping
     */
    omit?: ExternalGroupMappingOmit<ExtArgs> | null
    /**
     * The data used to create many ExternalGroupMappings.
     */
    data: ExternalGroupMappingCreateManyInput | ExternalGroupMappingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalGroupMappingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExternalGroupMapping update
   */
  export type ExternalGroupMappingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalGroupMapping
     */
    select?: ExternalGroupMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalGroupMapping
     */
    omit?: ExternalGroupMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalGroupMappingInclude<ExtArgs> | null
    /**
     * The data needed to update a ExternalGroupMapping.
     */
    data: XOR<ExternalGroupMappingUpdateInput, ExternalGroupMappingUncheckedUpdateInput>
    /**
     * Choose, which ExternalGroupMapping to update.
     */
    where: ExternalGroupMappingWhereUniqueInput
  }

  /**
   * ExternalGroupMapping updateMany
   */
  export type ExternalGroupMappingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExternalGroupMappings.
     */
    data: XOR<ExternalGroupMappingUpdateManyMutationInput, ExternalGroupMappingUncheckedUpdateManyInput>
    /**
     * Filter which ExternalGroupMappings to update
     */
    where?: ExternalGroupMappingWhereInput
    /**
     * Limit how many ExternalGroupMappings to update.
     */
    limit?: number
  }

  /**
   * ExternalGroupMapping updateManyAndReturn
   */
  export type ExternalGroupMappingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalGroupMapping
     */
    select?: ExternalGroupMappingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalGroupMapping
     */
    omit?: ExternalGroupMappingOmit<ExtArgs> | null
    /**
     * The data used to update ExternalGroupMappings.
     */
    data: XOR<ExternalGroupMappingUpdateManyMutationInput, ExternalGroupMappingUncheckedUpdateManyInput>
    /**
     * Filter which ExternalGroupMappings to update
     */
    where?: ExternalGroupMappingWhereInput
    /**
     * Limit how many ExternalGroupMappings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalGroupMappingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExternalGroupMapping upsert
   */
  export type ExternalGroupMappingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalGroupMapping
     */
    select?: ExternalGroupMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalGroupMapping
     */
    omit?: ExternalGroupMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalGroupMappingInclude<ExtArgs> | null
    /**
     * The filter to search for the ExternalGroupMapping to update in case it exists.
     */
    where: ExternalGroupMappingWhereUniqueInput
    /**
     * In case the ExternalGroupMapping found by the `where` argument doesn't exist, create a new ExternalGroupMapping with this data.
     */
    create: XOR<ExternalGroupMappingCreateInput, ExternalGroupMappingUncheckedCreateInput>
    /**
     * In case the ExternalGroupMapping was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExternalGroupMappingUpdateInput, ExternalGroupMappingUncheckedUpdateInput>
  }

  /**
   * ExternalGroupMapping delete
   */
  export type ExternalGroupMappingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalGroupMapping
     */
    select?: ExternalGroupMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalGroupMapping
     */
    omit?: ExternalGroupMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalGroupMappingInclude<ExtArgs> | null
    /**
     * Filter which ExternalGroupMapping to delete.
     */
    where: ExternalGroupMappingWhereUniqueInput
  }

  /**
   * ExternalGroupMapping deleteMany
   */
  export type ExternalGroupMappingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExternalGroupMappings to delete
     */
    where?: ExternalGroupMappingWhereInput
    /**
     * Limit how many ExternalGroupMappings to delete.
     */
    limit?: number
  }

  /**
   * ExternalGroupMapping.group
   */
  export type ExternalGroupMapping$groupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    where?: GroupWhereInput
  }

  /**
   * ExternalGroupMapping without action
   */
  export type ExternalGroupMappingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalGroupMapping
     */
    select?: ExternalGroupMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalGroupMapping
     */
    omit?: ExternalGroupMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalGroupMappingInclude<ExtArgs> | null
  }


  /**
   * Model SyncLog
   */

  export type AggregateSyncLog = {
    _count: SyncLogCountAggregateOutputType | null
    _avg: SyncLogAvgAggregateOutputType | null
    _sum: SyncLogSumAggregateOutputType | null
    _min: SyncLogMinAggregateOutputType | null
    _max: SyncLogMaxAggregateOutputType | null
  }

  export type SyncLogAvgAggregateOutputType = {
    durationMs: number | null
    peopleAdded: number | null
    peopleUpdated: number | null
    peopleRemoved: number | null
    groupsAdded: number | null
    groupsUpdated: number | null
    groupsSkipped: number | null
  }

  export type SyncLogSumAggregateOutputType = {
    durationMs: number | null
    peopleAdded: number | null
    peopleUpdated: number | null
    peopleRemoved: number | null
    groupsAdded: number | null
    groupsUpdated: number | null
    groupsSkipped: number | null
  }

  export type SyncLogMinAggregateOutputType = {
    id: string | null
    integrationId: string | null
    status: $Enums.SyncStatus | null
    startedAt: Date | null
    completedAt: Date | null
    durationMs: number | null
    peopleAdded: number | null
    peopleUpdated: number | null
    peopleRemoved: number | null
    groupsAdded: number | null
    groupsUpdated: number | null
    groupsSkipped: number | null
    errorMessage: string | null
    errorCode: string | null
  }

  export type SyncLogMaxAggregateOutputType = {
    id: string | null
    integrationId: string | null
    status: $Enums.SyncStatus | null
    startedAt: Date | null
    completedAt: Date | null
    durationMs: number | null
    peopleAdded: number | null
    peopleUpdated: number | null
    peopleRemoved: number | null
    groupsAdded: number | null
    groupsUpdated: number | null
    groupsSkipped: number | null
    errorMessage: string | null
    errorCode: string | null
  }

  export type SyncLogCountAggregateOutputType = {
    id: number
    integrationId: number
    status: number
    startedAt: number
    completedAt: number
    durationMs: number
    peopleAdded: number
    peopleUpdated: number
    peopleRemoved: number
    groupsAdded: number
    groupsUpdated: number
    groupsSkipped: number
    errorMessage: number
    errorCode: number
    errorDetails: number
    metadata: number
    _all: number
  }


  export type SyncLogAvgAggregateInputType = {
    durationMs?: true
    peopleAdded?: true
    peopleUpdated?: true
    peopleRemoved?: true
    groupsAdded?: true
    groupsUpdated?: true
    groupsSkipped?: true
  }

  export type SyncLogSumAggregateInputType = {
    durationMs?: true
    peopleAdded?: true
    peopleUpdated?: true
    peopleRemoved?: true
    groupsAdded?: true
    groupsUpdated?: true
    groupsSkipped?: true
  }

  export type SyncLogMinAggregateInputType = {
    id?: true
    integrationId?: true
    status?: true
    startedAt?: true
    completedAt?: true
    durationMs?: true
    peopleAdded?: true
    peopleUpdated?: true
    peopleRemoved?: true
    groupsAdded?: true
    groupsUpdated?: true
    groupsSkipped?: true
    errorMessage?: true
    errorCode?: true
  }

  export type SyncLogMaxAggregateInputType = {
    id?: true
    integrationId?: true
    status?: true
    startedAt?: true
    completedAt?: true
    durationMs?: true
    peopleAdded?: true
    peopleUpdated?: true
    peopleRemoved?: true
    groupsAdded?: true
    groupsUpdated?: true
    groupsSkipped?: true
    errorMessage?: true
    errorCode?: true
  }

  export type SyncLogCountAggregateInputType = {
    id?: true
    integrationId?: true
    status?: true
    startedAt?: true
    completedAt?: true
    durationMs?: true
    peopleAdded?: true
    peopleUpdated?: true
    peopleRemoved?: true
    groupsAdded?: true
    groupsUpdated?: true
    groupsSkipped?: true
    errorMessage?: true
    errorCode?: true
    errorDetails?: true
    metadata?: true
    _all?: true
  }

  export type SyncLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SyncLog to aggregate.
     */
    where?: SyncLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncLogs to fetch.
     */
    orderBy?: SyncLogOrderByWithRelationInput | SyncLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SyncLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SyncLogs
    **/
    _count?: true | SyncLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SyncLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SyncLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SyncLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SyncLogMaxAggregateInputType
  }

  export type GetSyncLogAggregateType<T extends SyncLogAggregateArgs> = {
        [P in keyof T & keyof AggregateSyncLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSyncLog[P]>
      : GetScalarType<T[P], AggregateSyncLog[P]>
  }




  export type SyncLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SyncLogWhereInput
    orderBy?: SyncLogOrderByWithAggregationInput | SyncLogOrderByWithAggregationInput[]
    by: SyncLogScalarFieldEnum[] | SyncLogScalarFieldEnum
    having?: SyncLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SyncLogCountAggregateInputType | true
    _avg?: SyncLogAvgAggregateInputType
    _sum?: SyncLogSumAggregateInputType
    _min?: SyncLogMinAggregateInputType
    _max?: SyncLogMaxAggregateInputType
  }

  export type SyncLogGroupByOutputType = {
    id: string
    integrationId: string
    status: $Enums.SyncStatus
    startedAt: Date
    completedAt: Date | null
    durationMs: number | null
    peopleAdded: number
    peopleUpdated: number
    peopleRemoved: number
    groupsAdded: number
    groupsUpdated: number
    groupsSkipped: number
    errorMessage: string | null
    errorCode: string | null
    errorDetails: JsonValue | null
    metadata: JsonValue | null
    _count: SyncLogCountAggregateOutputType | null
    _avg: SyncLogAvgAggregateOutputType | null
    _sum: SyncLogSumAggregateOutputType | null
    _min: SyncLogMinAggregateOutputType | null
    _max: SyncLogMaxAggregateOutputType | null
  }

  type GetSyncLogGroupByPayload<T extends SyncLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SyncLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SyncLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SyncLogGroupByOutputType[P]>
            : GetScalarType<T[P], SyncLogGroupByOutputType[P]>
        }
      >
    >


  export type SyncLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    integrationId?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
    durationMs?: boolean
    peopleAdded?: boolean
    peopleUpdated?: boolean
    peopleRemoved?: boolean
    groupsAdded?: boolean
    groupsUpdated?: boolean
    groupsSkipped?: boolean
    errorMessage?: boolean
    errorCode?: boolean
    errorDetails?: boolean
    metadata?: boolean
    integration?: boolean | ExternalIntegrationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["syncLog"]>

  export type SyncLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    integrationId?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
    durationMs?: boolean
    peopleAdded?: boolean
    peopleUpdated?: boolean
    peopleRemoved?: boolean
    groupsAdded?: boolean
    groupsUpdated?: boolean
    groupsSkipped?: boolean
    errorMessage?: boolean
    errorCode?: boolean
    errorDetails?: boolean
    metadata?: boolean
    integration?: boolean | ExternalIntegrationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["syncLog"]>

  export type SyncLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    integrationId?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
    durationMs?: boolean
    peopleAdded?: boolean
    peopleUpdated?: boolean
    peopleRemoved?: boolean
    groupsAdded?: boolean
    groupsUpdated?: boolean
    groupsSkipped?: boolean
    errorMessage?: boolean
    errorCode?: boolean
    errorDetails?: boolean
    metadata?: boolean
    integration?: boolean | ExternalIntegrationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["syncLog"]>

  export type SyncLogSelectScalar = {
    id?: boolean
    integrationId?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
    durationMs?: boolean
    peopleAdded?: boolean
    peopleUpdated?: boolean
    peopleRemoved?: boolean
    groupsAdded?: boolean
    groupsUpdated?: boolean
    groupsSkipped?: boolean
    errorMessage?: boolean
    errorCode?: boolean
    errorDetails?: boolean
    metadata?: boolean
  }

  export type SyncLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "integrationId" | "status" | "startedAt" | "completedAt" | "durationMs" | "peopleAdded" | "peopleUpdated" | "peopleRemoved" | "groupsAdded" | "groupsUpdated" | "groupsSkipped" | "errorMessage" | "errorCode" | "errorDetails" | "metadata", ExtArgs["result"]["syncLog"]>
  export type SyncLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    integration?: boolean | ExternalIntegrationDefaultArgs<ExtArgs>
  }
  export type SyncLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    integration?: boolean | ExternalIntegrationDefaultArgs<ExtArgs>
  }
  export type SyncLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    integration?: boolean | ExternalIntegrationDefaultArgs<ExtArgs>
  }

  export type $SyncLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SyncLog"
    objects: {
      integration: Prisma.$ExternalIntegrationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      integrationId: string
      status: $Enums.SyncStatus
      startedAt: Date
      completedAt: Date | null
      durationMs: number | null
      peopleAdded: number
      peopleUpdated: number
      peopleRemoved: number
      groupsAdded: number
      groupsUpdated: number
      groupsSkipped: number
      errorMessage: string | null
      errorCode: string | null
      errorDetails: Prisma.JsonValue | null
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["syncLog"]>
    composites: {}
  }

  type SyncLogGetPayload<S extends boolean | null | undefined | SyncLogDefaultArgs> = $Result.GetResult<Prisma.$SyncLogPayload, S>

  type SyncLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SyncLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SyncLogCountAggregateInputType | true
    }

  export interface SyncLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SyncLog'], meta: { name: 'SyncLog' } }
    /**
     * Find zero or one SyncLog that matches the filter.
     * @param {SyncLogFindUniqueArgs} args - Arguments to find a SyncLog
     * @example
     * // Get one SyncLog
     * const syncLog = await prisma.syncLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SyncLogFindUniqueArgs>(args: SelectSubset<T, SyncLogFindUniqueArgs<ExtArgs>>): Prisma__SyncLogClient<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SyncLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SyncLogFindUniqueOrThrowArgs} args - Arguments to find a SyncLog
     * @example
     * // Get one SyncLog
     * const syncLog = await prisma.syncLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SyncLogFindUniqueOrThrowArgs>(args: SelectSubset<T, SyncLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SyncLogClient<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SyncLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncLogFindFirstArgs} args - Arguments to find a SyncLog
     * @example
     * // Get one SyncLog
     * const syncLog = await prisma.syncLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SyncLogFindFirstArgs>(args?: SelectSubset<T, SyncLogFindFirstArgs<ExtArgs>>): Prisma__SyncLogClient<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SyncLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncLogFindFirstOrThrowArgs} args - Arguments to find a SyncLog
     * @example
     * // Get one SyncLog
     * const syncLog = await prisma.syncLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SyncLogFindFirstOrThrowArgs>(args?: SelectSubset<T, SyncLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__SyncLogClient<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SyncLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SyncLogs
     * const syncLogs = await prisma.syncLog.findMany()
     * 
     * // Get first 10 SyncLogs
     * const syncLogs = await prisma.syncLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const syncLogWithIdOnly = await prisma.syncLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SyncLogFindManyArgs>(args?: SelectSubset<T, SyncLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SyncLog.
     * @param {SyncLogCreateArgs} args - Arguments to create a SyncLog.
     * @example
     * // Create one SyncLog
     * const SyncLog = await prisma.syncLog.create({
     *   data: {
     *     // ... data to create a SyncLog
     *   }
     * })
     * 
     */
    create<T extends SyncLogCreateArgs>(args: SelectSubset<T, SyncLogCreateArgs<ExtArgs>>): Prisma__SyncLogClient<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SyncLogs.
     * @param {SyncLogCreateManyArgs} args - Arguments to create many SyncLogs.
     * @example
     * // Create many SyncLogs
     * const syncLog = await prisma.syncLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SyncLogCreateManyArgs>(args?: SelectSubset<T, SyncLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SyncLogs and returns the data saved in the database.
     * @param {SyncLogCreateManyAndReturnArgs} args - Arguments to create many SyncLogs.
     * @example
     * // Create many SyncLogs
     * const syncLog = await prisma.syncLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SyncLogs and only return the `id`
     * const syncLogWithIdOnly = await prisma.syncLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SyncLogCreateManyAndReturnArgs>(args?: SelectSubset<T, SyncLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SyncLog.
     * @param {SyncLogDeleteArgs} args - Arguments to delete one SyncLog.
     * @example
     * // Delete one SyncLog
     * const SyncLog = await prisma.syncLog.delete({
     *   where: {
     *     // ... filter to delete one SyncLog
     *   }
     * })
     * 
     */
    delete<T extends SyncLogDeleteArgs>(args: SelectSubset<T, SyncLogDeleteArgs<ExtArgs>>): Prisma__SyncLogClient<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SyncLog.
     * @param {SyncLogUpdateArgs} args - Arguments to update one SyncLog.
     * @example
     * // Update one SyncLog
     * const syncLog = await prisma.syncLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SyncLogUpdateArgs>(args: SelectSubset<T, SyncLogUpdateArgs<ExtArgs>>): Prisma__SyncLogClient<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SyncLogs.
     * @param {SyncLogDeleteManyArgs} args - Arguments to filter SyncLogs to delete.
     * @example
     * // Delete a few SyncLogs
     * const { count } = await prisma.syncLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SyncLogDeleteManyArgs>(args?: SelectSubset<T, SyncLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SyncLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SyncLogs
     * const syncLog = await prisma.syncLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SyncLogUpdateManyArgs>(args: SelectSubset<T, SyncLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SyncLogs and returns the data updated in the database.
     * @param {SyncLogUpdateManyAndReturnArgs} args - Arguments to update many SyncLogs.
     * @example
     * // Update many SyncLogs
     * const syncLog = await prisma.syncLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SyncLogs and only return the `id`
     * const syncLogWithIdOnly = await prisma.syncLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SyncLogUpdateManyAndReturnArgs>(args: SelectSubset<T, SyncLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SyncLog.
     * @param {SyncLogUpsertArgs} args - Arguments to update or create a SyncLog.
     * @example
     * // Update or create a SyncLog
     * const syncLog = await prisma.syncLog.upsert({
     *   create: {
     *     // ... data to create a SyncLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SyncLog we want to update
     *   }
     * })
     */
    upsert<T extends SyncLogUpsertArgs>(args: SelectSubset<T, SyncLogUpsertArgs<ExtArgs>>): Prisma__SyncLogClient<$Result.GetResult<Prisma.$SyncLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SyncLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncLogCountArgs} args - Arguments to filter SyncLogs to count.
     * @example
     * // Count the number of SyncLogs
     * const count = await prisma.syncLog.count({
     *   where: {
     *     // ... the filter for the SyncLogs we want to count
     *   }
     * })
    **/
    count<T extends SyncLogCountArgs>(
      args?: Subset<T, SyncLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SyncLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SyncLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SyncLogAggregateArgs>(args: Subset<T, SyncLogAggregateArgs>): Prisma.PrismaPromise<GetSyncLogAggregateType<T>>

    /**
     * Group by SyncLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SyncLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SyncLogGroupByArgs['orderBy'] }
        : { orderBy?: SyncLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SyncLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSyncLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SyncLog model
   */
  readonly fields: SyncLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SyncLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SyncLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    integration<T extends ExternalIntegrationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExternalIntegrationDefaultArgs<ExtArgs>>): Prisma__ExternalIntegrationClient<$Result.GetResult<Prisma.$ExternalIntegrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SyncLog model
   */
  interface SyncLogFieldRefs {
    readonly id: FieldRef<"SyncLog", 'String'>
    readonly integrationId: FieldRef<"SyncLog", 'String'>
    readonly status: FieldRef<"SyncLog", 'SyncStatus'>
    readonly startedAt: FieldRef<"SyncLog", 'DateTime'>
    readonly completedAt: FieldRef<"SyncLog", 'DateTime'>
    readonly durationMs: FieldRef<"SyncLog", 'Int'>
    readonly peopleAdded: FieldRef<"SyncLog", 'Int'>
    readonly peopleUpdated: FieldRef<"SyncLog", 'Int'>
    readonly peopleRemoved: FieldRef<"SyncLog", 'Int'>
    readonly groupsAdded: FieldRef<"SyncLog", 'Int'>
    readonly groupsUpdated: FieldRef<"SyncLog", 'Int'>
    readonly groupsSkipped: FieldRef<"SyncLog", 'Int'>
    readonly errorMessage: FieldRef<"SyncLog", 'String'>
    readonly errorCode: FieldRef<"SyncLog", 'String'>
    readonly errorDetails: FieldRef<"SyncLog", 'Json'>
    readonly metadata: FieldRef<"SyncLog", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * SyncLog findUnique
   */
  export type SyncLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncLog
     */
    omit?: SyncLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncLogInclude<ExtArgs> | null
    /**
     * Filter, which SyncLog to fetch.
     */
    where: SyncLogWhereUniqueInput
  }

  /**
   * SyncLog findUniqueOrThrow
   */
  export type SyncLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncLog
     */
    omit?: SyncLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncLogInclude<ExtArgs> | null
    /**
     * Filter, which SyncLog to fetch.
     */
    where: SyncLogWhereUniqueInput
  }

  /**
   * SyncLog findFirst
   */
  export type SyncLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncLog
     */
    omit?: SyncLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncLogInclude<ExtArgs> | null
    /**
     * Filter, which SyncLog to fetch.
     */
    where?: SyncLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncLogs to fetch.
     */
    orderBy?: SyncLogOrderByWithRelationInput | SyncLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SyncLogs.
     */
    cursor?: SyncLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SyncLogs.
     */
    distinct?: SyncLogScalarFieldEnum | SyncLogScalarFieldEnum[]
  }

  /**
   * SyncLog findFirstOrThrow
   */
  export type SyncLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncLog
     */
    omit?: SyncLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncLogInclude<ExtArgs> | null
    /**
     * Filter, which SyncLog to fetch.
     */
    where?: SyncLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncLogs to fetch.
     */
    orderBy?: SyncLogOrderByWithRelationInput | SyncLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SyncLogs.
     */
    cursor?: SyncLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SyncLogs.
     */
    distinct?: SyncLogScalarFieldEnum | SyncLogScalarFieldEnum[]
  }

  /**
   * SyncLog findMany
   */
  export type SyncLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncLog
     */
    omit?: SyncLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncLogInclude<ExtArgs> | null
    /**
     * Filter, which SyncLogs to fetch.
     */
    where?: SyncLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncLogs to fetch.
     */
    orderBy?: SyncLogOrderByWithRelationInput | SyncLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SyncLogs.
     */
    cursor?: SyncLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncLogs.
     */
    skip?: number
    distinct?: SyncLogScalarFieldEnum | SyncLogScalarFieldEnum[]
  }

  /**
   * SyncLog create
   */
  export type SyncLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncLog
     */
    omit?: SyncLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncLogInclude<ExtArgs> | null
    /**
     * The data needed to create a SyncLog.
     */
    data: XOR<SyncLogCreateInput, SyncLogUncheckedCreateInput>
  }

  /**
   * SyncLog createMany
   */
  export type SyncLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SyncLogs.
     */
    data: SyncLogCreateManyInput | SyncLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SyncLog createManyAndReturn
   */
  export type SyncLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SyncLog
     */
    omit?: SyncLogOmit<ExtArgs> | null
    /**
     * The data used to create many SyncLogs.
     */
    data: SyncLogCreateManyInput | SyncLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SyncLog update
   */
  export type SyncLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncLog
     */
    omit?: SyncLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncLogInclude<ExtArgs> | null
    /**
     * The data needed to update a SyncLog.
     */
    data: XOR<SyncLogUpdateInput, SyncLogUncheckedUpdateInput>
    /**
     * Choose, which SyncLog to update.
     */
    where: SyncLogWhereUniqueInput
  }

  /**
   * SyncLog updateMany
   */
  export type SyncLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SyncLogs.
     */
    data: XOR<SyncLogUpdateManyMutationInput, SyncLogUncheckedUpdateManyInput>
    /**
     * Filter which SyncLogs to update
     */
    where?: SyncLogWhereInput
    /**
     * Limit how many SyncLogs to update.
     */
    limit?: number
  }

  /**
   * SyncLog updateManyAndReturn
   */
  export type SyncLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SyncLog
     */
    omit?: SyncLogOmit<ExtArgs> | null
    /**
     * The data used to update SyncLogs.
     */
    data: XOR<SyncLogUpdateManyMutationInput, SyncLogUncheckedUpdateManyInput>
    /**
     * Filter which SyncLogs to update
     */
    where?: SyncLogWhereInput
    /**
     * Limit how many SyncLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SyncLog upsert
   */
  export type SyncLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncLog
     */
    omit?: SyncLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncLogInclude<ExtArgs> | null
    /**
     * The filter to search for the SyncLog to update in case it exists.
     */
    where: SyncLogWhereUniqueInput
    /**
     * In case the SyncLog found by the `where` argument doesn't exist, create a new SyncLog with this data.
     */
    create: XOR<SyncLogCreateInput, SyncLogUncheckedCreateInput>
    /**
     * In case the SyncLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SyncLogUpdateInput, SyncLogUncheckedUpdateInput>
  }

  /**
   * SyncLog delete
   */
  export type SyncLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncLog
     */
    omit?: SyncLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncLogInclude<ExtArgs> | null
    /**
     * Filter which SyncLog to delete.
     */
    where: SyncLogWhereUniqueInput
  }

  /**
   * SyncLog deleteMany
   */
  export type SyncLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SyncLogs to delete
     */
    where?: SyncLogWhereInput
    /**
     * Limit how many SyncLogs to delete.
     */
    limit?: number
  }

  /**
   * SyncLog without action
   */
  export type SyncLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncLog
     */
    select?: SyncLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncLog
     */
    omit?: SyncLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncLogInclude<ExtArgs> | null
  }


  /**
   * Model Lesson
   */

  export type AggregateLesson = {
    _count: LessonCountAggregateOutputType | null
    _avg: LessonAvgAggregateOutputType | null
    _sum: LessonSumAggregateOutputType | null
    _min: LessonMinAggregateOutputType | null
    _max: LessonMaxAggregateOutputType | null
  }

  export type LessonAvgAggregateOutputType = {
    quarter: number | null
    unit: number | null
    lessonNumber: number | null
  }

  export type LessonSumAggregateOutputType = {
    quarter: number | null
    unit: number | null
    lessonNumber: number | null
  }

  export type LessonMinAggregateOutputType = {
    id: string | null
    organizationId: string | null
    title: string | null
    quarter: number | null
    unit: number | null
    lessonNumber: number | null
    scripture: string | null
    isPublic: boolean | null
    isTemplate: boolean | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LessonMaxAggregateOutputType = {
    id: string | null
    organizationId: string | null
    title: string | null
    quarter: number | null
    unit: number | null
    lessonNumber: number | null
    scripture: string | null
    isPublic: boolean | null
    isTemplate: boolean | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LessonCountAggregateOutputType = {
    id: number
    organizationId: number
    title: number
    quarter: number
    unit: number
    lessonNumber: number
    scripture: number
    content: number
    slides: number
    games: number
    isPublic: number
    isTemplate: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LessonAvgAggregateInputType = {
    quarter?: true
    unit?: true
    lessonNumber?: true
  }

  export type LessonSumAggregateInputType = {
    quarter?: true
    unit?: true
    lessonNumber?: true
  }

  export type LessonMinAggregateInputType = {
    id?: true
    organizationId?: true
    title?: true
    quarter?: true
    unit?: true
    lessonNumber?: true
    scripture?: true
    isPublic?: true
    isTemplate?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LessonMaxAggregateInputType = {
    id?: true
    organizationId?: true
    title?: true
    quarter?: true
    unit?: true
    lessonNumber?: true
    scripture?: true
    isPublic?: true
    isTemplate?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LessonCountAggregateInputType = {
    id?: true
    organizationId?: true
    title?: true
    quarter?: true
    unit?: true
    lessonNumber?: true
    scripture?: true
    content?: true
    slides?: true
    games?: true
    isPublic?: true
    isTemplate?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LessonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lesson to aggregate.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lessons
    **/
    _count?: true | LessonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LessonAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LessonSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LessonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LessonMaxAggregateInputType
  }

  export type GetLessonAggregateType<T extends LessonAggregateArgs> = {
        [P in keyof T & keyof AggregateLesson]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLesson[P]>
      : GetScalarType<T[P], AggregateLesson[P]>
  }




  export type LessonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonWhereInput
    orderBy?: LessonOrderByWithAggregationInput | LessonOrderByWithAggregationInput[]
    by: LessonScalarFieldEnum[] | LessonScalarFieldEnum
    having?: LessonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LessonCountAggregateInputType | true
    _avg?: LessonAvgAggregateInputType
    _sum?: LessonSumAggregateInputType
    _min?: LessonMinAggregateInputType
    _max?: LessonMaxAggregateInputType
  }

  export type LessonGroupByOutputType = {
    id: string
    organizationId: string
    title: string
    quarter: number
    unit: number
    lessonNumber: number
    scripture: string
    content: JsonValue
    slides: JsonValue | null
    games: JsonValue | null
    isPublic: boolean
    isTemplate: boolean
    createdBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: LessonCountAggregateOutputType | null
    _avg: LessonAvgAggregateOutputType | null
    _sum: LessonSumAggregateOutputType | null
    _min: LessonMinAggregateOutputType | null
    _max: LessonMaxAggregateOutputType | null
  }

  type GetLessonGroupByPayload<T extends LessonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LessonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LessonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LessonGroupByOutputType[P]>
            : GetScalarType<T[P], LessonGroupByOutputType[P]>
        }
      >
    >


  export type LessonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    title?: boolean
    quarter?: boolean
    unit?: boolean
    lessonNumber?: boolean
    scripture?: boolean
    content?: boolean
    slides?: boolean
    games?: boolean
    isPublic?: boolean
    isTemplate?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    groups?: boolean | Lesson$groupsArgs<ExtArgs>
    _count?: boolean | LessonCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lesson"]>

  export type LessonSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    title?: boolean
    quarter?: boolean
    unit?: boolean
    lessonNumber?: boolean
    scripture?: boolean
    content?: boolean
    slides?: boolean
    games?: boolean
    isPublic?: boolean
    isTemplate?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lesson"]>

  export type LessonSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    title?: boolean
    quarter?: boolean
    unit?: boolean
    lessonNumber?: boolean
    scripture?: boolean
    content?: boolean
    slides?: boolean
    games?: boolean
    isPublic?: boolean
    isTemplate?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lesson"]>

  export type LessonSelectScalar = {
    id?: boolean
    organizationId?: boolean
    title?: boolean
    quarter?: boolean
    unit?: boolean
    lessonNumber?: boolean
    scripture?: boolean
    content?: boolean
    slides?: boolean
    games?: boolean
    isPublic?: boolean
    isTemplate?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LessonOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organizationId" | "title" | "quarter" | "unit" | "lessonNumber" | "scripture" | "content" | "slides" | "games" | "isPublic" | "isTemplate" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["lesson"]>
  export type LessonInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    groups?: boolean | Lesson$groupsArgs<ExtArgs>
    _count?: boolean | LessonCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LessonIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type LessonIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $LessonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lesson"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      groups: Prisma.$LessonGroupPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organizationId: string
      title: string
      quarter: number
      unit: number
      lessonNumber: number
      scripture: string
      content: Prisma.JsonValue
      slides: Prisma.JsonValue | null
      games: Prisma.JsonValue | null
      isPublic: boolean
      isTemplate: boolean
      createdBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["lesson"]>
    composites: {}
  }

  type LessonGetPayload<S extends boolean | null | undefined | LessonDefaultArgs> = $Result.GetResult<Prisma.$LessonPayload, S>

  type LessonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LessonFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LessonCountAggregateInputType | true
    }

  export interface LessonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lesson'], meta: { name: 'Lesson' } }
    /**
     * Find zero or one Lesson that matches the filter.
     * @param {LessonFindUniqueArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LessonFindUniqueArgs>(args: SelectSubset<T, LessonFindUniqueArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lesson that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LessonFindUniqueOrThrowArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LessonFindUniqueOrThrowArgs>(args: SelectSubset<T, LessonFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lesson that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonFindFirstArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LessonFindFirstArgs>(args?: SelectSubset<T, LessonFindFirstArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lesson that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonFindFirstOrThrowArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LessonFindFirstOrThrowArgs>(args?: SelectSubset<T, LessonFindFirstOrThrowArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Lessons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lessons
     * const lessons = await prisma.lesson.findMany()
     * 
     * // Get first 10 Lessons
     * const lessons = await prisma.lesson.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lessonWithIdOnly = await prisma.lesson.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LessonFindManyArgs>(args?: SelectSubset<T, LessonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lesson.
     * @param {LessonCreateArgs} args - Arguments to create a Lesson.
     * @example
     * // Create one Lesson
     * const Lesson = await prisma.lesson.create({
     *   data: {
     *     // ... data to create a Lesson
     *   }
     * })
     * 
     */
    create<T extends LessonCreateArgs>(args: SelectSubset<T, LessonCreateArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Lessons.
     * @param {LessonCreateManyArgs} args - Arguments to create many Lessons.
     * @example
     * // Create many Lessons
     * const lesson = await prisma.lesson.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LessonCreateManyArgs>(args?: SelectSubset<T, LessonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Lessons and returns the data saved in the database.
     * @param {LessonCreateManyAndReturnArgs} args - Arguments to create many Lessons.
     * @example
     * // Create many Lessons
     * const lesson = await prisma.lesson.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Lessons and only return the `id`
     * const lessonWithIdOnly = await prisma.lesson.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LessonCreateManyAndReturnArgs>(args?: SelectSubset<T, LessonCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Lesson.
     * @param {LessonDeleteArgs} args - Arguments to delete one Lesson.
     * @example
     * // Delete one Lesson
     * const Lesson = await prisma.lesson.delete({
     *   where: {
     *     // ... filter to delete one Lesson
     *   }
     * })
     * 
     */
    delete<T extends LessonDeleteArgs>(args: SelectSubset<T, LessonDeleteArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lesson.
     * @param {LessonUpdateArgs} args - Arguments to update one Lesson.
     * @example
     * // Update one Lesson
     * const lesson = await prisma.lesson.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LessonUpdateArgs>(args: SelectSubset<T, LessonUpdateArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Lessons.
     * @param {LessonDeleteManyArgs} args - Arguments to filter Lessons to delete.
     * @example
     * // Delete a few Lessons
     * const { count } = await prisma.lesson.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LessonDeleteManyArgs>(args?: SelectSubset<T, LessonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lessons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lessons
     * const lesson = await prisma.lesson.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LessonUpdateManyArgs>(args: SelectSubset<T, LessonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lessons and returns the data updated in the database.
     * @param {LessonUpdateManyAndReturnArgs} args - Arguments to update many Lessons.
     * @example
     * // Update many Lessons
     * const lesson = await prisma.lesson.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Lessons and only return the `id`
     * const lessonWithIdOnly = await prisma.lesson.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LessonUpdateManyAndReturnArgs>(args: SelectSubset<T, LessonUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Lesson.
     * @param {LessonUpsertArgs} args - Arguments to update or create a Lesson.
     * @example
     * // Update or create a Lesson
     * const lesson = await prisma.lesson.upsert({
     *   create: {
     *     // ... data to create a Lesson
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lesson we want to update
     *   }
     * })
     */
    upsert<T extends LessonUpsertArgs>(args: SelectSubset<T, LessonUpsertArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Lessons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonCountArgs} args - Arguments to filter Lessons to count.
     * @example
     * // Count the number of Lessons
     * const count = await prisma.lesson.count({
     *   where: {
     *     // ... the filter for the Lessons we want to count
     *   }
     * })
    **/
    count<T extends LessonCountArgs>(
      args?: Subset<T, LessonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LessonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lesson.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LessonAggregateArgs>(args: Subset<T, LessonAggregateArgs>): Prisma.PrismaPromise<GetLessonAggregateType<T>>

    /**
     * Group by Lesson.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LessonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LessonGroupByArgs['orderBy'] }
        : { orderBy?: LessonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LessonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLessonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lesson model
   */
  readonly fields: LessonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lesson.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LessonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    groups<T extends Lesson$groupsArgs<ExtArgs> = {}>(args?: Subset<T, Lesson$groupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lesson model
   */
  interface LessonFieldRefs {
    readonly id: FieldRef<"Lesson", 'String'>
    readonly organizationId: FieldRef<"Lesson", 'String'>
    readonly title: FieldRef<"Lesson", 'String'>
    readonly quarter: FieldRef<"Lesson", 'Int'>
    readonly unit: FieldRef<"Lesson", 'Int'>
    readonly lessonNumber: FieldRef<"Lesson", 'Int'>
    readonly scripture: FieldRef<"Lesson", 'String'>
    readonly content: FieldRef<"Lesson", 'Json'>
    readonly slides: FieldRef<"Lesson", 'Json'>
    readonly games: FieldRef<"Lesson", 'Json'>
    readonly isPublic: FieldRef<"Lesson", 'Boolean'>
    readonly isTemplate: FieldRef<"Lesson", 'Boolean'>
    readonly createdBy: FieldRef<"Lesson", 'String'>
    readonly createdAt: FieldRef<"Lesson", 'DateTime'>
    readonly updatedAt: FieldRef<"Lesson", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Lesson findUnique
   */
  export type LessonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson findUniqueOrThrow
   */
  export type LessonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson findFirst
   */
  export type LessonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lessons.
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lessons.
     */
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Lesson findFirstOrThrow
   */
  export type LessonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lessons.
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lessons.
     */
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Lesson findMany
   */
  export type LessonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lessons to fetch.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lessons.
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Lesson create
   */
  export type LessonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * The data needed to create a Lesson.
     */
    data: XOR<LessonCreateInput, LessonUncheckedCreateInput>
  }

  /**
   * Lesson createMany
   */
  export type LessonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lessons.
     */
    data: LessonCreateManyInput | LessonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lesson createManyAndReturn
   */
  export type LessonCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * The data used to create many Lessons.
     */
    data: LessonCreateManyInput | LessonCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lesson update
   */
  export type LessonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * The data needed to update a Lesson.
     */
    data: XOR<LessonUpdateInput, LessonUncheckedUpdateInput>
    /**
     * Choose, which Lesson to update.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson updateMany
   */
  export type LessonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lessons.
     */
    data: XOR<LessonUpdateManyMutationInput, LessonUncheckedUpdateManyInput>
    /**
     * Filter which Lessons to update
     */
    where?: LessonWhereInput
    /**
     * Limit how many Lessons to update.
     */
    limit?: number
  }

  /**
   * Lesson updateManyAndReturn
   */
  export type LessonUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * The data used to update Lessons.
     */
    data: XOR<LessonUpdateManyMutationInput, LessonUncheckedUpdateManyInput>
    /**
     * Filter which Lessons to update
     */
    where?: LessonWhereInput
    /**
     * Limit how many Lessons to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lesson upsert
   */
  export type LessonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * The filter to search for the Lesson to update in case it exists.
     */
    where: LessonWhereUniqueInput
    /**
     * In case the Lesson found by the `where` argument doesn't exist, create a new Lesson with this data.
     */
    create: XOR<LessonCreateInput, LessonUncheckedCreateInput>
    /**
     * In case the Lesson was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LessonUpdateInput, LessonUncheckedUpdateInput>
  }

  /**
   * Lesson delete
   */
  export type LessonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter which Lesson to delete.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson deleteMany
   */
  export type LessonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lessons to delete
     */
    where?: LessonWhereInput
    /**
     * Limit how many Lessons to delete.
     */
    limit?: number
  }

  /**
   * Lesson.groups
   */
  export type Lesson$groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonGroup
     */
    select?: LessonGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonGroup
     */
    omit?: LessonGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonGroupInclude<ExtArgs> | null
    where?: LessonGroupWhereInput
    orderBy?: LessonGroupOrderByWithRelationInput | LessonGroupOrderByWithRelationInput[]
    cursor?: LessonGroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonGroupScalarFieldEnum | LessonGroupScalarFieldEnum[]
  }

  /**
   * Lesson without action
   */
  export type LessonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
  }


  /**
   * Model LessonGroup
   */

  export type AggregateLessonGroup = {
    _count: LessonGroupCountAggregateOutputType | null
    _min: LessonGroupMinAggregateOutputType | null
    _max: LessonGroupMaxAggregateOutputType | null
  }

  export type LessonGroupMinAggregateOutputType = {
    id: string | null
    lessonId: string | null
    groupId: string | null
    createdAt: Date | null
  }

  export type LessonGroupMaxAggregateOutputType = {
    id: string | null
    lessonId: string | null
    groupId: string | null
    createdAt: Date | null
  }

  export type LessonGroupCountAggregateOutputType = {
    id: number
    lessonId: number
    groupId: number
    createdAt: number
    _all: number
  }


  export type LessonGroupMinAggregateInputType = {
    id?: true
    lessonId?: true
    groupId?: true
    createdAt?: true
  }

  export type LessonGroupMaxAggregateInputType = {
    id?: true
    lessonId?: true
    groupId?: true
    createdAt?: true
  }

  export type LessonGroupCountAggregateInputType = {
    id?: true
    lessonId?: true
    groupId?: true
    createdAt?: true
    _all?: true
  }

  export type LessonGroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LessonGroup to aggregate.
     */
    where?: LessonGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonGroups to fetch.
     */
    orderBy?: LessonGroupOrderByWithRelationInput | LessonGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LessonGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LessonGroups
    **/
    _count?: true | LessonGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LessonGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LessonGroupMaxAggregateInputType
  }

  export type GetLessonGroupAggregateType<T extends LessonGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateLessonGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLessonGroup[P]>
      : GetScalarType<T[P], AggregateLessonGroup[P]>
  }




  export type LessonGroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonGroupWhereInput
    orderBy?: LessonGroupOrderByWithAggregationInput | LessonGroupOrderByWithAggregationInput[]
    by: LessonGroupScalarFieldEnum[] | LessonGroupScalarFieldEnum
    having?: LessonGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LessonGroupCountAggregateInputType | true
    _min?: LessonGroupMinAggregateInputType
    _max?: LessonGroupMaxAggregateInputType
  }

  export type LessonGroupGroupByOutputType = {
    id: string
    lessonId: string
    groupId: string
    createdAt: Date
    _count: LessonGroupCountAggregateOutputType | null
    _min: LessonGroupMinAggregateOutputType | null
    _max: LessonGroupMaxAggregateOutputType | null
  }

  type GetLessonGroupGroupByPayload<T extends LessonGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LessonGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LessonGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LessonGroupGroupByOutputType[P]>
            : GetScalarType<T[P], LessonGroupGroupByOutputType[P]>
        }
      >
    >


  export type LessonGroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lessonId?: boolean
    groupId?: boolean
    createdAt?: boolean
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lessonGroup"]>

  export type LessonGroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lessonId?: boolean
    groupId?: boolean
    createdAt?: boolean
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lessonGroup"]>

  export type LessonGroupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lessonId?: boolean
    groupId?: boolean
    createdAt?: boolean
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lessonGroup"]>

  export type LessonGroupSelectScalar = {
    id?: boolean
    lessonId?: boolean
    groupId?: boolean
    createdAt?: boolean
  }

  export type LessonGroupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "lessonId" | "groupId" | "createdAt", ExtArgs["result"]["lessonGroup"]>
  export type LessonGroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }
  export type LessonGroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }
  export type LessonGroupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }

  export type $LessonGroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LessonGroup"
    objects: {
      lesson: Prisma.$LessonPayload<ExtArgs>
      group: Prisma.$GroupPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      lessonId: string
      groupId: string
      createdAt: Date
    }, ExtArgs["result"]["lessonGroup"]>
    composites: {}
  }

  type LessonGroupGetPayload<S extends boolean | null | undefined | LessonGroupDefaultArgs> = $Result.GetResult<Prisma.$LessonGroupPayload, S>

  type LessonGroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LessonGroupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LessonGroupCountAggregateInputType | true
    }

  export interface LessonGroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LessonGroup'], meta: { name: 'LessonGroup' } }
    /**
     * Find zero or one LessonGroup that matches the filter.
     * @param {LessonGroupFindUniqueArgs} args - Arguments to find a LessonGroup
     * @example
     * // Get one LessonGroup
     * const lessonGroup = await prisma.lessonGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LessonGroupFindUniqueArgs>(args: SelectSubset<T, LessonGroupFindUniqueArgs<ExtArgs>>): Prisma__LessonGroupClient<$Result.GetResult<Prisma.$LessonGroupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LessonGroup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LessonGroupFindUniqueOrThrowArgs} args - Arguments to find a LessonGroup
     * @example
     * // Get one LessonGroup
     * const lessonGroup = await prisma.lessonGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LessonGroupFindUniqueOrThrowArgs>(args: SelectSubset<T, LessonGroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LessonGroupClient<$Result.GetResult<Prisma.$LessonGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LessonGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonGroupFindFirstArgs} args - Arguments to find a LessonGroup
     * @example
     * // Get one LessonGroup
     * const lessonGroup = await prisma.lessonGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LessonGroupFindFirstArgs>(args?: SelectSubset<T, LessonGroupFindFirstArgs<ExtArgs>>): Prisma__LessonGroupClient<$Result.GetResult<Prisma.$LessonGroupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LessonGroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonGroupFindFirstOrThrowArgs} args - Arguments to find a LessonGroup
     * @example
     * // Get one LessonGroup
     * const lessonGroup = await prisma.lessonGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LessonGroupFindFirstOrThrowArgs>(args?: SelectSubset<T, LessonGroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__LessonGroupClient<$Result.GetResult<Prisma.$LessonGroupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LessonGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonGroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LessonGroups
     * const lessonGroups = await prisma.lessonGroup.findMany()
     * 
     * // Get first 10 LessonGroups
     * const lessonGroups = await prisma.lessonGroup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lessonGroupWithIdOnly = await prisma.lessonGroup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LessonGroupFindManyArgs>(args?: SelectSubset<T, LessonGroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LessonGroup.
     * @param {LessonGroupCreateArgs} args - Arguments to create a LessonGroup.
     * @example
     * // Create one LessonGroup
     * const LessonGroup = await prisma.lessonGroup.create({
     *   data: {
     *     // ... data to create a LessonGroup
     *   }
     * })
     * 
     */
    create<T extends LessonGroupCreateArgs>(args: SelectSubset<T, LessonGroupCreateArgs<ExtArgs>>): Prisma__LessonGroupClient<$Result.GetResult<Prisma.$LessonGroupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LessonGroups.
     * @param {LessonGroupCreateManyArgs} args - Arguments to create many LessonGroups.
     * @example
     * // Create many LessonGroups
     * const lessonGroup = await prisma.lessonGroup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LessonGroupCreateManyArgs>(args?: SelectSubset<T, LessonGroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LessonGroups and returns the data saved in the database.
     * @param {LessonGroupCreateManyAndReturnArgs} args - Arguments to create many LessonGroups.
     * @example
     * // Create many LessonGroups
     * const lessonGroup = await prisma.lessonGroup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LessonGroups and only return the `id`
     * const lessonGroupWithIdOnly = await prisma.lessonGroup.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LessonGroupCreateManyAndReturnArgs>(args?: SelectSubset<T, LessonGroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonGroupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LessonGroup.
     * @param {LessonGroupDeleteArgs} args - Arguments to delete one LessonGroup.
     * @example
     * // Delete one LessonGroup
     * const LessonGroup = await prisma.lessonGroup.delete({
     *   where: {
     *     // ... filter to delete one LessonGroup
     *   }
     * })
     * 
     */
    delete<T extends LessonGroupDeleteArgs>(args: SelectSubset<T, LessonGroupDeleteArgs<ExtArgs>>): Prisma__LessonGroupClient<$Result.GetResult<Prisma.$LessonGroupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LessonGroup.
     * @param {LessonGroupUpdateArgs} args - Arguments to update one LessonGroup.
     * @example
     * // Update one LessonGroup
     * const lessonGroup = await prisma.lessonGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LessonGroupUpdateArgs>(args: SelectSubset<T, LessonGroupUpdateArgs<ExtArgs>>): Prisma__LessonGroupClient<$Result.GetResult<Prisma.$LessonGroupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LessonGroups.
     * @param {LessonGroupDeleteManyArgs} args - Arguments to filter LessonGroups to delete.
     * @example
     * // Delete a few LessonGroups
     * const { count } = await prisma.lessonGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LessonGroupDeleteManyArgs>(args?: SelectSubset<T, LessonGroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LessonGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LessonGroups
     * const lessonGroup = await prisma.lessonGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LessonGroupUpdateManyArgs>(args: SelectSubset<T, LessonGroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LessonGroups and returns the data updated in the database.
     * @param {LessonGroupUpdateManyAndReturnArgs} args - Arguments to update many LessonGroups.
     * @example
     * // Update many LessonGroups
     * const lessonGroup = await prisma.lessonGroup.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LessonGroups and only return the `id`
     * const lessonGroupWithIdOnly = await prisma.lessonGroup.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LessonGroupUpdateManyAndReturnArgs>(args: SelectSubset<T, LessonGroupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonGroupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LessonGroup.
     * @param {LessonGroupUpsertArgs} args - Arguments to update or create a LessonGroup.
     * @example
     * // Update or create a LessonGroup
     * const lessonGroup = await prisma.lessonGroup.upsert({
     *   create: {
     *     // ... data to create a LessonGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LessonGroup we want to update
     *   }
     * })
     */
    upsert<T extends LessonGroupUpsertArgs>(args: SelectSubset<T, LessonGroupUpsertArgs<ExtArgs>>): Prisma__LessonGroupClient<$Result.GetResult<Prisma.$LessonGroupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LessonGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonGroupCountArgs} args - Arguments to filter LessonGroups to count.
     * @example
     * // Count the number of LessonGroups
     * const count = await prisma.lessonGroup.count({
     *   where: {
     *     // ... the filter for the LessonGroups we want to count
     *   }
     * })
    **/
    count<T extends LessonGroupCountArgs>(
      args?: Subset<T, LessonGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LessonGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LessonGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LessonGroupAggregateArgs>(args: Subset<T, LessonGroupAggregateArgs>): Prisma.PrismaPromise<GetLessonGroupAggregateType<T>>

    /**
     * Group by LessonGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LessonGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LessonGroupGroupByArgs['orderBy'] }
        : { orderBy?: LessonGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LessonGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLessonGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LessonGroup model
   */
  readonly fields: LessonGroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LessonGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LessonGroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lesson<T extends LessonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LessonDefaultArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    group<T extends GroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GroupDefaultArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LessonGroup model
   */
  interface LessonGroupFieldRefs {
    readonly id: FieldRef<"LessonGroup", 'String'>
    readonly lessonId: FieldRef<"LessonGroup", 'String'>
    readonly groupId: FieldRef<"LessonGroup", 'String'>
    readonly createdAt: FieldRef<"LessonGroup", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LessonGroup findUnique
   */
  export type LessonGroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonGroup
     */
    select?: LessonGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonGroup
     */
    omit?: LessonGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonGroupInclude<ExtArgs> | null
    /**
     * Filter, which LessonGroup to fetch.
     */
    where: LessonGroupWhereUniqueInput
  }

  /**
   * LessonGroup findUniqueOrThrow
   */
  export type LessonGroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonGroup
     */
    select?: LessonGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonGroup
     */
    omit?: LessonGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonGroupInclude<ExtArgs> | null
    /**
     * Filter, which LessonGroup to fetch.
     */
    where: LessonGroupWhereUniqueInput
  }

  /**
   * LessonGroup findFirst
   */
  export type LessonGroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonGroup
     */
    select?: LessonGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonGroup
     */
    omit?: LessonGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonGroupInclude<ExtArgs> | null
    /**
     * Filter, which LessonGroup to fetch.
     */
    where?: LessonGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonGroups to fetch.
     */
    orderBy?: LessonGroupOrderByWithRelationInput | LessonGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LessonGroups.
     */
    cursor?: LessonGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LessonGroups.
     */
    distinct?: LessonGroupScalarFieldEnum | LessonGroupScalarFieldEnum[]
  }

  /**
   * LessonGroup findFirstOrThrow
   */
  export type LessonGroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonGroup
     */
    select?: LessonGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonGroup
     */
    omit?: LessonGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonGroupInclude<ExtArgs> | null
    /**
     * Filter, which LessonGroup to fetch.
     */
    where?: LessonGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonGroups to fetch.
     */
    orderBy?: LessonGroupOrderByWithRelationInput | LessonGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LessonGroups.
     */
    cursor?: LessonGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LessonGroups.
     */
    distinct?: LessonGroupScalarFieldEnum | LessonGroupScalarFieldEnum[]
  }

  /**
   * LessonGroup findMany
   */
  export type LessonGroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonGroup
     */
    select?: LessonGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonGroup
     */
    omit?: LessonGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonGroupInclude<ExtArgs> | null
    /**
     * Filter, which LessonGroups to fetch.
     */
    where?: LessonGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonGroups to fetch.
     */
    orderBy?: LessonGroupOrderByWithRelationInput | LessonGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LessonGroups.
     */
    cursor?: LessonGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonGroups.
     */
    skip?: number
    distinct?: LessonGroupScalarFieldEnum | LessonGroupScalarFieldEnum[]
  }

  /**
   * LessonGroup create
   */
  export type LessonGroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonGroup
     */
    select?: LessonGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonGroup
     */
    omit?: LessonGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonGroupInclude<ExtArgs> | null
    /**
     * The data needed to create a LessonGroup.
     */
    data: XOR<LessonGroupCreateInput, LessonGroupUncheckedCreateInput>
  }

  /**
   * LessonGroup createMany
   */
  export type LessonGroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LessonGroups.
     */
    data: LessonGroupCreateManyInput | LessonGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LessonGroup createManyAndReturn
   */
  export type LessonGroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonGroup
     */
    select?: LessonGroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LessonGroup
     */
    omit?: LessonGroupOmit<ExtArgs> | null
    /**
     * The data used to create many LessonGroups.
     */
    data: LessonGroupCreateManyInput | LessonGroupCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonGroupIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LessonGroup update
   */
  export type LessonGroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonGroup
     */
    select?: LessonGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonGroup
     */
    omit?: LessonGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonGroupInclude<ExtArgs> | null
    /**
     * The data needed to update a LessonGroup.
     */
    data: XOR<LessonGroupUpdateInput, LessonGroupUncheckedUpdateInput>
    /**
     * Choose, which LessonGroup to update.
     */
    where: LessonGroupWhereUniqueInput
  }

  /**
   * LessonGroup updateMany
   */
  export type LessonGroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LessonGroups.
     */
    data: XOR<LessonGroupUpdateManyMutationInput, LessonGroupUncheckedUpdateManyInput>
    /**
     * Filter which LessonGroups to update
     */
    where?: LessonGroupWhereInput
    /**
     * Limit how many LessonGroups to update.
     */
    limit?: number
  }

  /**
   * LessonGroup updateManyAndReturn
   */
  export type LessonGroupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonGroup
     */
    select?: LessonGroupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LessonGroup
     */
    omit?: LessonGroupOmit<ExtArgs> | null
    /**
     * The data used to update LessonGroups.
     */
    data: XOR<LessonGroupUpdateManyMutationInput, LessonGroupUncheckedUpdateManyInput>
    /**
     * Filter which LessonGroups to update
     */
    where?: LessonGroupWhereInput
    /**
     * Limit how many LessonGroups to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonGroupIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LessonGroup upsert
   */
  export type LessonGroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonGroup
     */
    select?: LessonGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonGroup
     */
    omit?: LessonGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonGroupInclude<ExtArgs> | null
    /**
     * The filter to search for the LessonGroup to update in case it exists.
     */
    where: LessonGroupWhereUniqueInput
    /**
     * In case the LessonGroup found by the `where` argument doesn't exist, create a new LessonGroup with this data.
     */
    create: XOR<LessonGroupCreateInput, LessonGroupUncheckedCreateInput>
    /**
     * In case the LessonGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LessonGroupUpdateInput, LessonGroupUncheckedUpdateInput>
  }

  /**
   * LessonGroup delete
   */
  export type LessonGroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonGroup
     */
    select?: LessonGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonGroup
     */
    omit?: LessonGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonGroupInclude<ExtArgs> | null
    /**
     * Filter which LessonGroup to delete.
     */
    where: LessonGroupWhereUniqueInput
  }

  /**
   * LessonGroup deleteMany
   */
  export type LessonGroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LessonGroups to delete
     */
    where?: LessonGroupWhereInput
    /**
     * Limit how many LessonGroups to delete.
     */
    limit?: number
  }

  /**
   * LessonGroup without action
   */
  export type LessonGroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonGroup
     */
    select?: LessonGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonGroup
     */
    omit?: LessonGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonGroupInclude<ExtArgs> | null
  }


  /**
   * Model AIFilterConfig
   */

  export type AggregateAIFilterConfig = {
    _count: AIFilterConfigCountAggregateOutputType | null
    _min: AIFilterConfigMinAggregateOutputType | null
    _max: AIFilterConfigMaxAggregateOutputType | null
  }

  export type AIFilterConfigMinAggregateOutputType = {
    id: string | null
    organizationId: string | null
    redirectMessage: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AIFilterConfigMaxAggregateOutputType = {
    id: string | null
    organizationId: string | null
    redirectMessage: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AIFilterConfigCountAggregateOutputType = {
    id: number
    organizationId: number
    filterRules: number
    customKeywords: number
    redirectMessage: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AIFilterConfigMinAggregateInputType = {
    id?: true
    organizationId?: true
    redirectMessage?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AIFilterConfigMaxAggregateInputType = {
    id?: true
    organizationId?: true
    redirectMessage?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AIFilterConfigCountAggregateInputType = {
    id?: true
    organizationId?: true
    filterRules?: true
    customKeywords?: true
    redirectMessage?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AIFilterConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIFilterConfig to aggregate.
     */
    where?: AIFilterConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIFilterConfigs to fetch.
     */
    orderBy?: AIFilterConfigOrderByWithRelationInput | AIFilterConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AIFilterConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIFilterConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIFilterConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AIFilterConfigs
    **/
    _count?: true | AIFilterConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AIFilterConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AIFilterConfigMaxAggregateInputType
  }

  export type GetAIFilterConfigAggregateType<T extends AIFilterConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateAIFilterConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAIFilterConfig[P]>
      : GetScalarType<T[P], AggregateAIFilterConfig[P]>
  }




  export type AIFilterConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIFilterConfigWhereInput
    orderBy?: AIFilterConfigOrderByWithAggregationInput | AIFilterConfigOrderByWithAggregationInput[]
    by: AIFilterConfigScalarFieldEnum[] | AIFilterConfigScalarFieldEnum
    having?: AIFilterConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AIFilterConfigCountAggregateInputType | true
    _min?: AIFilterConfigMinAggregateInputType
    _max?: AIFilterConfigMaxAggregateInputType
  }

  export type AIFilterConfigGroupByOutputType = {
    id: string
    organizationId: string | null
    filterRules: JsonValue
    customKeywords: JsonValue | null
    redirectMessage: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: AIFilterConfigCountAggregateOutputType | null
    _min: AIFilterConfigMinAggregateOutputType | null
    _max: AIFilterConfigMaxAggregateOutputType | null
  }

  type GetAIFilterConfigGroupByPayload<T extends AIFilterConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AIFilterConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AIFilterConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AIFilterConfigGroupByOutputType[P]>
            : GetScalarType<T[P], AIFilterConfigGroupByOutputType[P]>
        }
      >
    >


  export type AIFilterConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    filterRules?: boolean
    customKeywords?: boolean
    redirectMessage?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | AIFilterConfig$organizationArgs<ExtArgs>
    metrics?: boolean | AIFilterConfig$metricsArgs<ExtArgs>
    _count?: boolean | AIFilterConfigCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIFilterConfig"]>

  export type AIFilterConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    filterRules?: boolean
    customKeywords?: boolean
    redirectMessage?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | AIFilterConfig$organizationArgs<ExtArgs>
  }, ExtArgs["result"]["aIFilterConfig"]>

  export type AIFilterConfigSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    filterRules?: boolean
    customKeywords?: boolean
    redirectMessage?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | AIFilterConfig$organizationArgs<ExtArgs>
  }, ExtArgs["result"]["aIFilterConfig"]>

  export type AIFilterConfigSelectScalar = {
    id?: boolean
    organizationId?: boolean
    filterRules?: boolean
    customKeywords?: boolean
    redirectMessage?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AIFilterConfigOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organizationId" | "filterRules" | "customKeywords" | "redirectMessage" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["aIFilterConfig"]>
  export type AIFilterConfigInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | AIFilterConfig$organizationArgs<ExtArgs>
    metrics?: boolean | AIFilterConfig$metricsArgs<ExtArgs>
    _count?: boolean | AIFilterConfigCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AIFilterConfigIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | AIFilterConfig$organizationArgs<ExtArgs>
  }
  export type AIFilterConfigIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | AIFilterConfig$organizationArgs<ExtArgs>
  }

  export type $AIFilterConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AIFilterConfig"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs> | null
      metrics: Prisma.$AIFilterMetricPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organizationId: string | null
      filterRules: Prisma.JsonValue
      customKeywords: Prisma.JsonValue | null
      redirectMessage: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["aIFilterConfig"]>
    composites: {}
  }

  type AIFilterConfigGetPayload<S extends boolean | null | undefined | AIFilterConfigDefaultArgs> = $Result.GetResult<Prisma.$AIFilterConfigPayload, S>

  type AIFilterConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AIFilterConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AIFilterConfigCountAggregateInputType | true
    }

  export interface AIFilterConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AIFilterConfig'], meta: { name: 'AIFilterConfig' } }
    /**
     * Find zero or one AIFilterConfig that matches the filter.
     * @param {AIFilterConfigFindUniqueArgs} args - Arguments to find a AIFilterConfig
     * @example
     * // Get one AIFilterConfig
     * const aIFilterConfig = await prisma.aIFilterConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AIFilterConfigFindUniqueArgs>(args: SelectSubset<T, AIFilterConfigFindUniqueArgs<ExtArgs>>): Prisma__AIFilterConfigClient<$Result.GetResult<Prisma.$AIFilterConfigPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AIFilterConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AIFilterConfigFindUniqueOrThrowArgs} args - Arguments to find a AIFilterConfig
     * @example
     * // Get one AIFilterConfig
     * const aIFilterConfig = await prisma.aIFilterConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AIFilterConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, AIFilterConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AIFilterConfigClient<$Result.GetResult<Prisma.$AIFilterConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIFilterConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIFilterConfigFindFirstArgs} args - Arguments to find a AIFilterConfig
     * @example
     * // Get one AIFilterConfig
     * const aIFilterConfig = await prisma.aIFilterConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AIFilterConfigFindFirstArgs>(args?: SelectSubset<T, AIFilterConfigFindFirstArgs<ExtArgs>>): Prisma__AIFilterConfigClient<$Result.GetResult<Prisma.$AIFilterConfigPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIFilterConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIFilterConfigFindFirstOrThrowArgs} args - Arguments to find a AIFilterConfig
     * @example
     * // Get one AIFilterConfig
     * const aIFilterConfig = await prisma.aIFilterConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AIFilterConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, AIFilterConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__AIFilterConfigClient<$Result.GetResult<Prisma.$AIFilterConfigPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AIFilterConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIFilterConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AIFilterConfigs
     * const aIFilterConfigs = await prisma.aIFilterConfig.findMany()
     * 
     * // Get first 10 AIFilterConfigs
     * const aIFilterConfigs = await prisma.aIFilterConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aIFilterConfigWithIdOnly = await prisma.aIFilterConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AIFilterConfigFindManyArgs>(args?: SelectSubset<T, AIFilterConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIFilterConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AIFilterConfig.
     * @param {AIFilterConfigCreateArgs} args - Arguments to create a AIFilterConfig.
     * @example
     * // Create one AIFilterConfig
     * const AIFilterConfig = await prisma.aIFilterConfig.create({
     *   data: {
     *     // ... data to create a AIFilterConfig
     *   }
     * })
     * 
     */
    create<T extends AIFilterConfigCreateArgs>(args: SelectSubset<T, AIFilterConfigCreateArgs<ExtArgs>>): Prisma__AIFilterConfigClient<$Result.GetResult<Prisma.$AIFilterConfigPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AIFilterConfigs.
     * @param {AIFilterConfigCreateManyArgs} args - Arguments to create many AIFilterConfigs.
     * @example
     * // Create many AIFilterConfigs
     * const aIFilterConfig = await prisma.aIFilterConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AIFilterConfigCreateManyArgs>(args?: SelectSubset<T, AIFilterConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AIFilterConfigs and returns the data saved in the database.
     * @param {AIFilterConfigCreateManyAndReturnArgs} args - Arguments to create many AIFilterConfigs.
     * @example
     * // Create many AIFilterConfigs
     * const aIFilterConfig = await prisma.aIFilterConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AIFilterConfigs and only return the `id`
     * const aIFilterConfigWithIdOnly = await prisma.aIFilterConfig.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AIFilterConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, AIFilterConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIFilterConfigPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AIFilterConfig.
     * @param {AIFilterConfigDeleteArgs} args - Arguments to delete one AIFilterConfig.
     * @example
     * // Delete one AIFilterConfig
     * const AIFilterConfig = await prisma.aIFilterConfig.delete({
     *   where: {
     *     // ... filter to delete one AIFilterConfig
     *   }
     * })
     * 
     */
    delete<T extends AIFilterConfigDeleteArgs>(args: SelectSubset<T, AIFilterConfigDeleteArgs<ExtArgs>>): Prisma__AIFilterConfigClient<$Result.GetResult<Prisma.$AIFilterConfigPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AIFilterConfig.
     * @param {AIFilterConfigUpdateArgs} args - Arguments to update one AIFilterConfig.
     * @example
     * // Update one AIFilterConfig
     * const aIFilterConfig = await prisma.aIFilterConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AIFilterConfigUpdateArgs>(args: SelectSubset<T, AIFilterConfigUpdateArgs<ExtArgs>>): Prisma__AIFilterConfigClient<$Result.GetResult<Prisma.$AIFilterConfigPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AIFilterConfigs.
     * @param {AIFilterConfigDeleteManyArgs} args - Arguments to filter AIFilterConfigs to delete.
     * @example
     * // Delete a few AIFilterConfigs
     * const { count } = await prisma.aIFilterConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AIFilterConfigDeleteManyArgs>(args?: SelectSubset<T, AIFilterConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIFilterConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIFilterConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AIFilterConfigs
     * const aIFilterConfig = await prisma.aIFilterConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AIFilterConfigUpdateManyArgs>(args: SelectSubset<T, AIFilterConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIFilterConfigs and returns the data updated in the database.
     * @param {AIFilterConfigUpdateManyAndReturnArgs} args - Arguments to update many AIFilterConfigs.
     * @example
     * // Update many AIFilterConfigs
     * const aIFilterConfig = await prisma.aIFilterConfig.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AIFilterConfigs and only return the `id`
     * const aIFilterConfigWithIdOnly = await prisma.aIFilterConfig.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AIFilterConfigUpdateManyAndReturnArgs>(args: SelectSubset<T, AIFilterConfigUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIFilterConfigPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AIFilterConfig.
     * @param {AIFilterConfigUpsertArgs} args - Arguments to update or create a AIFilterConfig.
     * @example
     * // Update or create a AIFilterConfig
     * const aIFilterConfig = await prisma.aIFilterConfig.upsert({
     *   create: {
     *     // ... data to create a AIFilterConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AIFilterConfig we want to update
     *   }
     * })
     */
    upsert<T extends AIFilterConfigUpsertArgs>(args: SelectSubset<T, AIFilterConfigUpsertArgs<ExtArgs>>): Prisma__AIFilterConfigClient<$Result.GetResult<Prisma.$AIFilterConfigPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AIFilterConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIFilterConfigCountArgs} args - Arguments to filter AIFilterConfigs to count.
     * @example
     * // Count the number of AIFilterConfigs
     * const count = await prisma.aIFilterConfig.count({
     *   where: {
     *     // ... the filter for the AIFilterConfigs we want to count
     *   }
     * })
    **/
    count<T extends AIFilterConfigCountArgs>(
      args?: Subset<T, AIFilterConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AIFilterConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AIFilterConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIFilterConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AIFilterConfigAggregateArgs>(args: Subset<T, AIFilterConfigAggregateArgs>): Prisma.PrismaPromise<GetAIFilterConfigAggregateType<T>>

    /**
     * Group by AIFilterConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIFilterConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AIFilterConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AIFilterConfigGroupByArgs['orderBy'] }
        : { orderBy?: AIFilterConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AIFilterConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAIFilterConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AIFilterConfig model
   */
  readonly fields: AIFilterConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AIFilterConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AIFilterConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends AIFilterConfig$organizationArgs<ExtArgs> = {}>(args?: Subset<T, AIFilterConfig$organizationArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    metrics<T extends AIFilterConfig$metricsArgs<ExtArgs> = {}>(args?: Subset<T, AIFilterConfig$metricsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIFilterMetricPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AIFilterConfig model
   */
  interface AIFilterConfigFieldRefs {
    readonly id: FieldRef<"AIFilterConfig", 'String'>
    readonly organizationId: FieldRef<"AIFilterConfig", 'String'>
    readonly filterRules: FieldRef<"AIFilterConfig", 'Json'>
    readonly customKeywords: FieldRef<"AIFilterConfig", 'Json'>
    readonly redirectMessage: FieldRef<"AIFilterConfig", 'String'>
    readonly isActive: FieldRef<"AIFilterConfig", 'Boolean'>
    readonly createdAt: FieldRef<"AIFilterConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"AIFilterConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AIFilterConfig findUnique
   */
  export type AIFilterConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIFilterConfig
     */
    select?: AIFilterConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIFilterConfig
     */
    omit?: AIFilterConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIFilterConfigInclude<ExtArgs> | null
    /**
     * Filter, which AIFilterConfig to fetch.
     */
    where: AIFilterConfigWhereUniqueInput
  }

  /**
   * AIFilterConfig findUniqueOrThrow
   */
  export type AIFilterConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIFilterConfig
     */
    select?: AIFilterConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIFilterConfig
     */
    omit?: AIFilterConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIFilterConfigInclude<ExtArgs> | null
    /**
     * Filter, which AIFilterConfig to fetch.
     */
    where: AIFilterConfigWhereUniqueInput
  }

  /**
   * AIFilterConfig findFirst
   */
  export type AIFilterConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIFilterConfig
     */
    select?: AIFilterConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIFilterConfig
     */
    omit?: AIFilterConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIFilterConfigInclude<ExtArgs> | null
    /**
     * Filter, which AIFilterConfig to fetch.
     */
    where?: AIFilterConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIFilterConfigs to fetch.
     */
    orderBy?: AIFilterConfigOrderByWithRelationInput | AIFilterConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIFilterConfigs.
     */
    cursor?: AIFilterConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIFilterConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIFilterConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIFilterConfigs.
     */
    distinct?: AIFilterConfigScalarFieldEnum | AIFilterConfigScalarFieldEnum[]
  }

  /**
   * AIFilterConfig findFirstOrThrow
   */
  export type AIFilterConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIFilterConfig
     */
    select?: AIFilterConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIFilterConfig
     */
    omit?: AIFilterConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIFilterConfigInclude<ExtArgs> | null
    /**
     * Filter, which AIFilterConfig to fetch.
     */
    where?: AIFilterConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIFilterConfigs to fetch.
     */
    orderBy?: AIFilterConfigOrderByWithRelationInput | AIFilterConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIFilterConfigs.
     */
    cursor?: AIFilterConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIFilterConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIFilterConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIFilterConfigs.
     */
    distinct?: AIFilterConfigScalarFieldEnum | AIFilterConfigScalarFieldEnum[]
  }

  /**
   * AIFilterConfig findMany
   */
  export type AIFilterConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIFilterConfig
     */
    select?: AIFilterConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIFilterConfig
     */
    omit?: AIFilterConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIFilterConfigInclude<ExtArgs> | null
    /**
     * Filter, which AIFilterConfigs to fetch.
     */
    where?: AIFilterConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIFilterConfigs to fetch.
     */
    orderBy?: AIFilterConfigOrderByWithRelationInput | AIFilterConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AIFilterConfigs.
     */
    cursor?: AIFilterConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIFilterConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIFilterConfigs.
     */
    skip?: number
    distinct?: AIFilterConfigScalarFieldEnum | AIFilterConfigScalarFieldEnum[]
  }

  /**
   * AIFilterConfig create
   */
  export type AIFilterConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIFilterConfig
     */
    select?: AIFilterConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIFilterConfig
     */
    omit?: AIFilterConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIFilterConfigInclude<ExtArgs> | null
    /**
     * The data needed to create a AIFilterConfig.
     */
    data: XOR<AIFilterConfigCreateInput, AIFilterConfigUncheckedCreateInput>
  }

  /**
   * AIFilterConfig createMany
   */
  export type AIFilterConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AIFilterConfigs.
     */
    data: AIFilterConfigCreateManyInput | AIFilterConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIFilterConfig createManyAndReturn
   */
  export type AIFilterConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIFilterConfig
     */
    select?: AIFilterConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIFilterConfig
     */
    omit?: AIFilterConfigOmit<ExtArgs> | null
    /**
     * The data used to create many AIFilterConfigs.
     */
    data: AIFilterConfigCreateManyInput | AIFilterConfigCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIFilterConfigIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIFilterConfig update
   */
  export type AIFilterConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIFilterConfig
     */
    select?: AIFilterConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIFilterConfig
     */
    omit?: AIFilterConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIFilterConfigInclude<ExtArgs> | null
    /**
     * The data needed to update a AIFilterConfig.
     */
    data: XOR<AIFilterConfigUpdateInput, AIFilterConfigUncheckedUpdateInput>
    /**
     * Choose, which AIFilterConfig to update.
     */
    where: AIFilterConfigWhereUniqueInput
  }

  /**
   * AIFilterConfig updateMany
   */
  export type AIFilterConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AIFilterConfigs.
     */
    data: XOR<AIFilterConfigUpdateManyMutationInput, AIFilterConfigUncheckedUpdateManyInput>
    /**
     * Filter which AIFilterConfigs to update
     */
    where?: AIFilterConfigWhereInput
    /**
     * Limit how many AIFilterConfigs to update.
     */
    limit?: number
  }

  /**
   * AIFilterConfig updateManyAndReturn
   */
  export type AIFilterConfigUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIFilterConfig
     */
    select?: AIFilterConfigSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIFilterConfig
     */
    omit?: AIFilterConfigOmit<ExtArgs> | null
    /**
     * The data used to update AIFilterConfigs.
     */
    data: XOR<AIFilterConfigUpdateManyMutationInput, AIFilterConfigUncheckedUpdateManyInput>
    /**
     * Filter which AIFilterConfigs to update
     */
    where?: AIFilterConfigWhereInput
    /**
     * Limit how many AIFilterConfigs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIFilterConfigIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIFilterConfig upsert
   */
  export type AIFilterConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIFilterConfig
     */
    select?: AIFilterConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIFilterConfig
     */
    omit?: AIFilterConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIFilterConfigInclude<ExtArgs> | null
    /**
     * The filter to search for the AIFilterConfig to update in case it exists.
     */
    where: AIFilterConfigWhereUniqueInput
    /**
     * In case the AIFilterConfig found by the `where` argument doesn't exist, create a new AIFilterConfig with this data.
     */
    create: XOR<AIFilterConfigCreateInput, AIFilterConfigUncheckedCreateInput>
    /**
     * In case the AIFilterConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AIFilterConfigUpdateInput, AIFilterConfigUncheckedUpdateInput>
  }

  /**
   * AIFilterConfig delete
   */
  export type AIFilterConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIFilterConfig
     */
    select?: AIFilterConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIFilterConfig
     */
    omit?: AIFilterConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIFilterConfigInclude<ExtArgs> | null
    /**
     * Filter which AIFilterConfig to delete.
     */
    where: AIFilterConfigWhereUniqueInput
  }

  /**
   * AIFilterConfig deleteMany
   */
  export type AIFilterConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIFilterConfigs to delete
     */
    where?: AIFilterConfigWhereInput
    /**
     * Limit how many AIFilterConfigs to delete.
     */
    limit?: number
  }

  /**
   * AIFilterConfig.organization
   */
  export type AIFilterConfig$organizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    where?: OrganizationWhereInput
  }

  /**
   * AIFilterConfig.metrics
   */
  export type AIFilterConfig$metricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIFilterMetric
     */
    select?: AIFilterMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIFilterMetric
     */
    omit?: AIFilterMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIFilterMetricInclude<ExtArgs> | null
    where?: AIFilterMetricWhereInput
    orderBy?: AIFilterMetricOrderByWithRelationInput | AIFilterMetricOrderByWithRelationInput[]
    cursor?: AIFilterMetricWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AIFilterMetricScalarFieldEnum | AIFilterMetricScalarFieldEnum[]
  }

  /**
   * AIFilterConfig without action
   */
  export type AIFilterConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIFilterConfig
     */
    select?: AIFilterConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIFilterConfig
     */
    omit?: AIFilterConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIFilterConfigInclude<ExtArgs> | null
  }


  /**
   * Model AIFilterMetric
   */

  export type AggregateAIFilterMetric = {
    _count: AIFilterMetricCountAggregateOutputType | null
    _min: AIFilterMetricMinAggregateOutputType | null
    _max: AIFilterMetricMaxAggregateOutputType | null
  }

  export type AIFilterMetricMinAggregateOutputType = {
    id: string | null
    filterId: string | null
    organizationId: string | null
    query: string | null
    detectedCategory: $Enums.FilterCategory | null
    actionTaken: $Enums.FilterAction | null
    userId: string | null
    groupId: string | null
    featureName: string | null
    leaderNotified: boolean | null
    leaderResponse: string | null
    resolvedAt: Date | null
    createdAt: Date | null
  }

  export type AIFilterMetricMaxAggregateOutputType = {
    id: string | null
    filterId: string | null
    organizationId: string | null
    query: string | null
    detectedCategory: $Enums.FilterCategory | null
    actionTaken: $Enums.FilterAction | null
    userId: string | null
    groupId: string | null
    featureName: string | null
    leaderNotified: boolean | null
    leaderResponse: string | null
    resolvedAt: Date | null
    createdAt: Date | null
  }

  export type AIFilterMetricCountAggregateOutputType = {
    id: number
    filterId: number
    organizationId: number
    query: number
    detectedCategory: number
    actionTaken: number
    userId: number
    groupId: number
    featureName: number
    leaderNotified: number
    leaderResponse: number
    resolvedAt: number
    createdAt: number
    _all: number
  }


  export type AIFilterMetricMinAggregateInputType = {
    id?: true
    filterId?: true
    organizationId?: true
    query?: true
    detectedCategory?: true
    actionTaken?: true
    userId?: true
    groupId?: true
    featureName?: true
    leaderNotified?: true
    leaderResponse?: true
    resolvedAt?: true
    createdAt?: true
  }

  export type AIFilterMetricMaxAggregateInputType = {
    id?: true
    filterId?: true
    organizationId?: true
    query?: true
    detectedCategory?: true
    actionTaken?: true
    userId?: true
    groupId?: true
    featureName?: true
    leaderNotified?: true
    leaderResponse?: true
    resolvedAt?: true
    createdAt?: true
  }

  export type AIFilterMetricCountAggregateInputType = {
    id?: true
    filterId?: true
    organizationId?: true
    query?: true
    detectedCategory?: true
    actionTaken?: true
    userId?: true
    groupId?: true
    featureName?: true
    leaderNotified?: true
    leaderResponse?: true
    resolvedAt?: true
    createdAt?: true
    _all?: true
  }

  export type AIFilterMetricAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIFilterMetric to aggregate.
     */
    where?: AIFilterMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIFilterMetrics to fetch.
     */
    orderBy?: AIFilterMetricOrderByWithRelationInput | AIFilterMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AIFilterMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIFilterMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIFilterMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AIFilterMetrics
    **/
    _count?: true | AIFilterMetricCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AIFilterMetricMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AIFilterMetricMaxAggregateInputType
  }

  export type GetAIFilterMetricAggregateType<T extends AIFilterMetricAggregateArgs> = {
        [P in keyof T & keyof AggregateAIFilterMetric]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAIFilterMetric[P]>
      : GetScalarType<T[P], AggregateAIFilterMetric[P]>
  }




  export type AIFilterMetricGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIFilterMetricWhereInput
    orderBy?: AIFilterMetricOrderByWithAggregationInput | AIFilterMetricOrderByWithAggregationInput[]
    by: AIFilterMetricScalarFieldEnum[] | AIFilterMetricScalarFieldEnum
    having?: AIFilterMetricScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AIFilterMetricCountAggregateInputType | true
    _min?: AIFilterMetricMinAggregateInputType
    _max?: AIFilterMetricMaxAggregateInputType
  }

  export type AIFilterMetricGroupByOutputType = {
    id: string
    filterId: string
    organizationId: string | null
    query: string
    detectedCategory: $Enums.FilterCategory
    actionTaken: $Enums.FilterAction
    userId: string | null
    groupId: string | null
    featureName: string | null
    leaderNotified: boolean
    leaderResponse: string | null
    resolvedAt: Date | null
    createdAt: Date
    _count: AIFilterMetricCountAggregateOutputType | null
    _min: AIFilterMetricMinAggregateOutputType | null
    _max: AIFilterMetricMaxAggregateOutputType | null
  }

  type GetAIFilterMetricGroupByPayload<T extends AIFilterMetricGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AIFilterMetricGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AIFilterMetricGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AIFilterMetricGroupByOutputType[P]>
            : GetScalarType<T[P], AIFilterMetricGroupByOutputType[P]>
        }
      >
    >


  export type AIFilterMetricSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filterId?: boolean
    organizationId?: boolean
    query?: boolean
    detectedCategory?: boolean
    actionTaken?: boolean
    userId?: boolean
    groupId?: boolean
    featureName?: boolean
    leaderNotified?: boolean
    leaderResponse?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
    filter?: boolean | AIFilterConfigDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIFilterMetric"]>

  export type AIFilterMetricSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filterId?: boolean
    organizationId?: boolean
    query?: boolean
    detectedCategory?: boolean
    actionTaken?: boolean
    userId?: boolean
    groupId?: boolean
    featureName?: boolean
    leaderNotified?: boolean
    leaderResponse?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
    filter?: boolean | AIFilterConfigDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIFilterMetric"]>

  export type AIFilterMetricSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filterId?: boolean
    organizationId?: boolean
    query?: boolean
    detectedCategory?: boolean
    actionTaken?: boolean
    userId?: boolean
    groupId?: boolean
    featureName?: boolean
    leaderNotified?: boolean
    leaderResponse?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
    filter?: boolean | AIFilterConfigDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIFilterMetric"]>

  export type AIFilterMetricSelectScalar = {
    id?: boolean
    filterId?: boolean
    organizationId?: boolean
    query?: boolean
    detectedCategory?: boolean
    actionTaken?: boolean
    userId?: boolean
    groupId?: boolean
    featureName?: boolean
    leaderNotified?: boolean
    leaderResponse?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
  }

  export type AIFilterMetricOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "filterId" | "organizationId" | "query" | "detectedCategory" | "actionTaken" | "userId" | "groupId" | "featureName" | "leaderNotified" | "leaderResponse" | "resolvedAt" | "createdAt", ExtArgs["result"]["aIFilterMetric"]>
  export type AIFilterMetricInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    filter?: boolean | AIFilterConfigDefaultArgs<ExtArgs>
  }
  export type AIFilterMetricIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    filter?: boolean | AIFilterConfigDefaultArgs<ExtArgs>
  }
  export type AIFilterMetricIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    filter?: boolean | AIFilterConfigDefaultArgs<ExtArgs>
  }

  export type $AIFilterMetricPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AIFilterMetric"
    objects: {
      filter: Prisma.$AIFilterConfigPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      filterId: string
      organizationId: string | null
      query: string
      detectedCategory: $Enums.FilterCategory
      actionTaken: $Enums.FilterAction
      userId: string | null
      groupId: string | null
      featureName: string | null
      leaderNotified: boolean
      leaderResponse: string | null
      resolvedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["aIFilterMetric"]>
    composites: {}
  }

  type AIFilterMetricGetPayload<S extends boolean | null | undefined | AIFilterMetricDefaultArgs> = $Result.GetResult<Prisma.$AIFilterMetricPayload, S>

  type AIFilterMetricCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AIFilterMetricFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AIFilterMetricCountAggregateInputType | true
    }

  export interface AIFilterMetricDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AIFilterMetric'], meta: { name: 'AIFilterMetric' } }
    /**
     * Find zero or one AIFilterMetric that matches the filter.
     * @param {AIFilterMetricFindUniqueArgs} args - Arguments to find a AIFilterMetric
     * @example
     * // Get one AIFilterMetric
     * const aIFilterMetric = await prisma.aIFilterMetric.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AIFilterMetricFindUniqueArgs>(args: SelectSubset<T, AIFilterMetricFindUniqueArgs<ExtArgs>>): Prisma__AIFilterMetricClient<$Result.GetResult<Prisma.$AIFilterMetricPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AIFilterMetric that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AIFilterMetricFindUniqueOrThrowArgs} args - Arguments to find a AIFilterMetric
     * @example
     * // Get one AIFilterMetric
     * const aIFilterMetric = await prisma.aIFilterMetric.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AIFilterMetricFindUniqueOrThrowArgs>(args: SelectSubset<T, AIFilterMetricFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AIFilterMetricClient<$Result.GetResult<Prisma.$AIFilterMetricPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIFilterMetric that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIFilterMetricFindFirstArgs} args - Arguments to find a AIFilterMetric
     * @example
     * // Get one AIFilterMetric
     * const aIFilterMetric = await prisma.aIFilterMetric.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AIFilterMetricFindFirstArgs>(args?: SelectSubset<T, AIFilterMetricFindFirstArgs<ExtArgs>>): Prisma__AIFilterMetricClient<$Result.GetResult<Prisma.$AIFilterMetricPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIFilterMetric that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIFilterMetricFindFirstOrThrowArgs} args - Arguments to find a AIFilterMetric
     * @example
     * // Get one AIFilterMetric
     * const aIFilterMetric = await prisma.aIFilterMetric.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AIFilterMetricFindFirstOrThrowArgs>(args?: SelectSubset<T, AIFilterMetricFindFirstOrThrowArgs<ExtArgs>>): Prisma__AIFilterMetricClient<$Result.GetResult<Prisma.$AIFilterMetricPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AIFilterMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIFilterMetricFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AIFilterMetrics
     * const aIFilterMetrics = await prisma.aIFilterMetric.findMany()
     * 
     * // Get first 10 AIFilterMetrics
     * const aIFilterMetrics = await prisma.aIFilterMetric.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aIFilterMetricWithIdOnly = await prisma.aIFilterMetric.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AIFilterMetricFindManyArgs>(args?: SelectSubset<T, AIFilterMetricFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIFilterMetricPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AIFilterMetric.
     * @param {AIFilterMetricCreateArgs} args - Arguments to create a AIFilterMetric.
     * @example
     * // Create one AIFilterMetric
     * const AIFilterMetric = await prisma.aIFilterMetric.create({
     *   data: {
     *     // ... data to create a AIFilterMetric
     *   }
     * })
     * 
     */
    create<T extends AIFilterMetricCreateArgs>(args: SelectSubset<T, AIFilterMetricCreateArgs<ExtArgs>>): Prisma__AIFilterMetricClient<$Result.GetResult<Prisma.$AIFilterMetricPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AIFilterMetrics.
     * @param {AIFilterMetricCreateManyArgs} args - Arguments to create many AIFilterMetrics.
     * @example
     * // Create many AIFilterMetrics
     * const aIFilterMetric = await prisma.aIFilterMetric.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AIFilterMetricCreateManyArgs>(args?: SelectSubset<T, AIFilterMetricCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AIFilterMetrics and returns the data saved in the database.
     * @param {AIFilterMetricCreateManyAndReturnArgs} args - Arguments to create many AIFilterMetrics.
     * @example
     * // Create many AIFilterMetrics
     * const aIFilterMetric = await prisma.aIFilterMetric.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AIFilterMetrics and only return the `id`
     * const aIFilterMetricWithIdOnly = await prisma.aIFilterMetric.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AIFilterMetricCreateManyAndReturnArgs>(args?: SelectSubset<T, AIFilterMetricCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIFilterMetricPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AIFilterMetric.
     * @param {AIFilterMetricDeleteArgs} args - Arguments to delete one AIFilterMetric.
     * @example
     * // Delete one AIFilterMetric
     * const AIFilterMetric = await prisma.aIFilterMetric.delete({
     *   where: {
     *     // ... filter to delete one AIFilterMetric
     *   }
     * })
     * 
     */
    delete<T extends AIFilterMetricDeleteArgs>(args: SelectSubset<T, AIFilterMetricDeleteArgs<ExtArgs>>): Prisma__AIFilterMetricClient<$Result.GetResult<Prisma.$AIFilterMetricPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AIFilterMetric.
     * @param {AIFilterMetricUpdateArgs} args - Arguments to update one AIFilterMetric.
     * @example
     * // Update one AIFilterMetric
     * const aIFilterMetric = await prisma.aIFilterMetric.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AIFilterMetricUpdateArgs>(args: SelectSubset<T, AIFilterMetricUpdateArgs<ExtArgs>>): Prisma__AIFilterMetricClient<$Result.GetResult<Prisma.$AIFilterMetricPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AIFilterMetrics.
     * @param {AIFilterMetricDeleteManyArgs} args - Arguments to filter AIFilterMetrics to delete.
     * @example
     * // Delete a few AIFilterMetrics
     * const { count } = await prisma.aIFilterMetric.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AIFilterMetricDeleteManyArgs>(args?: SelectSubset<T, AIFilterMetricDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIFilterMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIFilterMetricUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AIFilterMetrics
     * const aIFilterMetric = await prisma.aIFilterMetric.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AIFilterMetricUpdateManyArgs>(args: SelectSubset<T, AIFilterMetricUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIFilterMetrics and returns the data updated in the database.
     * @param {AIFilterMetricUpdateManyAndReturnArgs} args - Arguments to update many AIFilterMetrics.
     * @example
     * // Update many AIFilterMetrics
     * const aIFilterMetric = await prisma.aIFilterMetric.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AIFilterMetrics and only return the `id`
     * const aIFilterMetricWithIdOnly = await prisma.aIFilterMetric.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AIFilterMetricUpdateManyAndReturnArgs>(args: SelectSubset<T, AIFilterMetricUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIFilterMetricPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AIFilterMetric.
     * @param {AIFilterMetricUpsertArgs} args - Arguments to update or create a AIFilterMetric.
     * @example
     * // Update or create a AIFilterMetric
     * const aIFilterMetric = await prisma.aIFilterMetric.upsert({
     *   create: {
     *     // ... data to create a AIFilterMetric
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AIFilterMetric we want to update
     *   }
     * })
     */
    upsert<T extends AIFilterMetricUpsertArgs>(args: SelectSubset<T, AIFilterMetricUpsertArgs<ExtArgs>>): Prisma__AIFilterMetricClient<$Result.GetResult<Prisma.$AIFilterMetricPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AIFilterMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIFilterMetricCountArgs} args - Arguments to filter AIFilterMetrics to count.
     * @example
     * // Count the number of AIFilterMetrics
     * const count = await prisma.aIFilterMetric.count({
     *   where: {
     *     // ... the filter for the AIFilterMetrics we want to count
     *   }
     * })
    **/
    count<T extends AIFilterMetricCountArgs>(
      args?: Subset<T, AIFilterMetricCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AIFilterMetricCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AIFilterMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIFilterMetricAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AIFilterMetricAggregateArgs>(args: Subset<T, AIFilterMetricAggregateArgs>): Prisma.PrismaPromise<GetAIFilterMetricAggregateType<T>>

    /**
     * Group by AIFilterMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIFilterMetricGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AIFilterMetricGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AIFilterMetricGroupByArgs['orderBy'] }
        : { orderBy?: AIFilterMetricGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AIFilterMetricGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAIFilterMetricGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AIFilterMetric model
   */
  readonly fields: AIFilterMetricFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AIFilterMetric.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AIFilterMetricClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    filter<T extends AIFilterConfigDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AIFilterConfigDefaultArgs<ExtArgs>>): Prisma__AIFilterConfigClient<$Result.GetResult<Prisma.$AIFilterConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AIFilterMetric model
   */
  interface AIFilterMetricFieldRefs {
    readonly id: FieldRef<"AIFilterMetric", 'String'>
    readonly filterId: FieldRef<"AIFilterMetric", 'String'>
    readonly organizationId: FieldRef<"AIFilterMetric", 'String'>
    readonly query: FieldRef<"AIFilterMetric", 'String'>
    readonly detectedCategory: FieldRef<"AIFilterMetric", 'FilterCategory'>
    readonly actionTaken: FieldRef<"AIFilterMetric", 'FilterAction'>
    readonly userId: FieldRef<"AIFilterMetric", 'String'>
    readonly groupId: FieldRef<"AIFilterMetric", 'String'>
    readonly featureName: FieldRef<"AIFilterMetric", 'String'>
    readonly leaderNotified: FieldRef<"AIFilterMetric", 'Boolean'>
    readonly leaderResponse: FieldRef<"AIFilterMetric", 'String'>
    readonly resolvedAt: FieldRef<"AIFilterMetric", 'DateTime'>
    readonly createdAt: FieldRef<"AIFilterMetric", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AIFilterMetric findUnique
   */
  export type AIFilterMetricFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIFilterMetric
     */
    select?: AIFilterMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIFilterMetric
     */
    omit?: AIFilterMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIFilterMetricInclude<ExtArgs> | null
    /**
     * Filter, which AIFilterMetric to fetch.
     */
    where: AIFilterMetricWhereUniqueInput
  }

  /**
   * AIFilterMetric findUniqueOrThrow
   */
  export type AIFilterMetricFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIFilterMetric
     */
    select?: AIFilterMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIFilterMetric
     */
    omit?: AIFilterMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIFilterMetricInclude<ExtArgs> | null
    /**
     * Filter, which AIFilterMetric to fetch.
     */
    where: AIFilterMetricWhereUniqueInput
  }

  /**
   * AIFilterMetric findFirst
   */
  export type AIFilterMetricFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIFilterMetric
     */
    select?: AIFilterMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIFilterMetric
     */
    omit?: AIFilterMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIFilterMetricInclude<ExtArgs> | null
    /**
     * Filter, which AIFilterMetric to fetch.
     */
    where?: AIFilterMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIFilterMetrics to fetch.
     */
    orderBy?: AIFilterMetricOrderByWithRelationInput | AIFilterMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIFilterMetrics.
     */
    cursor?: AIFilterMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIFilterMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIFilterMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIFilterMetrics.
     */
    distinct?: AIFilterMetricScalarFieldEnum | AIFilterMetricScalarFieldEnum[]
  }

  /**
   * AIFilterMetric findFirstOrThrow
   */
  export type AIFilterMetricFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIFilterMetric
     */
    select?: AIFilterMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIFilterMetric
     */
    omit?: AIFilterMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIFilterMetricInclude<ExtArgs> | null
    /**
     * Filter, which AIFilterMetric to fetch.
     */
    where?: AIFilterMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIFilterMetrics to fetch.
     */
    orderBy?: AIFilterMetricOrderByWithRelationInput | AIFilterMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIFilterMetrics.
     */
    cursor?: AIFilterMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIFilterMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIFilterMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIFilterMetrics.
     */
    distinct?: AIFilterMetricScalarFieldEnum | AIFilterMetricScalarFieldEnum[]
  }

  /**
   * AIFilterMetric findMany
   */
  export type AIFilterMetricFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIFilterMetric
     */
    select?: AIFilterMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIFilterMetric
     */
    omit?: AIFilterMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIFilterMetricInclude<ExtArgs> | null
    /**
     * Filter, which AIFilterMetrics to fetch.
     */
    where?: AIFilterMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIFilterMetrics to fetch.
     */
    orderBy?: AIFilterMetricOrderByWithRelationInput | AIFilterMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AIFilterMetrics.
     */
    cursor?: AIFilterMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIFilterMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIFilterMetrics.
     */
    skip?: number
    distinct?: AIFilterMetricScalarFieldEnum | AIFilterMetricScalarFieldEnum[]
  }

  /**
   * AIFilterMetric create
   */
  export type AIFilterMetricCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIFilterMetric
     */
    select?: AIFilterMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIFilterMetric
     */
    omit?: AIFilterMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIFilterMetricInclude<ExtArgs> | null
    /**
     * The data needed to create a AIFilterMetric.
     */
    data: XOR<AIFilterMetricCreateInput, AIFilterMetricUncheckedCreateInput>
  }

  /**
   * AIFilterMetric createMany
   */
  export type AIFilterMetricCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AIFilterMetrics.
     */
    data: AIFilterMetricCreateManyInput | AIFilterMetricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIFilterMetric createManyAndReturn
   */
  export type AIFilterMetricCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIFilterMetric
     */
    select?: AIFilterMetricSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIFilterMetric
     */
    omit?: AIFilterMetricOmit<ExtArgs> | null
    /**
     * The data used to create many AIFilterMetrics.
     */
    data: AIFilterMetricCreateManyInput | AIFilterMetricCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIFilterMetricIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIFilterMetric update
   */
  export type AIFilterMetricUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIFilterMetric
     */
    select?: AIFilterMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIFilterMetric
     */
    omit?: AIFilterMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIFilterMetricInclude<ExtArgs> | null
    /**
     * The data needed to update a AIFilterMetric.
     */
    data: XOR<AIFilterMetricUpdateInput, AIFilterMetricUncheckedUpdateInput>
    /**
     * Choose, which AIFilterMetric to update.
     */
    where: AIFilterMetricWhereUniqueInput
  }

  /**
   * AIFilterMetric updateMany
   */
  export type AIFilterMetricUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AIFilterMetrics.
     */
    data: XOR<AIFilterMetricUpdateManyMutationInput, AIFilterMetricUncheckedUpdateManyInput>
    /**
     * Filter which AIFilterMetrics to update
     */
    where?: AIFilterMetricWhereInput
    /**
     * Limit how many AIFilterMetrics to update.
     */
    limit?: number
  }

  /**
   * AIFilterMetric updateManyAndReturn
   */
  export type AIFilterMetricUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIFilterMetric
     */
    select?: AIFilterMetricSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIFilterMetric
     */
    omit?: AIFilterMetricOmit<ExtArgs> | null
    /**
     * The data used to update AIFilterMetrics.
     */
    data: XOR<AIFilterMetricUpdateManyMutationInput, AIFilterMetricUncheckedUpdateManyInput>
    /**
     * Filter which AIFilterMetrics to update
     */
    where?: AIFilterMetricWhereInput
    /**
     * Limit how many AIFilterMetrics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIFilterMetricIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIFilterMetric upsert
   */
  export type AIFilterMetricUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIFilterMetric
     */
    select?: AIFilterMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIFilterMetric
     */
    omit?: AIFilterMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIFilterMetricInclude<ExtArgs> | null
    /**
     * The filter to search for the AIFilterMetric to update in case it exists.
     */
    where: AIFilterMetricWhereUniqueInput
    /**
     * In case the AIFilterMetric found by the `where` argument doesn't exist, create a new AIFilterMetric with this data.
     */
    create: XOR<AIFilterMetricCreateInput, AIFilterMetricUncheckedCreateInput>
    /**
     * In case the AIFilterMetric was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AIFilterMetricUpdateInput, AIFilterMetricUncheckedUpdateInput>
  }

  /**
   * AIFilterMetric delete
   */
  export type AIFilterMetricDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIFilterMetric
     */
    select?: AIFilterMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIFilterMetric
     */
    omit?: AIFilterMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIFilterMetricInclude<ExtArgs> | null
    /**
     * Filter which AIFilterMetric to delete.
     */
    where: AIFilterMetricWhereUniqueInput
  }

  /**
   * AIFilterMetric deleteMany
   */
  export type AIFilterMetricDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIFilterMetrics to delete
     */
    where?: AIFilterMetricWhereInput
    /**
     * Limit how many AIFilterMetrics to delete.
     */
    limit?: number
  }

  /**
   * AIFilterMetric without action
   */
  export type AIFilterMetricDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIFilterMetric
     */
    select?: AIFilterMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIFilterMetric
     */
    omit?: AIFilterMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIFilterMetricInclude<ExtArgs> | null
  }


  /**
   * Model ComparativeTheme
   */

  export type AggregateComparativeTheme = {
    _count: ComparativeThemeCountAggregateOutputType | null
    _min: ComparativeThemeMinAggregateOutputType | null
    _max: ComparativeThemeMaxAggregateOutputType | null
  }

  export type ComparativeThemeMinAggregateOutputType = {
    id: string | null
    organizationId: string | null
    themeName: string | null
    description: string | null
    category: string | null
    isPublic: boolean | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ComparativeThemeMaxAggregateOutputType = {
    id: string | null
    organizationId: string | null
    themeName: string | null
    description: string | null
    category: string | null
    isPublic: boolean | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ComparativeThemeCountAggregateOutputType = {
    id: number
    organizationId: number
    themeName: number
    description: number
    category: number
    otPassages: number
    ntPassages: number
    themeNotes: number
    isPublic: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ComparativeThemeMinAggregateInputType = {
    id?: true
    organizationId?: true
    themeName?: true
    description?: true
    category?: true
    isPublic?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ComparativeThemeMaxAggregateInputType = {
    id?: true
    organizationId?: true
    themeName?: true
    description?: true
    category?: true
    isPublic?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ComparativeThemeCountAggregateInputType = {
    id?: true
    organizationId?: true
    themeName?: true
    description?: true
    category?: true
    otPassages?: true
    ntPassages?: true
    themeNotes?: true
    isPublic?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ComparativeThemeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComparativeTheme to aggregate.
     */
    where?: ComparativeThemeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComparativeThemes to fetch.
     */
    orderBy?: ComparativeThemeOrderByWithRelationInput | ComparativeThemeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComparativeThemeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComparativeThemes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComparativeThemes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ComparativeThemes
    **/
    _count?: true | ComparativeThemeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComparativeThemeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComparativeThemeMaxAggregateInputType
  }

  export type GetComparativeThemeAggregateType<T extends ComparativeThemeAggregateArgs> = {
        [P in keyof T & keyof AggregateComparativeTheme]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComparativeTheme[P]>
      : GetScalarType<T[P], AggregateComparativeTheme[P]>
  }




  export type ComparativeThemeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComparativeThemeWhereInput
    orderBy?: ComparativeThemeOrderByWithAggregationInput | ComparativeThemeOrderByWithAggregationInput[]
    by: ComparativeThemeScalarFieldEnum[] | ComparativeThemeScalarFieldEnum
    having?: ComparativeThemeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComparativeThemeCountAggregateInputType | true
    _min?: ComparativeThemeMinAggregateInputType
    _max?: ComparativeThemeMaxAggregateInputType
  }

  export type ComparativeThemeGroupByOutputType = {
    id: string
    organizationId: string
    themeName: string
    description: string | null
    category: string | null
    otPassages: JsonValue
    ntPassages: JsonValue
    themeNotes: JsonValue | null
    isPublic: boolean
    createdBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: ComparativeThemeCountAggregateOutputType | null
    _min: ComparativeThemeMinAggregateOutputType | null
    _max: ComparativeThemeMaxAggregateOutputType | null
  }

  type GetComparativeThemeGroupByPayload<T extends ComparativeThemeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComparativeThemeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComparativeThemeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComparativeThemeGroupByOutputType[P]>
            : GetScalarType<T[P], ComparativeThemeGroupByOutputType[P]>
        }
      >
    >


  export type ComparativeThemeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    themeName?: boolean
    description?: boolean
    category?: boolean
    otPassages?: boolean
    ntPassages?: boolean
    themeNotes?: boolean
    isPublic?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    metrics?: boolean | ComparativeTheme$metricsArgs<ExtArgs>
    _count?: boolean | ComparativeThemeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comparativeTheme"]>

  export type ComparativeThemeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    themeName?: boolean
    description?: boolean
    category?: boolean
    otPassages?: boolean
    ntPassages?: boolean
    themeNotes?: boolean
    isPublic?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comparativeTheme"]>

  export type ComparativeThemeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    themeName?: boolean
    description?: boolean
    category?: boolean
    otPassages?: boolean
    ntPassages?: boolean
    themeNotes?: boolean
    isPublic?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comparativeTheme"]>

  export type ComparativeThemeSelectScalar = {
    id?: boolean
    organizationId?: boolean
    themeName?: boolean
    description?: boolean
    category?: boolean
    otPassages?: boolean
    ntPassages?: boolean
    themeNotes?: boolean
    isPublic?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ComparativeThemeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organizationId" | "themeName" | "description" | "category" | "otPassages" | "ntPassages" | "themeNotes" | "isPublic" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["comparativeTheme"]>
  export type ComparativeThemeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    metrics?: boolean | ComparativeTheme$metricsArgs<ExtArgs>
    _count?: boolean | ComparativeThemeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ComparativeThemeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type ComparativeThemeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $ComparativeThemePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ComparativeTheme"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      metrics: Prisma.$ThemeMetricPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organizationId: string
      themeName: string
      description: string | null
      category: string | null
      otPassages: Prisma.JsonValue
      ntPassages: Prisma.JsonValue
      themeNotes: Prisma.JsonValue | null
      isPublic: boolean
      createdBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["comparativeTheme"]>
    composites: {}
  }

  type ComparativeThemeGetPayload<S extends boolean | null | undefined | ComparativeThemeDefaultArgs> = $Result.GetResult<Prisma.$ComparativeThemePayload, S>

  type ComparativeThemeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ComparativeThemeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ComparativeThemeCountAggregateInputType | true
    }

  export interface ComparativeThemeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ComparativeTheme'], meta: { name: 'ComparativeTheme' } }
    /**
     * Find zero or one ComparativeTheme that matches the filter.
     * @param {ComparativeThemeFindUniqueArgs} args - Arguments to find a ComparativeTheme
     * @example
     * // Get one ComparativeTheme
     * const comparativeTheme = await prisma.comparativeTheme.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComparativeThemeFindUniqueArgs>(args: SelectSubset<T, ComparativeThemeFindUniqueArgs<ExtArgs>>): Prisma__ComparativeThemeClient<$Result.GetResult<Prisma.$ComparativeThemePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ComparativeTheme that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ComparativeThemeFindUniqueOrThrowArgs} args - Arguments to find a ComparativeTheme
     * @example
     * // Get one ComparativeTheme
     * const comparativeTheme = await prisma.comparativeTheme.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComparativeThemeFindUniqueOrThrowArgs>(args: SelectSubset<T, ComparativeThemeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ComparativeThemeClient<$Result.GetResult<Prisma.$ComparativeThemePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ComparativeTheme that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComparativeThemeFindFirstArgs} args - Arguments to find a ComparativeTheme
     * @example
     * // Get one ComparativeTheme
     * const comparativeTheme = await prisma.comparativeTheme.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComparativeThemeFindFirstArgs>(args?: SelectSubset<T, ComparativeThemeFindFirstArgs<ExtArgs>>): Prisma__ComparativeThemeClient<$Result.GetResult<Prisma.$ComparativeThemePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ComparativeTheme that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComparativeThemeFindFirstOrThrowArgs} args - Arguments to find a ComparativeTheme
     * @example
     * // Get one ComparativeTheme
     * const comparativeTheme = await prisma.comparativeTheme.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComparativeThemeFindFirstOrThrowArgs>(args?: SelectSubset<T, ComparativeThemeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ComparativeThemeClient<$Result.GetResult<Prisma.$ComparativeThemePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ComparativeThemes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComparativeThemeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ComparativeThemes
     * const comparativeThemes = await prisma.comparativeTheme.findMany()
     * 
     * // Get first 10 ComparativeThemes
     * const comparativeThemes = await prisma.comparativeTheme.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const comparativeThemeWithIdOnly = await prisma.comparativeTheme.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ComparativeThemeFindManyArgs>(args?: SelectSubset<T, ComparativeThemeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComparativeThemePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ComparativeTheme.
     * @param {ComparativeThemeCreateArgs} args - Arguments to create a ComparativeTheme.
     * @example
     * // Create one ComparativeTheme
     * const ComparativeTheme = await prisma.comparativeTheme.create({
     *   data: {
     *     // ... data to create a ComparativeTheme
     *   }
     * })
     * 
     */
    create<T extends ComparativeThemeCreateArgs>(args: SelectSubset<T, ComparativeThemeCreateArgs<ExtArgs>>): Prisma__ComparativeThemeClient<$Result.GetResult<Prisma.$ComparativeThemePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ComparativeThemes.
     * @param {ComparativeThemeCreateManyArgs} args - Arguments to create many ComparativeThemes.
     * @example
     * // Create many ComparativeThemes
     * const comparativeTheme = await prisma.comparativeTheme.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ComparativeThemeCreateManyArgs>(args?: SelectSubset<T, ComparativeThemeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ComparativeThemes and returns the data saved in the database.
     * @param {ComparativeThemeCreateManyAndReturnArgs} args - Arguments to create many ComparativeThemes.
     * @example
     * // Create many ComparativeThemes
     * const comparativeTheme = await prisma.comparativeTheme.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ComparativeThemes and only return the `id`
     * const comparativeThemeWithIdOnly = await prisma.comparativeTheme.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ComparativeThemeCreateManyAndReturnArgs>(args?: SelectSubset<T, ComparativeThemeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComparativeThemePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ComparativeTheme.
     * @param {ComparativeThemeDeleteArgs} args - Arguments to delete one ComparativeTheme.
     * @example
     * // Delete one ComparativeTheme
     * const ComparativeTheme = await prisma.comparativeTheme.delete({
     *   where: {
     *     // ... filter to delete one ComparativeTheme
     *   }
     * })
     * 
     */
    delete<T extends ComparativeThemeDeleteArgs>(args: SelectSubset<T, ComparativeThemeDeleteArgs<ExtArgs>>): Prisma__ComparativeThemeClient<$Result.GetResult<Prisma.$ComparativeThemePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ComparativeTheme.
     * @param {ComparativeThemeUpdateArgs} args - Arguments to update one ComparativeTheme.
     * @example
     * // Update one ComparativeTheme
     * const comparativeTheme = await prisma.comparativeTheme.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ComparativeThemeUpdateArgs>(args: SelectSubset<T, ComparativeThemeUpdateArgs<ExtArgs>>): Prisma__ComparativeThemeClient<$Result.GetResult<Prisma.$ComparativeThemePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ComparativeThemes.
     * @param {ComparativeThemeDeleteManyArgs} args - Arguments to filter ComparativeThemes to delete.
     * @example
     * // Delete a few ComparativeThemes
     * const { count } = await prisma.comparativeTheme.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ComparativeThemeDeleteManyArgs>(args?: SelectSubset<T, ComparativeThemeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ComparativeThemes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComparativeThemeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ComparativeThemes
     * const comparativeTheme = await prisma.comparativeTheme.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ComparativeThemeUpdateManyArgs>(args: SelectSubset<T, ComparativeThemeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ComparativeThemes and returns the data updated in the database.
     * @param {ComparativeThemeUpdateManyAndReturnArgs} args - Arguments to update many ComparativeThemes.
     * @example
     * // Update many ComparativeThemes
     * const comparativeTheme = await prisma.comparativeTheme.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ComparativeThemes and only return the `id`
     * const comparativeThemeWithIdOnly = await prisma.comparativeTheme.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ComparativeThemeUpdateManyAndReturnArgs>(args: SelectSubset<T, ComparativeThemeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComparativeThemePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ComparativeTheme.
     * @param {ComparativeThemeUpsertArgs} args - Arguments to update or create a ComparativeTheme.
     * @example
     * // Update or create a ComparativeTheme
     * const comparativeTheme = await prisma.comparativeTheme.upsert({
     *   create: {
     *     // ... data to create a ComparativeTheme
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ComparativeTheme we want to update
     *   }
     * })
     */
    upsert<T extends ComparativeThemeUpsertArgs>(args: SelectSubset<T, ComparativeThemeUpsertArgs<ExtArgs>>): Prisma__ComparativeThemeClient<$Result.GetResult<Prisma.$ComparativeThemePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ComparativeThemes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComparativeThemeCountArgs} args - Arguments to filter ComparativeThemes to count.
     * @example
     * // Count the number of ComparativeThemes
     * const count = await prisma.comparativeTheme.count({
     *   where: {
     *     // ... the filter for the ComparativeThemes we want to count
     *   }
     * })
    **/
    count<T extends ComparativeThemeCountArgs>(
      args?: Subset<T, ComparativeThemeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComparativeThemeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ComparativeTheme.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComparativeThemeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComparativeThemeAggregateArgs>(args: Subset<T, ComparativeThemeAggregateArgs>): Prisma.PrismaPromise<GetComparativeThemeAggregateType<T>>

    /**
     * Group by ComparativeTheme.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComparativeThemeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComparativeThemeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComparativeThemeGroupByArgs['orderBy'] }
        : { orderBy?: ComparativeThemeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComparativeThemeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComparativeThemeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ComparativeTheme model
   */
  readonly fields: ComparativeThemeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ComparativeTheme.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComparativeThemeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    metrics<T extends ComparativeTheme$metricsArgs<ExtArgs> = {}>(args?: Subset<T, ComparativeTheme$metricsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThemeMetricPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ComparativeTheme model
   */
  interface ComparativeThemeFieldRefs {
    readonly id: FieldRef<"ComparativeTheme", 'String'>
    readonly organizationId: FieldRef<"ComparativeTheme", 'String'>
    readonly themeName: FieldRef<"ComparativeTheme", 'String'>
    readonly description: FieldRef<"ComparativeTheme", 'String'>
    readonly category: FieldRef<"ComparativeTheme", 'String'>
    readonly otPassages: FieldRef<"ComparativeTheme", 'Json'>
    readonly ntPassages: FieldRef<"ComparativeTheme", 'Json'>
    readonly themeNotes: FieldRef<"ComparativeTheme", 'Json'>
    readonly isPublic: FieldRef<"ComparativeTheme", 'Boolean'>
    readonly createdBy: FieldRef<"ComparativeTheme", 'String'>
    readonly createdAt: FieldRef<"ComparativeTheme", 'DateTime'>
    readonly updatedAt: FieldRef<"ComparativeTheme", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ComparativeTheme findUnique
   */
  export type ComparativeThemeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComparativeTheme
     */
    select?: ComparativeThemeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComparativeTheme
     */
    omit?: ComparativeThemeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComparativeThemeInclude<ExtArgs> | null
    /**
     * Filter, which ComparativeTheme to fetch.
     */
    where: ComparativeThemeWhereUniqueInput
  }

  /**
   * ComparativeTheme findUniqueOrThrow
   */
  export type ComparativeThemeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComparativeTheme
     */
    select?: ComparativeThemeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComparativeTheme
     */
    omit?: ComparativeThemeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComparativeThemeInclude<ExtArgs> | null
    /**
     * Filter, which ComparativeTheme to fetch.
     */
    where: ComparativeThemeWhereUniqueInput
  }

  /**
   * ComparativeTheme findFirst
   */
  export type ComparativeThemeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComparativeTheme
     */
    select?: ComparativeThemeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComparativeTheme
     */
    omit?: ComparativeThemeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComparativeThemeInclude<ExtArgs> | null
    /**
     * Filter, which ComparativeTheme to fetch.
     */
    where?: ComparativeThemeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComparativeThemes to fetch.
     */
    orderBy?: ComparativeThemeOrderByWithRelationInput | ComparativeThemeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComparativeThemes.
     */
    cursor?: ComparativeThemeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComparativeThemes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComparativeThemes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComparativeThemes.
     */
    distinct?: ComparativeThemeScalarFieldEnum | ComparativeThemeScalarFieldEnum[]
  }

  /**
   * ComparativeTheme findFirstOrThrow
   */
  export type ComparativeThemeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComparativeTheme
     */
    select?: ComparativeThemeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComparativeTheme
     */
    omit?: ComparativeThemeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComparativeThemeInclude<ExtArgs> | null
    /**
     * Filter, which ComparativeTheme to fetch.
     */
    where?: ComparativeThemeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComparativeThemes to fetch.
     */
    orderBy?: ComparativeThemeOrderByWithRelationInput | ComparativeThemeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComparativeThemes.
     */
    cursor?: ComparativeThemeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComparativeThemes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComparativeThemes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComparativeThemes.
     */
    distinct?: ComparativeThemeScalarFieldEnum | ComparativeThemeScalarFieldEnum[]
  }

  /**
   * ComparativeTheme findMany
   */
  export type ComparativeThemeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComparativeTheme
     */
    select?: ComparativeThemeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComparativeTheme
     */
    omit?: ComparativeThemeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComparativeThemeInclude<ExtArgs> | null
    /**
     * Filter, which ComparativeThemes to fetch.
     */
    where?: ComparativeThemeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComparativeThemes to fetch.
     */
    orderBy?: ComparativeThemeOrderByWithRelationInput | ComparativeThemeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ComparativeThemes.
     */
    cursor?: ComparativeThemeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComparativeThemes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComparativeThemes.
     */
    skip?: number
    distinct?: ComparativeThemeScalarFieldEnum | ComparativeThemeScalarFieldEnum[]
  }

  /**
   * ComparativeTheme create
   */
  export type ComparativeThemeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComparativeTheme
     */
    select?: ComparativeThemeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComparativeTheme
     */
    omit?: ComparativeThemeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComparativeThemeInclude<ExtArgs> | null
    /**
     * The data needed to create a ComparativeTheme.
     */
    data: XOR<ComparativeThemeCreateInput, ComparativeThemeUncheckedCreateInput>
  }

  /**
   * ComparativeTheme createMany
   */
  export type ComparativeThemeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ComparativeThemes.
     */
    data: ComparativeThemeCreateManyInput | ComparativeThemeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ComparativeTheme createManyAndReturn
   */
  export type ComparativeThemeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComparativeTheme
     */
    select?: ComparativeThemeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ComparativeTheme
     */
    omit?: ComparativeThemeOmit<ExtArgs> | null
    /**
     * The data used to create many ComparativeThemes.
     */
    data: ComparativeThemeCreateManyInput | ComparativeThemeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComparativeThemeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ComparativeTheme update
   */
  export type ComparativeThemeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComparativeTheme
     */
    select?: ComparativeThemeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComparativeTheme
     */
    omit?: ComparativeThemeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComparativeThemeInclude<ExtArgs> | null
    /**
     * The data needed to update a ComparativeTheme.
     */
    data: XOR<ComparativeThemeUpdateInput, ComparativeThemeUncheckedUpdateInput>
    /**
     * Choose, which ComparativeTheme to update.
     */
    where: ComparativeThemeWhereUniqueInput
  }

  /**
   * ComparativeTheme updateMany
   */
  export type ComparativeThemeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ComparativeThemes.
     */
    data: XOR<ComparativeThemeUpdateManyMutationInput, ComparativeThemeUncheckedUpdateManyInput>
    /**
     * Filter which ComparativeThemes to update
     */
    where?: ComparativeThemeWhereInput
    /**
     * Limit how many ComparativeThemes to update.
     */
    limit?: number
  }

  /**
   * ComparativeTheme updateManyAndReturn
   */
  export type ComparativeThemeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComparativeTheme
     */
    select?: ComparativeThemeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ComparativeTheme
     */
    omit?: ComparativeThemeOmit<ExtArgs> | null
    /**
     * The data used to update ComparativeThemes.
     */
    data: XOR<ComparativeThemeUpdateManyMutationInput, ComparativeThemeUncheckedUpdateManyInput>
    /**
     * Filter which ComparativeThemes to update
     */
    where?: ComparativeThemeWhereInput
    /**
     * Limit how many ComparativeThemes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComparativeThemeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ComparativeTheme upsert
   */
  export type ComparativeThemeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComparativeTheme
     */
    select?: ComparativeThemeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComparativeTheme
     */
    omit?: ComparativeThemeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComparativeThemeInclude<ExtArgs> | null
    /**
     * The filter to search for the ComparativeTheme to update in case it exists.
     */
    where: ComparativeThemeWhereUniqueInput
    /**
     * In case the ComparativeTheme found by the `where` argument doesn't exist, create a new ComparativeTheme with this data.
     */
    create: XOR<ComparativeThemeCreateInput, ComparativeThemeUncheckedCreateInput>
    /**
     * In case the ComparativeTheme was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComparativeThemeUpdateInput, ComparativeThemeUncheckedUpdateInput>
  }

  /**
   * ComparativeTheme delete
   */
  export type ComparativeThemeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComparativeTheme
     */
    select?: ComparativeThemeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComparativeTheme
     */
    omit?: ComparativeThemeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComparativeThemeInclude<ExtArgs> | null
    /**
     * Filter which ComparativeTheme to delete.
     */
    where: ComparativeThemeWhereUniqueInput
  }

  /**
   * ComparativeTheme deleteMany
   */
  export type ComparativeThemeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComparativeThemes to delete
     */
    where?: ComparativeThemeWhereInput
    /**
     * Limit how many ComparativeThemes to delete.
     */
    limit?: number
  }

  /**
   * ComparativeTheme.metrics
   */
  export type ComparativeTheme$metricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThemeMetric
     */
    select?: ThemeMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThemeMetric
     */
    omit?: ThemeMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemeMetricInclude<ExtArgs> | null
    where?: ThemeMetricWhereInput
    orderBy?: ThemeMetricOrderByWithRelationInput | ThemeMetricOrderByWithRelationInput[]
    cursor?: ThemeMetricWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ThemeMetricScalarFieldEnum | ThemeMetricScalarFieldEnum[]
  }

  /**
   * ComparativeTheme without action
   */
  export type ComparativeThemeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComparativeTheme
     */
    select?: ComparativeThemeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComparativeTheme
     */
    omit?: ComparativeThemeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComparativeThemeInclude<ExtArgs> | null
  }


  /**
   * Model ThemeMetric
   */

  export type AggregateThemeMetric = {
    _count: ThemeMetricCountAggregateOutputType | null
    _avg: ThemeMetricAvgAggregateOutputType | null
    _sum: ThemeMetricSumAggregateOutputType | null
    _min: ThemeMetricMinAggregateOutputType | null
    _max: ThemeMetricMaxAggregateOutputType | null
  }

  export type ThemeMetricAvgAggregateOutputType = {
    viewCount: number | null
    timeSpentMs: number | null
  }

  export type ThemeMetricSumAggregateOutputType = {
    viewCount: number | null
    timeSpentMs: number | null
  }

  export type ThemeMetricMinAggregateOutputType = {
    id: string | null
    themeId: string | null
    organizationId: string | null
    viewCount: number | null
    lastViewedAt: Date | null
    userId: string | null
    featureContext: string | null
    timeSpentMs: number | null
    usedInLesson: boolean | null
    lessonId: string | null
    createdAt: Date | null
  }

  export type ThemeMetricMaxAggregateOutputType = {
    id: string | null
    themeId: string | null
    organizationId: string | null
    viewCount: number | null
    lastViewedAt: Date | null
    userId: string | null
    featureContext: string | null
    timeSpentMs: number | null
    usedInLesson: boolean | null
    lessonId: string | null
    createdAt: Date | null
  }

  export type ThemeMetricCountAggregateOutputType = {
    id: number
    themeId: number
    organizationId: number
    viewCount: number
    lastViewedAt: number
    userId: number
    featureContext: number
    timeSpentMs: number
    usedInLesson: number
    lessonId: number
    createdAt: number
    _all: number
  }


  export type ThemeMetricAvgAggregateInputType = {
    viewCount?: true
    timeSpentMs?: true
  }

  export type ThemeMetricSumAggregateInputType = {
    viewCount?: true
    timeSpentMs?: true
  }

  export type ThemeMetricMinAggregateInputType = {
    id?: true
    themeId?: true
    organizationId?: true
    viewCount?: true
    lastViewedAt?: true
    userId?: true
    featureContext?: true
    timeSpentMs?: true
    usedInLesson?: true
    lessonId?: true
    createdAt?: true
  }

  export type ThemeMetricMaxAggregateInputType = {
    id?: true
    themeId?: true
    organizationId?: true
    viewCount?: true
    lastViewedAt?: true
    userId?: true
    featureContext?: true
    timeSpentMs?: true
    usedInLesson?: true
    lessonId?: true
    createdAt?: true
  }

  export type ThemeMetricCountAggregateInputType = {
    id?: true
    themeId?: true
    organizationId?: true
    viewCount?: true
    lastViewedAt?: true
    userId?: true
    featureContext?: true
    timeSpentMs?: true
    usedInLesson?: true
    lessonId?: true
    createdAt?: true
    _all?: true
  }

  export type ThemeMetricAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ThemeMetric to aggregate.
     */
    where?: ThemeMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ThemeMetrics to fetch.
     */
    orderBy?: ThemeMetricOrderByWithRelationInput | ThemeMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ThemeMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ThemeMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ThemeMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ThemeMetrics
    **/
    _count?: true | ThemeMetricCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ThemeMetricAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ThemeMetricSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ThemeMetricMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ThemeMetricMaxAggregateInputType
  }

  export type GetThemeMetricAggregateType<T extends ThemeMetricAggregateArgs> = {
        [P in keyof T & keyof AggregateThemeMetric]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateThemeMetric[P]>
      : GetScalarType<T[P], AggregateThemeMetric[P]>
  }




  export type ThemeMetricGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ThemeMetricWhereInput
    orderBy?: ThemeMetricOrderByWithAggregationInput | ThemeMetricOrderByWithAggregationInput[]
    by: ThemeMetricScalarFieldEnum[] | ThemeMetricScalarFieldEnum
    having?: ThemeMetricScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ThemeMetricCountAggregateInputType | true
    _avg?: ThemeMetricAvgAggregateInputType
    _sum?: ThemeMetricSumAggregateInputType
    _min?: ThemeMetricMinAggregateInputType
    _max?: ThemeMetricMaxAggregateInputType
  }

  export type ThemeMetricGroupByOutputType = {
    id: string
    themeId: string
    organizationId: string
    viewCount: number
    lastViewedAt: Date
    userId: string | null
    featureContext: string | null
    timeSpentMs: number | null
    usedInLesson: boolean
    lessonId: string | null
    createdAt: Date
    _count: ThemeMetricCountAggregateOutputType | null
    _avg: ThemeMetricAvgAggregateOutputType | null
    _sum: ThemeMetricSumAggregateOutputType | null
    _min: ThemeMetricMinAggregateOutputType | null
    _max: ThemeMetricMaxAggregateOutputType | null
  }

  type GetThemeMetricGroupByPayload<T extends ThemeMetricGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ThemeMetricGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ThemeMetricGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ThemeMetricGroupByOutputType[P]>
            : GetScalarType<T[P], ThemeMetricGroupByOutputType[P]>
        }
      >
    >


  export type ThemeMetricSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    themeId?: boolean
    organizationId?: boolean
    viewCount?: boolean
    lastViewedAt?: boolean
    userId?: boolean
    featureContext?: boolean
    timeSpentMs?: boolean
    usedInLesson?: boolean
    lessonId?: boolean
    createdAt?: boolean
    theme?: boolean | ComparativeThemeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["themeMetric"]>

  export type ThemeMetricSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    themeId?: boolean
    organizationId?: boolean
    viewCount?: boolean
    lastViewedAt?: boolean
    userId?: boolean
    featureContext?: boolean
    timeSpentMs?: boolean
    usedInLesson?: boolean
    lessonId?: boolean
    createdAt?: boolean
    theme?: boolean | ComparativeThemeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["themeMetric"]>

  export type ThemeMetricSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    themeId?: boolean
    organizationId?: boolean
    viewCount?: boolean
    lastViewedAt?: boolean
    userId?: boolean
    featureContext?: boolean
    timeSpentMs?: boolean
    usedInLesson?: boolean
    lessonId?: boolean
    createdAt?: boolean
    theme?: boolean | ComparativeThemeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["themeMetric"]>

  export type ThemeMetricSelectScalar = {
    id?: boolean
    themeId?: boolean
    organizationId?: boolean
    viewCount?: boolean
    lastViewedAt?: boolean
    userId?: boolean
    featureContext?: boolean
    timeSpentMs?: boolean
    usedInLesson?: boolean
    lessonId?: boolean
    createdAt?: boolean
  }

  export type ThemeMetricOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "themeId" | "organizationId" | "viewCount" | "lastViewedAt" | "userId" | "featureContext" | "timeSpentMs" | "usedInLesson" | "lessonId" | "createdAt", ExtArgs["result"]["themeMetric"]>
  export type ThemeMetricInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    theme?: boolean | ComparativeThemeDefaultArgs<ExtArgs>
  }
  export type ThemeMetricIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    theme?: boolean | ComparativeThemeDefaultArgs<ExtArgs>
  }
  export type ThemeMetricIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    theme?: boolean | ComparativeThemeDefaultArgs<ExtArgs>
  }

  export type $ThemeMetricPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ThemeMetric"
    objects: {
      theme: Prisma.$ComparativeThemePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      themeId: string
      organizationId: string
      viewCount: number
      lastViewedAt: Date
      userId: string | null
      featureContext: string | null
      timeSpentMs: number | null
      usedInLesson: boolean
      lessonId: string | null
      createdAt: Date
    }, ExtArgs["result"]["themeMetric"]>
    composites: {}
  }

  type ThemeMetricGetPayload<S extends boolean | null | undefined | ThemeMetricDefaultArgs> = $Result.GetResult<Prisma.$ThemeMetricPayload, S>

  type ThemeMetricCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ThemeMetricFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ThemeMetricCountAggregateInputType | true
    }

  export interface ThemeMetricDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ThemeMetric'], meta: { name: 'ThemeMetric' } }
    /**
     * Find zero or one ThemeMetric that matches the filter.
     * @param {ThemeMetricFindUniqueArgs} args - Arguments to find a ThemeMetric
     * @example
     * // Get one ThemeMetric
     * const themeMetric = await prisma.themeMetric.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ThemeMetricFindUniqueArgs>(args: SelectSubset<T, ThemeMetricFindUniqueArgs<ExtArgs>>): Prisma__ThemeMetricClient<$Result.GetResult<Prisma.$ThemeMetricPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ThemeMetric that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ThemeMetricFindUniqueOrThrowArgs} args - Arguments to find a ThemeMetric
     * @example
     * // Get one ThemeMetric
     * const themeMetric = await prisma.themeMetric.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ThemeMetricFindUniqueOrThrowArgs>(args: SelectSubset<T, ThemeMetricFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ThemeMetricClient<$Result.GetResult<Prisma.$ThemeMetricPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ThemeMetric that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThemeMetricFindFirstArgs} args - Arguments to find a ThemeMetric
     * @example
     * // Get one ThemeMetric
     * const themeMetric = await prisma.themeMetric.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ThemeMetricFindFirstArgs>(args?: SelectSubset<T, ThemeMetricFindFirstArgs<ExtArgs>>): Prisma__ThemeMetricClient<$Result.GetResult<Prisma.$ThemeMetricPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ThemeMetric that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThemeMetricFindFirstOrThrowArgs} args - Arguments to find a ThemeMetric
     * @example
     * // Get one ThemeMetric
     * const themeMetric = await prisma.themeMetric.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ThemeMetricFindFirstOrThrowArgs>(args?: SelectSubset<T, ThemeMetricFindFirstOrThrowArgs<ExtArgs>>): Prisma__ThemeMetricClient<$Result.GetResult<Prisma.$ThemeMetricPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ThemeMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThemeMetricFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ThemeMetrics
     * const themeMetrics = await prisma.themeMetric.findMany()
     * 
     * // Get first 10 ThemeMetrics
     * const themeMetrics = await prisma.themeMetric.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const themeMetricWithIdOnly = await prisma.themeMetric.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ThemeMetricFindManyArgs>(args?: SelectSubset<T, ThemeMetricFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThemeMetricPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ThemeMetric.
     * @param {ThemeMetricCreateArgs} args - Arguments to create a ThemeMetric.
     * @example
     * // Create one ThemeMetric
     * const ThemeMetric = await prisma.themeMetric.create({
     *   data: {
     *     // ... data to create a ThemeMetric
     *   }
     * })
     * 
     */
    create<T extends ThemeMetricCreateArgs>(args: SelectSubset<T, ThemeMetricCreateArgs<ExtArgs>>): Prisma__ThemeMetricClient<$Result.GetResult<Prisma.$ThemeMetricPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ThemeMetrics.
     * @param {ThemeMetricCreateManyArgs} args - Arguments to create many ThemeMetrics.
     * @example
     * // Create many ThemeMetrics
     * const themeMetric = await prisma.themeMetric.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ThemeMetricCreateManyArgs>(args?: SelectSubset<T, ThemeMetricCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ThemeMetrics and returns the data saved in the database.
     * @param {ThemeMetricCreateManyAndReturnArgs} args - Arguments to create many ThemeMetrics.
     * @example
     * // Create many ThemeMetrics
     * const themeMetric = await prisma.themeMetric.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ThemeMetrics and only return the `id`
     * const themeMetricWithIdOnly = await prisma.themeMetric.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ThemeMetricCreateManyAndReturnArgs>(args?: SelectSubset<T, ThemeMetricCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThemeMetricPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ThemeMetric.
     * @param {ThemeMetricDeleteArgs} args - Arguments to delete one ThemeMetric.
     * @example
     * // Delete one ThemeMetric
     * const ThemeMetric = await prisma.themeMetric.delete({
     *   where: {
     *     // ... filter to delete one ThemeMetric
     *   }
     * })
     * 
     */
    delete<T extends ThemeMetricDeleteArgs>(args: SelectSubset<T, ThemeMetricDeleteArgs<ExtArgs>>): Prisma__ThemeMetricClient<$Result.GetResult<Prisma.$ThemeMetricPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ThemeMetric.
     * @param {ThemeMetricUpdateArgs} args - Arguments to update one ThemeMetric.
     * @example
     * // Update one ThemeMetric
     * const themeMetric = await prisma.themeMetric.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ThemeMetricUpdateArgs>(args: SelectSubset<T, ThemeMetricUpdateArgs<ExtArgs>>): Prisma__ThemeMetricClient<$Result.GetResult<Prisma.$ThemeMetricPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ThemeMetrics.
     * @param {ThemeMetricDeleteManyArgs} args - Arguments to filter ThemeMetrics to delete.
     * @example
     * // Delete a few ThemeMetrics
     * const { count } = await prisma.themeMetric.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ThemeMetricDeleteManyArgs>(args?: SelectSubset<T, ThemeMetricDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ThemeMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThemeMetricUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ThemeMetrics
     * const themeMetric = await prisma.themeMetric.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ThemeMetricUpdateManyArgs>(args: SelectSubset<T, ThemeMetricUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ThemeMetrics and returns the data updated in the database.
     * @param {ThemeMetricUpdateManyAndReturnArgs} args - Arguments to update many ThemeMetrics.
     * @example
     * // Update many ThemeMetrics
     * const themeMetric = await prisma.themeMetric.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ThemeMetrics and only return the `id`
     * const themeMetricWithIdOnly = await prisma.themeMetric.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ThemeMetricUpdateManyAndReturnArgs>(args: SelectSubset<T, ThemeMetricUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThemeMetricPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ThemeMetric.
     * @param {ThemeMetricUpsertArgs} args - Arguments to update or create a ThemeMetric.
     * @example
     * // Update or create a ThemeMetric
     * const themeMetric = await prisma.themeMetric.upsert({
     *   create: {
     *     // ... data to create a ThemeMetric
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ThemeMetric we want to update
     *   }
     * })
     */
    upsert<T extends ThemeMetricUpsertArgs>(args: SelectSubset<T, ThemeMetricUpsertArgs<ExtArgs>>): Prisma__ThemeMetricClient<$Result.GetResult<Prisma.$ThemeMetricPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ThemeMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThemeMetricCountArgs} args - Arguments to filter ThemeMetrics to count.
     * @example
     * // Count the number of ThemeMetrics
     * const count = await prisma.themeMetric.count({
     *   where: {
     *     // ... the filter for the ThemeMetrics we want to count
     *   }
     * })
    **/
    count<T extends ThemeMetricCountArgs>(
      args?: Subset<T, ThemeMetricCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ThemeMetricCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ThemeMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThemeMetricAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ThemeMetricAggregateArgs>(args: Subset<T, ThemeMetricAggregateArgs>): Prisma.PrismaPromise<GetThemeMetricAggregateType<T>>

    /**
     * Group by ThemeMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThemeMetricGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ThemeMetricGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ThemeMetricGroupByArgs['orderBy'] }
        : { orderBy?: ThemeMetricGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ThemeMetricGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetThemeMetricGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ThemeMetric model
   */
  readonly fields: ThemeMetricFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ThemeMetric.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ThemeMetricClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    theme<T extends ComparativeThemeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ComparativeThemeDefaultArgs<ExtArgs>>): Prisma__ComparativeThemeClient<$Result.GetResult<Prisma.$ComparativeThemePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ThemeMetric model
   */
  interface ThemeMetricFieldRefs {
    readonly id: FieldRef<"ThemeMetric", 'String'>
    readonly themeId: FieldRef<"ThemeMetric", 'String'>
    readonly organizationId: FieldRef<"ThemeMetric", 'String'>
    readonly viewCount: FieldRef<"ThemeMetric", 'Int'>
    readonly lastViewedAt: FieldRef<"ThemeMetric", 'DateTime'>
    readonly userId: FieldRef<"ThemeMetric", 'String'>
    readonly featureContext: FieldRef<"ThemeMetric", 'String'>
    readonly timeSpentMs: FieldRef<"ThemeMetric", 'Int'>
    readonly usedInLesson: FieldRef<"ThemeMetric", 'Boolean'>
    readonly lessonId: FieldRef<"ThemeMetric", 'String'>
    readonly createdAt: FieldRef<"ThemeMetric", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ThemeMetric findUnique
   */
  export type ThemeMetricFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThemeMetric
     */
    select?: ThemeMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThemeMetric
     */
    omit?: ThemeMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemeMetricInclude<ExtArgs> | null
    /**
     * Filter, which ThemeMetric to fetch.
     */
    where: ThemeMetricWhereUniqueInput
  }

  /**
   * ThemeMetric findUniqueOrThrow
   */
  export type ThemeMetricFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThemeMetric
     */
    select?: ThemeMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThemeMetric
     */
    omit?: ThemeMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemeMetricInclude<ExtArgs> | null
    /**
     * Filter, which ThemeMetric to fetch.
     */
    where: ThemeMetricWhereUniqueInput
  }

  /**
   * ThemeMetric findFirst
   */
  export type ThemeMetricFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThemeMetric
     */
    select?: ThemeMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThemeMetric
     */
    omit?: ThemeMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemeMetricInclude<ExtArgs> | null
    /**
     * Filter, which ThemeMetric to fetch.
     */
    where?: ThemeMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ThemeMetrics to fetch.
     */
    orderBy?: ThemeMetricOrderByWithRelationInput | ThemeMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ThemeMetrics.
     */
    cursor?: ThemeMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ThemeMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ThemeMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ThemeMetrics.
     */
    distinct?: ThemeMetricScalarFieldEnum | ThemeMetricScalarFieldEnum[]
  }

  /**
   * ThemeMetric findFirstOrThrow
   */
  export type ThemeMetricFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThemeMetric
     */
    select?: ThemeMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThemeMetric
     */
    omit?: ThemeMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemeMetricInclude<ExtArgs> | null
    /**
     * Filter, which ThemeMetric to fetch.
     */
    where?: ThemeMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ThemeMetrics to fetch.
     */
    orderBy?: ThemeMetricOrderByWithRelationInput | ThemeMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ThemeMetrics.
     */
    cursor?: ThemeMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ThemeMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ThemeMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ThemeMetrics.
     */
    distinct?: ThemeMetricScalarFieldEnum | ThemeMetricScalarFieldEnum[]
  }

  /**
   * ThemeMetric findMany
   */
  export type ThemeMetricFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThemeMetric
     */
    select?: ThemeMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThemeMetric
     */
    omit?: ThemeMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemeMetricInclude<ExtArgs> | null
    /**
     * Filter, which ThemeMetrics to fetch.
     */
    where?: ThemeMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ThemeMetrics to fetch.
     */
    orderBy?: ThemeMetricOrderByWithRelationInput | ThemeMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ThemeMetrics.
     */
    cursor?: ThemeMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ThemeMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ThemeMetrics.
     */
    skip?: number
    distinct?: ThemeMetricScalarFieldEnum | ThemeMetricScalarFieldEnum[]
  }

  /**
   * ThemeMetric create
   */
  export type ThemeMetricCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThemeMetric
     */
    select?: ThemeMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThemeMetric
     */
    omit?: ThemeMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemeMetricInclude<ExtArgs> | null
    /**
     * The data needed to create a ThemeMetric.
     */
    data: XOR<ThemeMetricCreateInput, ThemeMetricUncheckedCreateInput>
  }

  /**
   * ThemeMetric createMany
   */
  export type ThemeMetricCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ThemeMetrics.
     */
    data: ThemeMetricCreateManyInput | ThemeMetricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ThemeMetric createManyAndReturn
   */
  export type ThemeMetricCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThemeMetric
     */
    select?: ThemeMetricSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ThemeMetric
     */
    omit?: ThemeMetricOmit<ExtArgs> | null
    /**
     * The data used to create many ThemeMetrics.
     */
    data: ThemeMetricCreateManyInput | ThemeMetricCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemeMetricIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ThemeMetric update
   */
  export type ThemeMetricUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThemeMetric
     */
    select?: ThemeMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThemeMetric
     */
    omit?: ThemeMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemeMetricInclude<ExtArgs> | null
    /**
     * The data needed to update a ThemeMetric.
     */
    data: XOR<ThemeMetricUpdateInput, ThemeMetricUncheckedUpdateInput>
    /**
     * Choose, which ThemeMetric to update.
     */
    where: ThemeMetricWhereUniqueInput
  }

  /**
   * ThemeMetric updateMany
   */
  export type ThemeMetricUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ThemeMetrics.
     */
    data: XOR<ThemeMetricUpdateManyMutationInput, ThemeMetricUncheckedUpdateManyInput>
    /**
     * Filter which ThemeMetrics to update
     */
    where?: ThemeMetricWhereInput
    /**
     * Limit how many ThemeMetrics to update.
     */
    limit?: number
  }

  /**
   * ThemeMetric updateManyAndReturn
   */
  export type ThemeMetricUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThemeMetric
     */
    select?: ThemeMetricSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ThemeMetric
     */
    omit?: ThemeMetricOmit<ExtArgs> | null
    /**
     * The data used to update ThemeMetrics.
     */
    data: XOR<ThemeMetricUpdateManyMutationInput, ThemeMetricUncheckedUpdateManyInput>
    /**
     * Filter which ThemeMetrics to update
     */
    where?: ThemeMetricWhereInput
    /**
     * Limit how many ThemeMetrics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemeMetricIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ThemeMetric upsert
   */
  export type ThemeMetricUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThemeMetric
     */
    select?: ThemeMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThemeMetric
     */
    omit?: ThemeMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemeMetricInclude<ExtArgs> | null
    /**
     * The filter to search for the ThemeMetric to update in case it exists.
     */
    where: ThemeMetricWhereUniqueInput
    /**
     * In case the ThemeMetric found by the `where` argument doesn't exist, create a new ThemeMetric with this data.
     */
    create: XOR<ThemeMetricCreateInput, ThemeMetricUncheckedCreateInput>
    /**
     * In case the ThemeMetric was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ThemeMetricUpdateInput, ThemeMetricUncheckedUpdateInput>
  }

  /**
   * ThemeMetric delete
   */
  export type ThemeMetricDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThemeMetric
     */
    select?: ThemeMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThemeMetric
     */
    omit?: ThemeMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemeMetricInclude<ExtArgs> | null
    /**
     * Filter which ThemeMetric to delete.
     */
    where: ThemeMetricWhereUniqueInput
  }

  /**
   * ThemeMetric deleteMany
   */
  export type ThemeMetricDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ThemeMetrics to delete
     */
    where?: ThemeMetricWhereInput
    /**
     * Limit how many ThemeMetrics to delete.
     */
    limit?: number
  }

  /**
   * ThemeMetric without action
   */
  export type ThemeMetricDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThemeMetric
     */
    select?: ThemeMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThemeMetric
     */
    omit?: ThemeMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemeMetricInclude<ExtArgs> | null
  }


  /**
   * Model NotificationPreference
   */

  export type AggregateNotificationPreference = {
    _count: NotificationPreferenceCountAggregateOutputType | null
    _avg: NotificationPreferenceAvgAggregateOutputType | null
    _sum: NotificationPreferenceSumAggregateOutputType | null
    _min: NotificationPreferenceMinAggregateOutputType | null
    _max: NotificationPreferenceMaxAggregateOutputType | null
  }

  export type NotificationPreferenceAvgAggregateOutputType = {
    lessonReminderDays: number | null
    eventReminderHours: number | null
    maxNotificationsPerDay: number | null
  }

  export type NotificationPreferenceSumAggregateOutputType = {
    lessonReminderDays: number | null
    eventReminderHours: number | null
    maxNotificationsPerDay: number | null
  }

  export type NotificationPreferenceMinAggregateOutputType = {
    id: string | null
    userId: string | null
    emailEnabled: boolean | null
    emailLessonReminders: boolean | null
    emailEventReminders: boolean | null
    emailAnnouncements: boolean | null
    emailGroupUpdates: boolean | null
    emailDigest: boolean | null
    emailDigestFrequency: $Enums.DigestFrequency | null
    inAppEnabled: boolean | null
    inAppLessonReminders: boolean | null
    inAppEventReminders: boolean | null
    inAppAnnouncements: boolean | null
    inAppGroupUpdates: boolean | null
    quietHoursEnabled: boolean | null
    quietHoursStart: string | null
    quietHoursEnd: string | null
    quietHoursTimezone: string | null
    lessonReminderDays: number | null
    lessonReminderTime: string | null
    eventReminderHours: number | null
    batchNotifications: boolean | null
    maxNotificationsPerDay: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationPreferenceMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    emailEnabled: boolean | null
    emailLessonReminders: boolean | null
    emailEventReminders: boolean | null
    emailAnnouncements: boolean | null
    emailGroupUpdates: boolean | null
    emailDigest: boolean | null
    emailDigestFrequency: $Enums.DigestFrequency | null
    inAppEnabled: boolean | null
    inAppLessonReminders: boolean | null
    inAppEventReminders: boolean | null
    inAppAnnouncements: boolean | null
    inAppGroupUpdates: boolean | null
    quietHoursEnabled: boolean | null
    quietHoursStart: string | null
    quietHoursEnd: string | null
    quietHoursTimezone: string | null
    lessonReminderDays: number | null
    lessonReminderTime: string | null
    eventReminderHours: number | null
    batchNotifications: boolean | null
    maxNotificationsPerDay: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationPreferenceCountAggregateOutputType = {
    id: number
    userId: number
    emailEnabled: number
    emailLessonReminders: number
    emailEventReminders: number
    emailAnnouncements: number
    emailGroupUpdates: number
    emailDigest: number
    emailDigestFrequency: number
    inAppEnabled: number
    inAppLessonReminders: number
    inAppEventReminders: number
    inAppAnnouncements: number
    inAppGroupUpdates: number
    quietHoursEnabled: number
    quietHoursStart: number
    quietHoursEnd: number
    quietHoursTimezone: number
    preferredDays: number
    lessonReminderDays: number
    lessonReminderTime: number
    eventReminderHours: number
    batchNotifications: number
    maxNotificationsPerDay: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationPreferenceAvgAggregateInputType = {
    lessonReminderDays?: true
    eventReminderHours?: true
    maxNotificationsPerDay?: true
  }

  export type NotificationPreferenceSumAggregateInputType = {
    lessonReminderDays?: true
    eventReminderHours?: true
    maxNotificationsPerDay?: true
  }

  export type NotificationPreferenceMinAggregateInputType = {
    id?: true
    userId?: true
    emailEnabled?: true
    emailLessonReminders?: true
    emailEventReminders?: true
    emailAnnouncements?: true
    emailGroupUpdates?: true
    emailDigest?: true
    emailDigestFrequency?: true
    inAppEnabled?: true
    inAppLessonReminders?: true
    inAppEventReminders?: true
    inAppAnnouncements?: true
    inAppGroupUpdates?: true
    quietHoursEnabled?: true
    quietHoursStart?: true
    quietHoursEnd?: true
    quietHoursTimezone?: true
    lessonReminderDays?: true
    lessonReminderTime?: true
    eventReminderHours?: true
    batchNotifications?: true
    maxNotificationsPerDay?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationPreferenceMaxAggregateInputType = {
    id?: true
    userId?: true
    emailEnabled?: true
    emailLessonReminders?: true
    emailEventReminders?: true
    emailAnnouncements?: true
    emailGroupUpdates?: true
    emailDigest?: true
    emailDigestFrequency?: true
    inAppEnabled?: true
    inAppLessonReminders?: true
    inAppEventReminders?: true
    inAppAnnouncements?: true
    inAppGroupUpdates?: true
    quietHoursEnabled?: true
    quietHoursStart?: true
    quietHoursEnd?: true
    quietHoursTimezone?: true
    lessonReminderDays?: true
    lessonReminderTime?: true
    eventReminderHours?: true
    batchNotifications?: true
    maxNotificationsPerDay?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationPreferenceCountAggregateInputType = {
    id?: true
    userId?: true
    emailEnabled?: true
    emailLessonReminders?: true
    emailEventReminders?: true
    emailAnnouncements?: true
    emailGroupUpdates?: true
    emailDigest?: true
    emailDigestFrequency?: true
    inAppEnabled?: true
    inAppLessonReminders?: true
    inAppEventReminders?: true
    inAppAnnouncements?: true
    inAppGroupUpdates?: true
    quietHoursEnabled?: true
    quietHoursStart?: true
    quietHoursEnd?: true
    quietHoursTimezone?: true
    preferredDays?: true
    lessonReminderDays?: true
    lessonReminderTime?: true
    eventReminderHours?: true
    batchNotifications?: true
    maxNotificationsPerDay?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationPreferenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationPreference to aggregate.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationPreferences
    **/
    _count?: true | NotificationPreferenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationPreferenceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationPreferenceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationPreferenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationPreferenceMaxAggregateInputType
  }

  export type GetNotificationPreferenceAggregateType<T extends NotificationPreferenceAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationPreference]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationPreference[P]>
      : GetScalarType<T[P], AggregateNotificationPreference[P]>
  }




  export type NotificationPreferenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationPreferenceWhereInput
    orderBy?: NotificationPreferenceOrderByWithAggregationInput | NotificationPreferenceOrderByWithAggregationInput[]
    by: NotificationPreferenceScalarFieldEnum[] | NotificationPreferenceScalarFieldEnum
    having?: NotificationPreferenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationPreferenceCountAggregateInputType | true
    _avg?: NotificationPreferenceAvgAggregateInputType
    _sum?: NotificationPreferenceSumAggregateInputType
    _min?: NotificationPreferenceMinAggregateInputType
    _max?: NotificationPreferenceMaxAggregateInputType
  }

  export type NotificationPreferenceGroupByOutputType = {
    id: string
    userId: string
    emailEnabled: boolean
    emailLessonReminders: boolean
    emailEventReminders: boolean
    emailAnnouncements: boolean
    emailGroupUpdates: boolean
    emailDigest: boolean
    emailDigestFrequency: $Enums.DigestFrequency
    inAppEnabled: boolean
    inAppLessonReminders: boolean
    inAppEventReminders: boolean
    inAppAnnouncements: boolean
    inAppGroupUpdates: boolean
    quietHoursEnabled: boolean
    quietHoursStart: string | null
    quietHoursEnd: string | null
    quietHoursTimezone: string
    preferredDays: JsonValue | null
    lessonReminderDays: number
    lessonReminderTime: string
    eventReminderHours: number
    batchNotifications: boolean
    maxNotificationsPerDay: number
    createdAt: Date
    updatedAt: Date
    _count: NotificationPreferenceCountAggregateOutputType | null
    _avg: NotificationPreferenceAvgAggregateOutputType | null
    _sum: NotificationPreferenceSumAggregateOutputType | null
    _min: NotificationPreferenceMinAggregateOutputType | null
    _max: NotificationPreferenceMaxAggregateOutputType | null
  }

  type GetNotificationPreferenceGroupByPayload<T extends NotificationPreferenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationPreferenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationPreferenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationPreferenceGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationPreferenceGroupByOutputType[P]>
        }
      >
    >


  export type NotificationPreferenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    emailEnabled?: boolean
    emailLessonReminders?: boolean
    emailEventReminders?: boolean
    emailAnnouncements?: boolean
    emailGroupUpdates?: boolean
    emailDigest?: boolean
    emailDigestFrequency?: boolean
    inAppEnabled?: boolean
    inAppLessonReminders?: boolean
    inAppEventReminders?: boolean
    inAppAnnouncements?: boolean
    inAppGroupUpdates?: boolean
    quietHoursEnabled?: boolean
    quietHoursStart?: boolean
    quietHoursEnd?: boolean
    quietHoursTimezone?: boolean
    preferredDays?: boolean
    lessonReminderDays?: boolean
    lessonReminderTime?: boolean
    eventReminderHours?: boolean
    batchNotifications?: boolean
    maxNotificationsPerDay?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPreference"]>

  export type NotificationPreferenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    emailEnabled?: boolean
    emailLessonReminders?: boolean
    emailEventReminders?: boolean
    emailAnnouncements?: boolean
    emailGroupUpdates?: boolean
    emailDigest?: boolean
    emailDigestFrequency?: boolean
    inAppEnabled?: boolean
    inAppLessonReminders?: boolean
    inAppEventReminders?: boolean
    inAppAnnouncements?: boolean
    inAppGroupUpdates?: boolean
    quietHoursEnabled?: boolean
    quietHoursStart?: boolean
    quietHoursEnd?: boolean
    quietHoursTimezone?: boolean
    preferredDays?: boolean
    lessonReminderDays?: boolean
    lessonReminderTime?: boolean
    eventReminderHours?: boolean
    batchNotifications?: boolean
    maxNotificationsPerDay?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPreference"]>

  export type NotificationPreferenceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    emailEnabled?: boolean
    emailLessonReminders?: boolean
    emailEventReminders?: boolean
    emailAnnouncements?: boolean
    emailGroupUpdates?: boolean
    emailDigest?: boolean
    emailDigestFrequency?: boolean
    inAppEnabled?: boolean
    inAppLessonReminders?: boolean
    inAppEventReminders?: boolean
    inAppAnnouncements?: boolean
    inAppGroupUpdates?: boolean
    quietHoursEnabled?: boolean
    quietHoursStart?: boolean
    quietHoursEnd?: boolean
    quietHoursTimezone?: boolean
    preferredDays?: boolean
    lessonReminderDays?: boolean
    lessonReminderTime?: boolean
    eventReminderHours?: boolean
    batchNotifications?: boolean
    maxNotificationsPerDay?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPreference"]>

  export type NotificationPreferenceSelectScalar = {
    id?: boolean
    userId?: boolean
    emailEnabled?: boolean
    emailLessonReminders?: boolean
    emailEventReminders?: boolean
    emailAnnouncements?: boolean
    emailGroupUpdates?: boolean
    emailDigest?: boolean
    emailDigestFrequency?: boolean
    inAppEnabled?: boolean
    inAppLessonReminders?: boolean
    inAppEventReminders?: boolean
    inAppAnnouncements?: boolean
    inAppGroupUpdates?: boolean
    quietHoursEnabled?: boolean
    quietHoursStart?: boolean
    quietHoursEnd?: boolean
    quietHoursTimezone?: boolean
    preferredDays?: boolean
    lessonReminderDays?: boolean
    lessonReminderTime?: boolean
    eventReminderHours?: boolean
    batchNotifications?: boolean
    maxNotificationsPerDay?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationPreferenceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "emailEnabled" | "emailLessonReminders" | "emailEventReminders" | "emailAnnouncements" | "emailGroupUpdates" | "emailDigest" | "emailDigestFrequency" | "inAppEnabled" | "inAppLessonReminders" | "inAppEventReminders" | "inAppAnnouncements" | "inAppGroupUpdates" | "quietHoursEnabled" | "quietHoursStart" | "quietHoursEnd" | "quietHoursTimezone" | "preferredDays" | "lessonReminderDays" | "lessonReminderTime" | "eventReminderHours" | "batchNotifications" | "maxNotificationsPerDay" | "createdAt" | "updatedAt", ExtArgs["result"]["notificationPreference"]>
  export type NotificationPreferenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationPreferenceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationPreferenceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPreferencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationPreference"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      emailEnabled: boolean
      emailLessonReminders: boolean
      emailEventReminders: boolean
      emailAnnouncements: boolean
      emailGroupUpdates: boolean
      emailDigest: boolean
      emailDigestFrequency: $Enums.DigestFrequency
      inAppEnabled: boolean
      inAppLessonReminders: boolean
      inAppEventReminders: boolean
      inAppAnnouncements: boolean
      inAppGroupUpdates: boolean
      quietHoursEnabled: boolean
      quietHoursStart: string | null
      quietHoursEnd: string | null
      quietHoursTimezone: string
      preferredDays: Prisma.JsonValue | null
      lessonReminderDays: number
      lessonReminderTime: string
      eventReminderHours: number
      batchNotifications: boolean
      maxNotificationsPerDay: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notificationPreference"]>
    composites: {}
  }

  type NotificationPreferenceGetPayload<S extends boolean | null | undefined | NotificationPreferenceDefaultArgs> = $Result.GetResult<Prisma.$NotificationPreferencePayload, S>

  type NotificationPreferenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationPreferenceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationPreferenceCountAggregateInputType | true
    }

  export interface NotificationPreferenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationPreference'], meta: { name: 'NotificationPreference' } }
    /**
     * Find zero or one NotificationPreference that matches the filter.
     * @param {NotificationPreferenceFindUniqueArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationPreferenceFindUniqueArgs>(args: SelectSubset<T, NotificationPreferenceFindUniqueArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NotificationPreference that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationPreferenceFindUniqueOrThrowArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationPreferenceFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationPreference that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceFindFirstArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationPreferenceFindFirstArgs>(args?: SelectSubset<T, NotificationPreferenceFindFirstArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationPreference that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceFindFirstOrThrowArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationPreferenceFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationPreferenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NotificationPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationPreferences
     * const notificationPreferences = await prisma.notificationPreference.findMany()
     * 
     * // Get first 10 NotificationPreferences
     * const notificationPreferences = await prisma.notificationPreference.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationPreferenceWithIdOnly = await prisma.notificationPreference.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationPreferenceFindManyArgs>(args?: SelectSubset<T, NotificationPreferenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NotificationPreference.
     * @param {NotificationPreferenceCreateArgs} args - Arguments to create a NotificationPreference.
     * @example
     * // Create one NotificationPreference
     * const NotificationPreference = await prisma.notificationPreference.create({
     *   data: {
     *     // ... data to create a NotificationPreference
     *   }
     * })
     * 
     */
    create<T extends NotificationPreferenceCreateArgs>(args: SelectSubset<T, NotificationPreferenceCreateArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NotificationPreferences.
     * @param {NotificationPreferenceCreateManyArgs} args - Arguments to create many NotificationPreferences.
     * @example
     * // Create many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationPreferenceCreateManyArgs>(args?: SelectSubset<T, NotificationPreferenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationPreferences and returns the data saved in the database.
     * @param {NotificationPreferenceCreateManyAndReturnArgs} args - Arguments to create many NotificationPreferences.
     * @example
     * // Create many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationPreferences and only return the `id`
     * const notificationPreferenceWithIdOnly = await prisma.notificationPreference.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationPreferenceCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationPreferenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NotificationPreference.
     * @param {NotificationPreferenceDeleteArgs} args - Arguments to delete one NotificationPreference.
     * @example
     * // Delete one NotificationPreference
     * const NotificationPreference = await prisma.notificationPreference.delete({
     *   where: {
     *     // ... filter to delete one NotificationPreference
     *   }
     * })
     * 
     */
    delete<T extends NotificationPreferenceDeleteArgs>(args: SelectSubset<T, NotificationPreferenceDeleteArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NotificationPreference.
     * @param {NotificationPreferenceUpdateArgs} args - Arguments to update one NotificationPreference.
     * @example
     * // Update one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationPreferenceUpdateArgs>(args: SelectSubset<T, NotificationPreferenceUpdateArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NotificationPreferences.
     * @param {NotificationPreferenceDeleteManyArgs} args - Arguments to filter NotificationPreferences to delete.
     * @example
     * // Delete a few NotificationPreferences
     * const { count } = await prisma.notificationPreference.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationPreferenceDeleteManyArgs>(args?: SelectSubset<T, NotificationPreferenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationPreferenceUpdateManyArgs>(args: SelectSubset<T, NotificationPreferenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationPreferences and returns the data updated in the database.
     * @param {NotificationPreferenceUpdateManyAndReturnArgs} args - Arguments to update many NotificationPreferences.
     * @example
     * // Update many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NotificationPreferences and only return the `id`
     * const notificationPreferenceWithIdOnly = await prisma.notificationPreference.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationPreferenceUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationPreferenceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NotificationPreference.
     * @param {NotificationPreferenceUpsertArgs} args - Arguments to update or create a NotificationPreference.
     * @example
     * // Update or create a NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.upsert({
     *   create: {
     *     // ... data to create a NotificationPreference
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationPreference we want to update
     *   }
     * })
     */
    upsert<T extends NotificationPreferenceUpsertArgs>(args: SelectSubset<T, NotificationPreferenceUpsertArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NotificationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceCountArgs} args - Arguments to filter NotificationPreferences to count.
     * @example
     * // Count the number of NotificationPreferences
     * const count = await prisma.notificationPreference.count({
     *   where: {
     *     // ... the filter for the NotificationPreferences we want to count
     *   }
     * })
    **/
    count<T extends NotificationPreferenceCountArgs>(
      args?: Subset<T, NotificationPreferenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationPreferenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationPreferenceAggregateArgs>(args: Subset<T, NotificationPreferenceAggregateArgs>): Prisma.PrismaPromise<GetNotificationPreferenceAggregateType<T>>

    /**
     * Group by NotificationPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationPreferenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationPreferenceGroupByArgs['orderBy'] }
        : { orderBy?: NotificationPreferenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationPreferenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationPreferenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationPreference model
   */
  readonly fields: NotificationPreferenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationPreference.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationPreferenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationPreference model
   */
  interface NotificationPreferenceFieldRefs {
    readonly id: FieldRef<"NotificationPreference", 'String'>
    readonly userId: FieldRef<"NotificationPreference", 'String'>
    readonly emailEnabled: FieldRef<"NotificationPreference", 'Boolean'>
    readonly emailLessonReminders: FieldRef<"NotificationPreference", 'Boolean'>
    readonly emailEventReminders: FieldRef<"NotificationPreference", 'Boolean'>
    readonly emailAnnouncements: FieldRef<"NotificationPreference", 'Boolean'>
    readonly emailGroupUpdates: FieldRef<"NotificationPreference", 'Boolean'>
    readonly emailDigest: FieldRef<"NotificationPreference", 'Boolean'>
    readonly emailDigestFrequency: FieldRef<"NotificationPreference", 'DigestFrequency'>
    readonly inAppEnabled: FieldRef<"NotificationPreference", 'Boolean'>
    readonly inAppLessonReminders: FieldRef<"NotificationPreference", 'Boolean'>
    readonly inAppEventReminders: FieldRef<"NotificationPreference", 'Boolean'>
    readonly inAppAnnouncements: FieldRef<"NotificationPreference", 'Boolean'>
    readonly inAppGroupUpdates: FieldRef<"NotificationPreference", 'Boolean'>
    readonly quietHoursEnabled: FieldRef<"NotificationPreference", 'Boolean'>
    readonly quietHoursStart: FieldRef<"NotificationPreference", 'String'>
    readonly quietHoursEnd: FieldRef<"NotificationPreference", 'String'>
    readonly quietHoursTimezone: FieldRef<"NotificationPreference", 'String'>
    readonly preferredDays: FieldRef<"NotificationPreference", 'Json'>
    readonly lessonReminderDays: FieldRef<"NotificationPreference", 'Int'>
    readonly lessonReminderTime: FieldRef<"NotificationPreference", 'String'>
    readonly eventReminderHours: FieldRef<"NotificationPreference", 'Int'>
    readonly batchNotifications: FieldRef<"NotificationPreference", 'Boolean'>
    readonly maxNotificationsPerDay: FieldRef<"NotificationPreference", 'Int'>
    readonly createdAt: FieldRef<"NotificationPreference", 'DateTime'>
    readonly updatedAt: FieldRef<"NotificationPreference", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationPreference findUnique
   */
  export type NotificationPreferenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference findUniqueOrThrow
   */
  export type NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference findFirst
   */
  export type NotificationPreferenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationPreferences.
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationPreferences.
     */
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[]
  }

  /**
   * NotificationPreference findFirstOrThrow
   */
  export type NotificationPreferenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationPreferences.
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationPreferences.
     */
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[]
  }

  /**
   * NotificationPreference findMany
   */
  export type NotificationPreferenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreferences to fetch.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationPreferences.
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[]
  }

  /**
   * NotificationPreference create
   */
  export type NotificationPreferenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationPreference.
     */
    data: XOR<NotificationPreferenceCreateInput, NotificationPreferenceUncheckedCreateInput>
  }

  /**
   * NotificationPreference createMany
   */
  export type NotificationPreferenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationPreferences.
     */
    data: NotificationPreferenceCreateManyInput | NotificationPreferenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationPreference createManyAndReturn
   */
  export type NotificationPreferenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * The data used to create many NotificationPreferences.
     */
    data: NotificationPreferenceCreateManyInput | NotificationPreferenceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationPreference update
   */
  export type NotificationPreferenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationPreference.
     */
    data: XOR<NotificationPreferenceUpdateInput, NotificationPreferenceUncheckedUpdateInput>
    /**
     * Choose, which NotificationPreference to update.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference updateMany
   */
  export type NotificationPreferenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationPreferences.
     */
    data: XOR<NotificationPreferenceUpdateManyMutationInput, NotificationPreferenceUncheckedUpdateManyInput>
    /**
     * Filter which NotificationPreferences to update
     */
    where?: NotificationPreferenceWhereInput
    /**
     * Limit how many NotificationPreferences to update.
     */
    limit?: number
  }

  /**
   * NotificationPreference updateManyAndReturn
   */
  export type NotificationPreferenceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * The data used to update NotificationPreferences.
     */
    data: XOR<NotificationPreferenceUpdateManyMutationInput, NotificationPreferenceUncheckedUpdateManyInput>
    /**
     * Filter which NotificationPreferences to update
     */
    where?: NotificationPreferenceWhereInput
    /**
     * Limit how many NotificationPreferences to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationPreference upsert
   */
  export type NotificationPreferenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationPreference to update in case it exists.
     */
    where: NotificationPreferenceWhereUniqueInput
    /**
     * In case the NotificationPreference found by the `where` argument doesn't exist, create a new NotificationPreference with this data.
     */
    create: XOR<NotificationPreferenceCreateInput, NotificationPreferenceUncheckedCreateInput>
    /**
     * In case the NotificationPreference was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationPreferenceUpdateInput, NotificationPreferenceUncheckedUpdateInput>
  }

  /**
   * NotificationPreference delete
   */
  export type NotificationPreferenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter which NotificationPreference to delete.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference deleteMany
   */
  export type NotificationPreferenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationPreferences to delete
     */
    where?: NotificationPreferenceWhereInput
    /**
     * Limit how many NotificationPreferences to delete.
     */
    limit?: number
  }

  /**
   * NotificationPreference without action
   */
  export type NotificationPreferenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationAvgAggregateOutputType = {
    retryCount: number | null
    maxRetries: number | null
  }

  export type NotificationSumAggregateOutputType = {
    retryCount: number | null
    maxRetries: number | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    organizationId: string | null
    type: $Enums.NotificationType | null
    title: string | null
    message: string | null
    actionUrl: string | null
    deliveryMethod: $Enums.NotificationDeliveryMethod | null
    priority: $Enums.NotificationPriority | null
    scheduledFor: Date | null
    sentAt: Date | null
    readAt: Date | null
    status: $Enums.NotificationStatus | null
    failureReason: string | null
    retryCount: number | null
    maxRetries: number | null
    groupId: string | null
    lessonId: string | null
    eventId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    organizationId: string | null
    type: $Enums.NotificationType | null
    title: string | null
    message: string | null
    actionUrl: string | null
    deliveryMethod: $Enums.NotificationDeliveryMethod | null
    priority: $Enums.NotificationPriority | null
    scheduledFor: Date | null
    sentAt: Date | null
    readAt: Date | null
    status: $Enums.NotificationStatus | null
    failureReason: string | null
    retryCount: number | null
    maxRetries: number | null
    groupId: string | null
    lessonId: string | null
    eventId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    organizationId: number
    type: number
    title: number
    message: number
    actionUrl: number
    deliveryMethod: number
    priority: number
    scheduledFor: number
    sentAt: number
    readAt: number
    status: number
    deliveryStatus: number
    failureReason: number
    retryCount: number
    maxRetries: number
    groupId: number
    lessonId: number
    eventId: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationAvgAggregateInputType = {
    retryCount?: true
    maxRetries?: true
  }

  export type NotificationSumAggregateInputType = {
    retryCount?: true
    maxRetries?: true
  }

  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    organizationId?: true
    type?: true
    title?: true
    message?: true
    actionUrl?: true
    deliveryMethod?: true
    priority?: true
    scheduledFor?: true
    sentAt?: true
    readAt?: true
    status?: true
    failureReason?: true
    retryCount?: true
    maxRetries?: true
    groupId?: true
    lessonId?: true
    eventId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    organizationId?: true
    type?: true
    title?: true
    message?: true
    actionUrl?: true
    deliveryMethod?: true
    priority?: true
    scheduledFor?: true
    sentAt?: true
    readAt?: true
    status?: true
    failureReason?: true
    retryCount?: true
    maxRetries?: true
    groupId?: true
    lessonId?: true
    eventId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    organizationId?: true
    type?: true
    title?: true
    message?: true
    actionUrl?: true
    deliveryMethod?: true
    priority?: true
    scheduledFor?: true
    sentAt?: true
    readAt?: true
    status?: true
    deliveryStatus?: true
    failureReason?: true
    retryCount?: true
    maxRetries?: true
    groupId?: true
    lessonId?: true
    eventId?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _avg?: NotificationAvgAggregateInputType
    _sum?: NotificationSumAggregateInputType
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    organizationId: string
    type: $Enums.NotificationType
    title: string
    message: string
    actionUrl: string | null
    deliveryMethod: $Enums.NotificationDeliveryMethod
    priority: $Enums.NotificationPriority
    scheduledFor: Date | null
    sentAt: Date | null
    readAt: Date | null
    status: $Enums.NotificationStatus
    deliveryStatus: JsonValue | null
    failureReason: string | null
    retryCount: number
    maxRetries: number
    groupId: string | null
    lessonId: string | null
    eventId: string | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    organizationId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    actionUrl?: boolean
    deliveryMethod?: boolean
    priority?: boolean
    scheduledFor?: boolean
    sentAt?: boolean
    readAt?: boolean
    status?: boolean
    deliveryStatus?: boolean
    failureReason?: boolean
    retryCount?: boolean
    maxRetries?: boolean
    groupId?: boolean
    lessonId?: boolean
    eventId?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    organizationId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    actionUrl?: boolean
    deliveryMethod?: boolean
    priority?: boolean
    scheduledFor?: boolean
    sentAt?: boolean
    readAt?: boolean
    status?: boolean
    deliveryStatus?: boolean
    failureReason?: boolean
    retryCount?: boolean
    maxRetries?: boolean
    groupId?: boolean
    lessonId?: boolean
    eventId?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    organizationId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    actionUrl?: boolean
    deliveryMethod?: boolean
    priority?: boolean
    scheduledFor?: boolean
    sentAt?: boolean
    readAt?: boolean
    status?: boolean
    deliveryStatus?: boolean
    failureReason?: boolean
    retryCount?: boolean
    maxRetries?: boolean
    groupId?: boolean
    lessonId?: boolean
    eventId?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    organizationId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    actionUrl?: boolean
    deliveryMethod?: boolean
    priority?: boolean
    scheduledFor?: boolean
    sentAt?: boolean
    readAt?: boolean
    status?: boolean
    deliveryStatus?: boolean
    failureReason?: boolean
    retryCount?: boolean
    maxRetries?: boolean
    groupId?: boolean
    lessonId?: boolean
    eventId?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "organizationId" | "type" | "title" | "message" | "actionUrl" | "deliveryMethod" | "priority" | "scheduledFor" | "sentAt" | "readAt" | "status" | "deliveryStatus" | "failureReason" | "retryCount" | "maxRetries" | "groupId" | "lessonId" | "eventId" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      organizationId: string
      type: $Enums.NotificationType
      title: string
      message: string
      actionUrl: string | null
      deliveryMethod: $Enums.NotificationDeliveryMethod
      priority: $Enums.NotificationPriority
      scheduledFor: Date | null
      sentAt: Date | null
      readAt: Date | null
      status: $Enums.NotificationStatus
      deliveryStatus: Prisma.JsonValue | null
      failureReason: string | null
      retryCount: number
      maxRetries: number
      groupId: string | null
      lessonId: string | null
      eventId: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly organizationId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly actionUrl: FieldRef<"Notification", 'String'>
    readonly deliveryMethod: FieldRef<"Notification", 'NotificationDeliveryMethod'>
    readonly priority: FieldRef<"Notification", 'NotificationPriority'>
    readonly scheduledFor: FieldRef<"Notification", 'DateTime'>
    readonly sentAt: FieldRef<"Notification", 'DateTime'>
    readonly readAt: FieldRef<"Notification", 'DateTime'>
    readonly status: FieldRef<"Notification", 'NotificationStatus'>
    readonly deliveryStatus: FieldRef<"Notification", 'Json'>
    readonly failureReason: FieldRef<"Notification", 'String'>
    readonly retryCount: FieldRef<"Notification", 'Int'>
    readonly maxRetries: FieldRef<"Notification", 'Int'>
    readonly groupId: FieldRef<"Notification", 'String'>
    readonly lessonId: FieldRef<"Notification", 'String'>
    readonly eventId: FieldRef<"Notification", 'String'>
    readonly metadata: FieldRef<"Notification", 'Json'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly updatedAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model NotificationSchedule
   */

  export type AggregateNotificationSchedule = {
    _count: NotificationScheduleCountAggregateOutputType | null
    _avg: NotificationScheduleAvgAggregateOutputType | null
    _sum: NotificationScheduleSumAggregateOutputType | null
    _min: NotificationScheduleMinAggregateOutputType | null
    _max: NotificationScheduleMaxAggregateOutputType | null
  }

  export type NotificationScheduleAvgAggregateOutputType = {
    dayOfWeek: number | null
    dayOfMonth: number | null
    offsetDays: number | null
    offsetHours: number | null
  }

  export type NotificationScheduleSumAggregateOutputType = {
    dayOfWeek: number | null
    dayOfMonth: number | null
    offsetDays: number | null
    offsetHours: number | null
  }

  export type NotificationScheduleMinAggregateOutputType = {
    id: string | null
    organizationId: string | null
    groupId: string | null
    name: string | null
    description: string | null
    notificationType: $Enums.NotificationType | null
    title: string | null
    message: string | null
    actionUrl: string | null
    frequency: $Enums.ScheduleFrequency | null
    dayOfWeek: number | null
    dayOfMonth: number | null
    timeOfDay: string | null
    timezone: string | null
    offsetDays: number | null
    offsetHours: number | null
    isActive: boolean | null
    lastRunAt: Date | null
    nextRunAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationScheduleMaxAggregateOutputType = {
    id: string | null
    organizationId: string | null
    groupId: string | null
    name: string | null
    description: string | null
    notificationType: $Enums.NotificationType | null
    title: string | null
    message: string | null
    actionUrl: string | null
    frequency: $Enums.ScheduleFrequency | null
    dayOfWeek: number | null
    dayOfMonth: number | null
    timeOfDay: string | null
    timezone: string | null
    offsetDays: number | null
    offsetHours: number | null
    isActive: boolean | null
    lastRunAt: Date | null
    nextRunAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationScheduleCountAggregateOutputType = {
    id: number
    organizationId: number
    groupId: number
    name: number
    description: number
    notificationType: number
    title: number
    message: number
    actionUrl: number
    frequency: number
    dayOfWeek: number
    dayOfMonth: number
    timeOfDay: number
    timezone: number
    offsetDays: number
    offsetHours: number
    targetRoles: number
    targetUserIds: number
    isActive: number
    lastRunAt: number
    nextRunAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationScheduleAvgAggregateInputType = {
    dayOfWeek?: true
    dayOfMonth?: true
    offsetDays?: true
    offsetHours?: true
  }

  export type NotificationScheduleSumAggregateInputType = {
    dayOfWeek?: true
    dayOfMonth?: true
    offsetDays?: true
    offsetHours?: true
  }

  export type NotificationScheduleMinAggregateInputType = {
    id?: true
    organizationId?: true
    groupId?: true
    name?: true
    description?: true
    notificationType?: true
    title?: true
    message?: true
    actionUrl?: true
    frequency?: true
    dayOfWeek?: true
    dayOfMonth?: true
    timeOfDay?: true
    timezone?: true
    offsetDays?: true
    offsetHours?: true
    isActive?: true
    lastRunAt?: true
    nextRunAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationScheduleMaxAggregateInputType = {
    id?: true
    organizationId?: true
    groupId?: true
    name?: true
    description?: true
    notificationType?: true
    title?: true
    message?: true
    actionUrl?: true
    frequency?: true
    dayOfWeek?: true
    dayOfMonth?: true
    timeOfDay?: true
    timezone?: true
    offsetDays?: true
    offsetHours?: true
    isActive?: true
    lastRunAt?: true
    nextRunAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationScheduleCountAggregateInputType = {
    id?: true
    organizationId?: true
    groupId?: true
    name?: true
    description?: true
    notificationType?: true
    title?: true
    message?: true
    actionUrl?: true
    frequency?: true
    dayOfWeek?: true
    dayOfMonth?: true
    timeOfDay?: true
    timezone?: true
    offsetDays?: true
    offsetHours?: true
    targetRoles?: true
    targetUserIds?: true
    isActive?: true
    lastRunAt?: true
    nextRunAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationSchedule to aggregate.
     */
    where?: NotificationScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationSchedules to fetch.
     */
    orderBy?: NotificationScheduleOrderByWithRelationInput | NotificationScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationSchedules
    **/
    _count?: true | NotificationScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationScheduleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationScheduleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationScheduleMaxAggregateInputType
  }

  export type GetNotificationScheduleAggregateType<T extends NotificationScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationSchedule[P]>
      : GetScalarType<T[P], AggregateNotificationSchedule[P]>
  }




  export type NotificationScheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationScheduleWhereInput
    orderBy?: NotificationScheduleOrderByWithAggregationInput | NotificationScheduleOrderByWithAggregationInput[]
    by: NotificationScheduleScalarFieldEnum[] | NotificationScheduleScalarFieldEnum
    having?: NotificationScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationScheduleCountAggregateInputType | true
    _avg?: NotificationScheduleAvgAggregateInputType
    _sum?: NotificationScheduleSumAggregateInputType
    _min?: NotificationScheduleMinAggregateInputType
    _max?: NotificationScheduleMaxAggregateInputType
  }

  export type NotificationScheduleGroupByOutputType = {
    id: string
    organizationId: string
    groupId: string | null
    name: string
    description: string | null
    notificationType: $Enums.NotificationType
    title: string
    message: string
    actionUrl: string | null
    frequency: $Enums.ScheduleFrequency
    dayOfWeek: number | null
    dayOfMonth: number | null
    timeOfDay: string
    timezone: string
    offsetDays: number
    offsetHours: number
    targetRoles: JsonValue | null
    targetUserIds: JsonValue | null
    isActive: boolean
    lastRunAt: Date | null
    nextRunAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: NotificationScheduleCountAggregateOutputType | null
    _avg: NotificationScheduleAvgAggregateOutputType | null
    _sum: NotificationScheduleSumAggregateOutputType | null
    _min: NotificationScheduleMinAggregateOutputType | null
    _max: NotificationScheduleMaxAggregateOutputType | null
  }

  type GetNotificationScheduleGroupByPayload<T extends NotificationScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationScheduleGroupByOutputType[P]>
        }
      >
    >


  export type NotificationScheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    groupId?: boolean
    name?: boolean
    description?: boolean
    notificationType?: boolean
    title?: boolean
    message?: boolean
    actionUrl?: boolean
    frequency?: boolean
    dayOfWeek?: boolean
    dayOfMonth?: boolean
    timeOfDay?: boolean
    timezone?: boolean
    offsetDays?: boolean
    offsetHours?: boolean
    targetRoles?: boolean
    targetUserIds?: boolean
    isActive?: boolean
    lastRunAt?: boolean
    nextRunAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["notificationSchedule"]>

  export type NotificationScheduleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    groupId?: boolean
    name?: boolean
    description?: boolean
    notificationType?: boolean
    title?: boolean
    message?: boolean
    actionUrl?: boolean
    frequency?: boolean
    dayOfWeek?: boolean
    dayOfMonth?: boolean
    timeOfDay?: boolean
    timezone?: boolean
    offsetDays?: boolean
    offsetHours?: boolean
    targetRoles?: boolean
    targetUserIds?: boolean
    isActive?: boolean
    lastRunAt?: boolean
    nextRunAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["notificationSchedule"]>

  export type NotificationScheduleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    groupId?: boolean
    name?: boolean
    description?: boolean
    notificationType?: boolean
    title?: boolean
    message?: boolean
    actionUrl?: boolean
    frequency?: boolean
    dayOfWeek?: boolean
    dayOfMonth?: boolean
    timeOfDay?: boolean
    timezone?: boolean
    offsetDays?: boolean
    offsetHours?: boolean
    targetRoles?: boolean
    targetUserIds?: boolean
    isActive?: boolean
    lastRunAt?: boolean
    nextRunAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["notificationSchedule"]>

  export type NotificationScheduleSelectScalar = {
    id?: boolean
    organizationId?: boolean
    groupId?: boolean
    name?: boolean
    description?: boolean
    notificationType?: boolean
    title?: boolean
    message?: boolean
    actionUrl?: boolean
    frequency?: boolean
    dayOfWeek?: boolean
    dayOfMonth?: boolean
    timeOfDay?: boolean
    timezone?: boolean
    offsetDays?: boolean
    offsetHours?: boolean
    targetRoles?: boolean
    targetUserIds?: boolean
    isActive?: boolean
    lastRunAt?: boolean
    nextRunAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationScheduleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organizationId" | "groupId" | "name" | "description" | "notificationType" | "title" | "message" | "actionUrl" | "frequency" | "dayOfWeek" | "dayOfMonth" | "timeOfDay" | "timezone" | "offsetDays" | "offsetHours" | "targetRoles" | "targetUserIds" | "isActive" | "lastRunAt" | "nextRunAt" | "createdAt" | "updatedAt", ExtArgs["result"]["notificationSchedule"]>

  export type $NotificationSchedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationSchedule"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organizationId: string
      groupId: string | null
      name: string
      description: string | null
      notificationType: $Enums.NotificationType
      title: string
      message: string
      actionUrl: string | null
      frequency: $Enums.ScheduleFrequency
      dayOfWeek: number | null
      dayOfMonth: number | null
      timeOfDay: string
      timezone: string
      offsetDays: number
      offsetHours: number
      targetRoles: Prisma.JsonValue | null
      targetUserIds: Prisma.JsonValue | null
      isActive: boolean
      lastRunAt: Date | null
      nextRunAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notificationSchedule"]>
    composites: {}
  }

  type NotificationScheduleGetPayload<S extends boolean | null | undefined | NotificationScheduleDefaultArgs> = $Result.GetResult<Prisma.$NotificationSchedulePayload, S>

  type NotificationScheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationScheduleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationScheduleCountAggregateInputType | true
    }

  export interface NotificationScheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationSchedule'], meta: { name: 'NotificationSchedule' } }
    /**
     * Find zero or one NotificationSchedule that matches the filter.
     * @param {NotificationScheduleFindUniqueArgs} args - Arguments to find a NotificationSchedule
     * @example
     * // Get one NotificationSchedule
     * const notificationSchedule = await prisma.notificationSchedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationScheduleFindUniqueArgs>(args: SelectSubset<T, NotificationScheduleFindUniqueArgs<ExtArgs>>): Prisma__NotificationScheduleClient<$Result.GetResult<Prisma.$NotificationSchedulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NotificationSchedule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationScheduleFindUniqueOrThrowArgs} args - Arguments to find a NotificationSchedule
     * @example
     * // Get one NotificationSchedule
     * const notificationSchedule = await prisma.notificationSchedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationScheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationScheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationScheduleClient<$Result.GetResult<Prisma.$NotificationSchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationSchedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationScheduleFindFirstArgs} args - Arguments to find a NotificationSchedule
     * @example
     * // Get one NotificationSchedule
     * const notificationSchedule = await prisma.notificationSchedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationScheduleFindFirstArgs>(args?: SelectSubset<T, NotificationScheduleFindFirstArgs<ExtArgs>>): Prisma__NotificationScheduleClient<$Result.GetResult<Prisma.$NotificationSchedulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationSchedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationScheduleFindFirstOrThrowArgs} args - Arguments to find a NotificationSchedule
     * @example
     * // Get one NotificationSchedule
     * const notificationSchedule = await prisma.notificationSchedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationScheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationScheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationScheduleClient<$Result.GetResult<Prisma.$NotificationSchedulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NotificationSchedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationSchedules
     * const notificationSchedules = await prisma.notificationSchedule.findMany()
     * 
     * // Get first 10 NotificationSchedules
     * const notificationSchedules = await prisma.notificationSchedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationScheduleWithIdOnly = await prisma.notificationSchedule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationScheduleFindManyArgs>(args?: SelectSubset<T, NotificationScheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationSchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NotificationSchedule.
     * @param {NotificationScheduleCreateArgs} args - Arguments to create a NotificationSchedule.
     * @example
     * // Create one NotificationSchedule
     * const NotificationSchedule = await prisma.notificationSchedule.create({
     *   data: {
     *     // ... data to create a NotificationSchedule
     *   }
     * })
     * 
     */
    create<T extends NotificationScheduleCreateArgs>(args: SelectSubset<T, NotificationScheduleCreateArgs<ExtArgs>>): Prisma__NotificationScheduleClient<$Result.GetResult<Prisma.$NotificationSchedulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NotificationSchedules.
     * @param {NotificationScheduleCreateManyArgs} args - Arguments to create many NotificationSchedules.
     * @example
     * // Create many NotificationSchedules
     * const notificationSchedule = await prisma.notificationSchedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationScheduleCreateManyArgs>(args?: SelectSubset<T, NotificationScheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationSchedules and returns the data saved in the database.
     * @param {NotificationScheduleCreateManyAndReturnArgs} args - Arguments to create many NotificationSchedules.
     * @example
     * // Create many NotificationSchedules
     * const notificationSchedule = await prisma.notificationSchedule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationSchedules and only return the `id`
     * const notificationScheduleWithIdOnly = await prisma.notificationSchedule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationScheduleCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationScheduleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationSchedulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NotificationSchedule.
     * @param {NotificationScheduleDeleteArgs} args - Arguments to delete one NotificationSchedule.
     * @example
     * // Delete one NotificationSchedule
     * const NotificationSchedule = await prisma.notificationSchedule.delete({
     *   where: {
     *     // ... filter to delete one NotificationSchedule
     *   }
     * })
     * 
     */
    delete<T extends NotificationScheduleDeleteArgs>(args: SelectSubset<T, NotificationScheduleDeleteArgs<ExtArgs>>): Prisma__NotificationScheduleClient<$Result.GetResult<Prisma.$NotificationSchedulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NotificationSchedule.
     * @param {NotificationScheduleUpdateArgs} args - Arguments to update one NotificationSchedule.
     * @example
     * // Update one NotificationSchedule
     * const notificationSchedule = await prisma.notificationSchedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationScheduleUpdateArgs>(args: SelectSubset<T, NotificationScheduleUpdateArgs<ExtArgs>>): Prisma__NotificationScheduleClient<$Result.GetResult<Prisma.$NotificationSchedulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NotificationSchedules.
     * @param {NotificationScheduleDeleteManyArgs} args - Arguments to filter NotificationSchedules to delete.
     * @example
     * // Delete a few NotificationSchedules
     * const { count } = await prisma.notificationSchedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationScheduleDeleteManyArgs>(args?: SelectSubset<T, NotificationScheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationSchedules
     * const notificationSchedule = await prisma.notificationSchedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationScheduleUpdateManyArgs>(args: SelectSubset<T, NotificationScheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationSchedules and returns the data updated in the database.
     * @param {NotificationScheduleUpdateManyAndReturnArgs} args - Arguments to update many NotificationSchedules.
     * @example
     * // Update many NotificationSchedules
     * const notificationSchedule = await prisma.notificationSchedule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NotificationSchedules and only return the `id`
     * const notificationScheduleWithIdOnly = await prisma.notificationSchedule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationScheduleUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationScheduleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationSchedulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NotificationSchedule.
     * @param {NotificationScheduleUpsertArgs} args - Arguments to update or create a NotificationSchedule.
     * @example
     * // Update or create a NotificationSchedule
     * const notificationSchedule = await prisma.notificationSchedule.upsert({
     *   create: {
     *     // ... data to create a NotificationSchedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationSchedule we want to update
     *   }
     * })
     */
    upsert<T extends NotificationScheduleUpsertArgs>(args: SelectSubset<T, NotificationScheduleUpsertArgs<ExtArgs>>): Prisma__NotificationScheduleClient<$Result.GetResult<Prisma.$NotificationSchedulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NotificationSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationScheduleCountArgs} args - Arguments to filter NotificationSchedules to count.
     * @example
     * // Count the number of NotificationSchedules
     * const count = await prisma.notificationSchedule.count({
     *   where: {
     *     // ... the filter for the NotificationSchedules we want to count
     *   }
     * })
    **/
    count<T extends NotificationScheduleCountArgs>(
      args?: Subset<T, NotificationScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationScheduleAggregateArgs>(args: Subset<T, NotificationScheduleAggregateArgs>): Prisma.PrismaPromise<GetNotificationScheduleAggregateType<T>>

    /**
     * Group by NotificationSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationScheduleGroupByArgs['orderBy'] }
        : { orderBy?: NotificationScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationSchedule model
   */
  readonly fields: NotificationScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationSchedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationScheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationSchedule model
   */
  interface NotificationScheduleFieldRefs {
    readonly id: FieldRef<"NotificationSchedule", 'String'>
    readonly organizationId: FieldRef<"NotificationSchedule", 'String'>
    readonly groupId: FieldRef<"NotificationSchedule", 'String'>
    readonly name: FieldRef<"NotificationSchedule", 'String'>
    readonly description: FieldRef<"NotificationSchedule", 'String'>
    readonly notificationType: FieldRef<"NotificationSchedule", 'NotificationType'>
    readonly title: FieldRef<"NotificationSchedule", 'String'>
    readonly message: FieldRef<"NotificationSchedule", 'String'>
    readonly actionUrl: FieldRef<"NotificationSchedule", 'String'>
    readonly frequency: FieldRef<"NotificationSchedule", 'ScheduleFrequency'>
    readonly dayOfWeek: FieldRef<"NotificationSchedule", 'Int'>
    readonly dayOfMonth: FieldRef<"NotificationSchedule", 'Int'>
    readonly timeOfDay: FieldRef<"NotificationSchedule", 'String'>
    readonly timezone: FieldRef<"NotificationSchedule", 'String'>
    readonly offsetDays: FieldRef<"NotificationSchedule", 'Int'>
    readonly offsetHours: FieldRef<"NotificationSchedule", 'Int'>
    readonly targetRoles: FieldRef<"NotificationSchedule", 'Json'>
    readonly targetUserIds: FieldRef<"NotificationSchedule", 'Json'>
    readonly isActive: FieldRef<"NotificationSchedule", 'Boolean'>
    readonly lastRunAt: FieldRef<"NotificationSchedule", 'DateTime'>
    readonly nextRunAt: FieldRef<"NotificationSchedule", 'DateTime'>
    readonly createdAt: FieldRef<"NotificationSchedule", 'DateTime'>
    readonly updatedAt: FieldRef<"NotificationSchedule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationSchedule findUnique
   */
  export type NotificationScheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSchedule
     */
    select?: NotificationScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSchedule
     */
    omit?: NotificationScheduleOmit<ExtArgs> | null
    /**
     * Filter, which NotificationSchedule to fetch.
     */
    where: NotificationScheduleWhereUniqueInput
  }

  /**
   * NotificationSchedule findUniqueOrThrow
   */
  export type NotificationScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSchedule
     */
    select?: NotificationScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSchedule
     */
    omit?: NotificationScheduleOmit<ExtArgs> | null
    /**
     * Filter, which NotificationSchedule to fetch.
     */
    where: NotificationScheduleWhereUniqueInput
  }

  /**
   * NotificationSchedule findFirst
   */
  export type NotificationScheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSchedule
     */
    select?: NotificationScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSchedule
     */
    omit?: NotificationScheduleOmit<ExtArgs> | null
    /**
     * Filter, which NotificationSchedule to fetch.
     */
    where?: NotificationScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationSchedules to fetch.
     */
    orderBy?: NotificationScheduleOrderByWithRelationInput | NotificationScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationSchedules.
     */
    cursor?: NotificationScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationSchedules.
     */
    distinct?: NotificationScheduleScalarFieldEnum | NotificationScheduleScalarFieldEnum[]
  }

  /**
   * NotificationSchedule findFirstOrThrow
   */
  export type NotificationScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSchedule
     */
    select?: NotificationScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSchedule
     */
    omit?: NotificationScheduleOmit<ExtArgs> | null
    /**
     * Filter, which NotificationSchedule to fetch.
     */
    where?: NotificationScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationSchedules to fetch.
     */
    orderBy?: NotificationScheduleOrderByWithRelationInput | NotificationScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationSchedules.
     */
    cursor?: NotificationScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationSchedules.
     */
    distinct?: NotificationScheduleScalarFieldEnum | NotificationScheduleScalarFieldEnum[]
  }

  /**
   * NotificationSchedule findMany
   */
  export type NotificationScheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSchedule
     */
    select?: NotificationScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSchedule
     */
    omit?: NotificationScheduleOmit<ExtArgs> | null
    /**
     * Filter, which NotificationSchedules to fetch.
     */
    where?: NotificationScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationSchedules to fetch.
     */
    orderBy?: NotificationScheduleOrderByWithRelationInput | NotificationScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationSchedules.
     */
    cursor?: NotificationScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationSchedules.
     */
    skip?: number
    distinct?: NotificationScheduleScalarFieldEnum | NotificationScheduleScalarFieldEnum[]
  }

  /**
   * NotificationSchedule create
   */
  export type NotificationScheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSchedule
     */
    select?: NotificationScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSchedule
     */
    omit?: NotificationScheduleOmit<ExtArgs> | null
    /**
     * The data needed to create a NotificationSchedule.
     */
    data: XOR<NotificationScheduleCreateInput, NotificationScheduleUncheckedCreateInput>
  }

  /**
   * NotificationSchedule createMany
   */
  export type NotificationScheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationSchedules.
     */
    data: NotificationScheduleCreateManyInput | NotificationScheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationSchedule createManyAndReturn
   */
  export type NotificationScheduleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSchedule
     */
    select?: NotificationScheduleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSchedule
     */
    omit?: NotificationScheduleOmit<ExtArgs> | null
    /**
     * The data used to create many NotificationSchedules.
     */
    data: NotificationScheduleCreateManyInput | NotificationScheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationSchedule update
   */
  export type NotificationScheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSchedule
     */
    select?: NotificationScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSchedule
     */
    omit?: NotificationScheduleOmit<ExtArgs> | null
    /**
     * The data needed to update a NotificationSchedule.
     */
    data: XOR<NotificationScheduleUpdateInput, NotificationScheduleUncheckedUpdateInput>
    /**
     * Choose, which NotificationSchedule to update.
     */
    where: NotificationScheduleWhereUniqueInput
  }

  /**
   * NotificationSchedule updateMany
   */
  export type NotificationScheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationSchedules.
     */
    data: XOR<NotificationScheduleUpdateManyMutationInput, NotificationScheduleUncheckedUpdateManyInput>
    /**
     * Filter which NotificationSchedules to update
     */
    where?: NotificationScheduleWhereInput
    /**
     * Limit how many NotificationSchedules to update.
     */
    limit?: number
  }

  /**
   * NotificationSchedule updateManyAndReturn
   */
  export type NotificationScheduleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSchedule
     */
    select?: NotificationScheduleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSchedule
     */
    omit?: NotificationScheduleOmit<ExtArgs> | null
    /**
     * The data used to update NotificationSchedules.
     */
    data: XOR<NotificationScheduleUpdateManyMutationInput, NotificationScheduleUncheckedUpdateManyInput>
    /**
     * Filter which NotificationSchedules to update
     */
    where?: NotificationScheduleWhereInput
    /**
     * Limit how many NotificationSchedules to update.
     */
    limit?: number
  }

  /**
   * NotificationSchedule upsert
   */
  export type NotificationScheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSchedule
     */
    select?: NotificationScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSchedule
     */
    omit?: NotificationScheduleOmit<ExtArgs> | null
    /**
     * The filter to search for the NotificationSchedule to update in case it exists.
     */
    where: NotificationScheduleWhereUniqueInput
    /**
     * In case the NotificationSchedule found by the `where` argument doesn't exist, create a new NotificationSchedule with this data.
     */
    create: XOR<NotificationScheduleCreateInput, NotificationScheduleUncheckedCreateInput>
    /**
     * In case the NotificationSchedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationScheduleUpdateInput, NotificationScheduleUncheckedUpdateInput>
  }

  /**
   * NotificationSchedule delete
   */
  export type NotificationScheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSchedule
     */
    select?: NotificationScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSchedule
     */
    omit?: NotificationScheduleOmit<ExtArgs> | null
    /**
     * Filter which NotificationSchedule to delete.
     */
    where: NotificationScheduleWhereUniqueInput
  }

  /**
   * NotificationSchedule deleteMany
   */
  export type NotificationScheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationSchedules to delete
     */
    where?: NotificationScheduleWhereInput
    /**
     * Limit how many NotificationSchedules to delete.
     */
    limit?: number
  }

  /**
   * NotificationSchedule without action
   */
  export type NotificationScheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSchedule
     */
    select?: NotificationScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSchedule
     */
    omit?: NotificationScheduleOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const OrganizationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    timezone: 'timezone',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrganizationScalarFieldEnum = (typeof OrganizationScalarFieldEnum)[keyof typeof OrganizationScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    firstName: 'firstName',
    lastName: 'lastName',
    role: 'role',
    organizationId: 'organizationId',
    isActive: 'isActive',
    externalId: 'externalId',
    externalData: 'externalData',
    lastLoginAt: 'lastLoginAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const RefreshTokenScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type RefreshTokenScalarFieldEnum = (typeof RefreshTokenScalarFieldEnum)[keyof typeof RefreshTokenScalarFieldEnum]


  export const GroupScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    organizationId: 'organizationId',
    externalId: 'externalId',
    externalData: 'externalData',
    ageMin: 'ageMin',
    ageMax: 'ageMax',
    grade: 'grade',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GroupScalarFieldEnum = (typeof GroupScalarFieldEnum)[keyof typeof GroupScalarFieldEnum]


  export const GroupMemberScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    groupId: 'groupId',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GroupMemberScalarFieldEnum = (typeof GroupMemberScalarFieldEnum)[keyof typeof GroupMemberScalarFieldEnum]


  export const ExternalIntegrationScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    provider: 'provider',
    status: 'status',
    credentialsEncrypted: 'credentialsEncrypted',
    credentialsIV: 'credentialsIV',
    credentialsTag: 'credentialsTag',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    tokenExpiresAt: 'tokenExpiresAt',
    apiBaseUrl: 'apiBaseUrl',
    apiVersion: 'apiVersion',
    syncEnabled: 'syncEnabled',
    syncFrequency: 'syncFrequency',
    lastSyncAt: 'lastSyncAt',
    lastSyncStatus: 'lastSyncStatus',
    nextSyncAt: 'nextSyncAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExternalIntegrationScalarFieldEnum = (typeof ExternalIntegrationScalarFieldEnum)[keyof typeof ExternalIntegrationScalarFieldEnum]


  export const ExternalGroupMappingScalarFieldEnum: {
    id: 'id',
    integrationId: 'integrationId',
    externalGroupId: 'externalGroupId',
    externalGroupName: 'externalGroupName',
    externalGroupType: 'externalGroupType',
    groupId: 'groupId',
    syncMembers: 'syncMembers',
    syncLeaders: 'syncLeaders',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExternalGroupMappingScalarFieldEnum = (typeof ExternalGroupMappingScalarFieldEnum)[keyof typeof ExternalGroupMappingScalarFieldEnum]


  export const SyncLogScalarFieldEnum: {
    id: 'id',
    integrationId: 'integrationId',
    status: 'status',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    durationMs: 'durationMs',
    peopleAdded: 'peopleAdded',
    peopleUpdated: 'peopleUpdated',
    peopleRemoved: 'peopleRemoved',
    groupsAdded: 'groupsAdded',
    groupsUpdated: 'groupsUpdated',
    groupsSkipped: 'groupsSkipped',
    errorMessage: 'errorMessage',
    errorCode: 'errorCode',
    errorDetails: 'errorDetails',
    metadata: 'metadata'
  };

  export type SyncLogScalarFieldEnum = (typeof SyncLogScalarFieldEnum)[keyof typeof SyncLogScalarFieldEnum]


  export const LessonScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    title: 'title',
    quarter: 'quarter',
    unit: 'unit',
    lessonNumber: 'lessonNumber',
    scripture: 'scripture',
    content: 'content',
    slides: 'slides',
    games: 'games',
    isPublic: 'isPublic',
    isTemplate: 'isTemplate',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LessonScalarFieldEnum = (typeof LessonScalarFieldEnum)[keyof typeof LessonScalarFieldEnum]


  export const LessonGroupScalarFieldEnum: {
    id: 'id',
    lessonId: 'lessonId',
    groupId: 'groupId',
    createdAt: 'createdAt'
  };

  export type LessonGroupScalarFieldEnum = (typeof LessonGroupScalarFieldEnum)[keyof typeof LessonGroupScalarFieldEnum]


  export const AIFilterConfigScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    filterRules: 'filterRules',
    customKeywords: 'customKeywords',
    redirectMessage: 'redirectMessage',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AIFilterConfigScalarFieldEnum = (typeof AIFilterConfigScalarFieldEnum)[keyof typeof AIFilterConfigScalarFieldEnum]


  export const AIFilterMetricScalarFieldEnum: {
    id: 'id',
    filterId: 'filterId',
    organizationId: 'organizationId',
    query: 'query',
    detectedCategory: 'detectedCategory',
    actionTaken: 'actionTaken',
    userId: 'userId',
    groupId: 'groupId',
    featureName: 'featureName',
    leaderNotified: 'leaderNotified',
    leaderResponse: 'leaderResponse',
    resolvedAt: 'resolvedAt',
    createdAt: 'createdAt'
  };

  export type AIFilterMetricScalarFieldEnum = (typeof AIFilterMetricScalarFieldEnum)[keyof typeof AIFilterMetricScalarFieldEnum]


  export const ComparativeThemeScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    themeName: 'themeName',
    description: 'description',
    category: 'category',
    otPassages: 'otPassages',
    ntPassages: 'ntPassages',
    themeNotes: 'themeNotes',
    isPublic: 'isPublic',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ComparativeThemeScalarFieldEnum = (typeof ComparativeThemeScalarFieldEnum)[keyof typeof ComparativeThemeScalarFieldEnum]


  export const ThemeMetricScalarFieldEnum: {
    id: 'id',
    themeId: 'themeId',
    organizationId: 'organizationId',
    viewCount: 'viewCount',
    lastViewedAt: 'lastViewedAt',
    userId: 'userId',
    featureContext: 'featureContext',
    timeSpentMs: 'timeSpentMs',
    usedInLesson: 'usedInLesson',
    lessonId: 'lessonId',
    createdAt: 'createdAt'
  };

  export type ThemeMetricScalarFieldEnum = (typeof ThemeMetricScalarFieldEnum)[keyof typeof ThemeMetricScalarFieldEnum]


  export const NotificationPreferenceScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    emailEnabled: 'emailEnabled',
    emailLessonReminders: 'emailLessonReminders',
    emailEventReminders: 'emailEventReminders',
    emailAnnouncements: 'emailAnnouncements',
    emailGroupUpdates: 'emailGroupUpdates',
    emailDigest: 'emailDigest',
    emailDigestFrequency: 'emailDigestFrequency',
    inAppEnabled: 'inAppEnabled',
    inAppLessonReminders: 'inAppLessonReminders',
    inAppEventReminders: 'inAppEventReminders',
    inAppAnnouncements: 'inAppAnnouncements',
    inAppGroupUpdates: 'inAppGroupUpdates',
    quietHoursEnabled: 'quietHoursEnabled',
    quietHoursStart: 'quietHoursStart',
    quietHoursEnd: 'quietHoursEnd',
    quietHoursTimezone: 'quietHoursTimezone',
    preferredDays: 'preferredDays',
    lessonReminderDays: 'lessonReminderDays',
    lessonReminderTime: 'lessonReminderTime',
    eventReminderHours: 'eventReminderHours',
    batchNotifications: 'batchNotifications',
    maxNotificationsPerDay: 'maxNotificationsPerDay',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationPreferenceScalarFieldEnum = (typeof NotificationPreferenceScalarFieldEnum)[keyof typeof NotificationPreferenceScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    organizationId: 'organizationId',
    type: 'type',
    title: 'title',
    message: 'message',
    actionUrl: 'actionUrl',
    deliveryMethod: 'deliveryMethod',
    priority: 'priority',
    scheduledFor: 'scheduledFor',
    sentAt: 'sentAt',
    readAt: 'readAt',
    status: 'status',
    deliveryStatus: 'deliveryStatus',
    failureReason: 'failureReason',
    retryCount: 'retryCount',
    maxRetries: 'maxRetries',
    groupId: 'groupId',
    lessonId: 'lessonId',
    eventId: 'eventId',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const NotificationScheduleScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    groupId: 'groupId',
    name: 'name',
    description: 'description',
    notificationType: 'notificationType',
    title: 'title',
    message: 'message',
    actionUrl: 'actionUrl',
    frequency: 'frequency',
    dayOfWeek: 'dayOfWeek',
    dayOfMonth: 'dayOfMonth',
    timeOfDay: 'timeOfDay',
    timezone: 'timezone',
    offsetDays: 'offsetDays',
    offsetHours: 'offsetHours',
    targetRoles: 'targetRoles',
    targetUserIds: 'targetUserIds',
    isActive: 'isActive',
    lastRunAt: 'lastRunAt',
    nextRunAt: 'nextRunAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationScheduleScalarFieldEnum = (typeof NotificationScheduleScalarFieldEnum)[keyof typeof NotificationScheduleScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'IntegrationProvider'
   */
  export type EnumIntegrationProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IntegrationProvider'>
    


  /**
   * Reference to a field of type 'IntegrationProvider[]'
   */
  export type ListEnumIntegrationProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IntegrationProvider[]'>
    


  /**
   * Reference to a field of type 'IntegrationStatus'
   */
  export type EnumIntegrationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IntegrationStatus'>
    


  /**
   * Reference to a field of type 'IntegrationStatus[]'
   */
  export type ListEnumIntegrationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IntegrationStatus[]'>
    


  /**
   * Reference to a field of type 'SyncFrequency'
   */
  export type EnumSyncFrequencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SyncFrequency'>
    


  /**
   * Reference to a field of type 'SyncFrequency[]'
   */
  export type ListEnumSyncFrequencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SyncFrequency[]'>
    


  /**
   * Reference to a field of type 'SyncStatus'
   */
  export type EnumSyncStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SyncStatus'>
    


  /**
   * Reference to a field of type 'SyncStatus[]'
   */
  export type ListEnumSyncStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SyncStatus[]'>
    


  /**
   * Reference to a field of type 'FilterCategory'
   */
  export type EnumFilterCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FilterCategory'>
    


  /**
   * Reference to a field of type 'FilterCategory[]'
   */
  export type ListEnumFilterCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FilterCategory[]'>
    


  /**
   * Reference to a field of type 'FilterAction'
   */
  export type EnumFilterActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FilterAction'>
    


  /**
   * Reference to a field of type 'FilterAction[]'
   */
  export type ListEnumFilterActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FilterAction[]'>
    


  /**
   * Reference to a field of type 'DigestFrequency'
   */
  export type EnumDigestFrequencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DigestFrequency'>
    


  /**
   * Reference to a field of type 'DigestFrequency[]'
   */
  export type ListEnumDigestFrequencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DigestFrequency[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'NotificationDeliveryMethod'
   */
  export type EnumNotificationDeliveryMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationDeliveryMethod'>
    


  /**
   * Reference to a field of type 'NotificationDeliveryMethod[]'
   */
  export type ListEnumNotificationDeliveryMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationDeliveryMethod[]'>
    


  /**
   * Reference to a field of type 'NotificationPriority'
   */
  export type EnumNotificationPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationPriority'>
    


  /**
   * Reference to a field of type 'NotificationPriority[]'
   */
  export type ListEnumNotificationPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationPriority[]'>
    


  /**
   * Reference to a field of type 'NotificationStatus'
   */
  export type EnumNotificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationStatus'>
    


  /**
   * Reference to a field of type 'NotificationStatus[]'
   */
  export type ListEnumNotificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationStatus[]'>
    


  /**
   * Reference to a field of type 'ScheduleFrequency'
   */
  export type EnumScheduleFrequencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ScheduleFrequency'>
    


  /**
   * Reference to a field of type 'ScheduleFrequency[]'
   */
  export type ListEnumScheduleFrequencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ScheduleFrequency[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type OrganizationWhereInput = {
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    id?: StringFilter<"Organization"> | string
    name?: StringFilter<"Organization"> | string
    slug?: StringFilter<"Organization"> | string
    timezone?: StringFilter<"Organization"> | string
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    updatedAt?: DateTimeFilter<"Organization"> | Date | string
    users?: UserListRelationFilter
    groups?: GroupListRelationFilter
    integrations?: ExternalIntegrationListRelationFilter
    lessons?: LessonListRelationFilter
    aiFilterConfigs?: AIFilterConfigListRelationFilter
    comparativeThemes?: ComparativeThemeListRelationFilter
  }

  export type OrganizationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    timezone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
    groups?: GroupOrderByRelationAggregateInput
    integrations?: ExternalIntegrationOrderByRelationAggregateInput
    lessons?: LessonOrderByRelationAggregateInput
    aiFilterConfigs?: AIFilterConfigOrderByRelationAggregateInput
    comparativeThemes?: ComparativeThemeOrderByRelationAggregateInput
  }

  export type OrganizationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    name?: StringFilter<"Organization"> | string
    timezone?: StringFilter<"Organization"> | string
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    updatedAt?: DateTimeFilter<"Organization"> | Date | string
    users?: UserListRelationFilter
    groups?: GroupListRelationFilter
    integrations?: ExternalIntegrationListRelationFilter
    lessons?: LessonListRelationFilter
    aiFilterConfigs?: AIFilterConfigListRelationFilter
    comparativeThemes?: ComparativeThemeListRelationFilter
  }, "id" | "slug">

  export type OrganizationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    timezone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrganizationCountOrderByAggregateInput
    _max?: OrganizationMaxOrderByAggregateInput
    _min?: OrganizationMinOrderByAggregateInput
  }

  export type OrganizationScalarWhereWithAggregatesInput = {
    AND?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    OR?: OrganizationScalarWhereWithAggregatesInput[]
    NOT?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Organization"> | string
    name?: StringWithAggregatesFilter<"Organization"> | string
    slug?: StringWithAggregatesFilter<"Organization"> | string
    timezone?: StringWithAggregatesFilter<"Organization"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    organizationId?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    externalId?: StringNullableFilter<"User"> | string | null
    externalData?: JsonNullableFilter<"User">
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    groupMemberships?: GroupMemberListRelationFilter
    refreshTokens?: RefreshTokenListRelationFilter
    notificationPreference?: XOR<NotificationPreferenceNullableScalarRelationFilter, NotificationPreferenceWhereInput> | null
    notifications?: NotificationListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    organizationId?: SortOrder
    isActive?: SortOrder
    externalId?: SortOrderInput | SortOrder
    externalData?: SortOrderInput | SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    groupMemberships?: GroupMemberOrderByRelationAggregateInput
    refreshTokens?: RefreshTokenOrderByRelationAggregateInput
    notificationPreference?: NotificationPreferenceOrderByWithRelationInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    organizationId?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    externalId?: StringNullableFilter<"User"> | string | null
    externalData?: JsonNullableFilter<"User">
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    groupMemberships?: GroupMemberListRelationFilter
    refreshTokens?: RefreshTokenListRelationFilter
    notificationPreference?: XOR<NotificationPreferenceNullableScalarRelationFilter, NotificationPreferenceWhereInput> | null
    notifications?: NotificationListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    organizationId?: SortOrder
    isActive?: SortOrder
    externalId?: SortOrderInput | SortOrder
    externalData?: SortOrderInput | SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    organizationId?: StringWithAggregatesFilter<"User"> | string
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    externalId?: StringNullableWithAggregatesFilter<"User"> | string | null
    externalData?: JsonNullableWithAggregatesFilter<"User">
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type RefreshTokenWhereInput = {
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    userId?: StringFilter<"RefreshToken"> | string
    token?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type RefreshTokenOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type RefreshTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    userId?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type RefreshTokenOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    _count?: RefreshTokenCountOrderByAggregateInput
    _max?: RefreshTokenMaxOrderByAggregateInput
    _min?: RefreshTokenMinOrderByAggregateInput
  }

  export type RefreshTokenScalarWhereWithAggregatesInput = {
    AND?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    OR?: RefreshTokenScalarWhereWithAggregatesInput[]
    NOT?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RefreshToken"> | string
    userId?: StringWithAggregatesFilter<"RefreshToken"> | string
    token?: StringWithAggregatesFilter<"RefreshToken"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
  }

  export type GroupWhereInput = {
    AND?: GroupWhereInput | GroupWhereInput[]
    OR?: GroupWhereInput[]
    NOT?: GroupWhereInput | GroupWhereInput[]
    id?: StringFilter<"Group"> | string
    name?: StringFilter<"Group"> | string
    description?: StringNullableFilter<"Group"> | string | null
    organizationId?: StringFilter<"Group"> | string
    externalId?: StringNullableFilter<"Group"> | string | null
    externalData?: JsonNullableFilter<"Group">
    ageMin?: IntNullableFilter<"Group"> | number | null
    ageMax?: IntNullableFilter<"Group"> | number | null
    grade?: StringNullableFilter<"Group"> | string | null
    isActive?: BoolFilter<"Group"> | boolean
    createdAt?: DateTimeFilter<"Group"> | Date | string
    updatedAt?: DateTimeFilter<"Group"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    members?: GroupMemberListRelationFilter
    mappings?: ExternalGroupMappingListRelationFilter
    lessons?: LessonGroupListRelationFilter
  }

  export type GroupOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    organizationId?: SortOrder
    externalId?: SortOrderInput | SortOrder
    externalData?: SortOrderInput | SortOrder
    ageMin?: SortOrderInput | SortOrder
    ageMax?: SortOrderInput | SortOrder
    grade?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    members?: GroupMemberOrderByRelationAggregateInput
    mappings?: ExternalGroupMappingOrderByRelationAggregateInput
    lessons?: LessonGroupOrderByRelationAggregateInput
  }

  export type GroupWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GroupWhereInput | GroupWhereInput[]
    OR?: GroupWhereInput[]
    NOT?: GroupWhereInput | GroupWhereInput[]
    name?: StringFilter<"Group"> | string
    description?: StringNullableFilter<"Group"> | string | null
    organizationId?: StringFilter<"Group"> | string
    externalId?: StringNullableFilter<"Group"> | string | null
    externalData?: JsonNullableFilter<"Group">
    ageMin?: IntNullableFilter<"Group"> | number | null
    ageMax?: IntNullableFilter<"Group"> | number | null
    grade?: StringNullableFilter<"Group"> | string | null
    isActive?: BoolFilter<"Group"> | boolean
    createdAt?: DateTimeFilter<"Group"> | Date | string
    updatedAt?: DateTimeFilter<"Group"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    members?: GroupMemberListRelationFilter
    mappings?: ExternalGroupMappingListRelationFilter
    lessons?: LessonGroupListRelationFilter
  }, "id">

  export type GroupOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    organizationId?: SortOrder
    externalId?: SortOrderInput | SortOrder
    externalData?: SortOrderInput | SortOrder
    ageMin?: SortOrderInput | SortOrder
    ageMax?: SortOrderInput | SortOrder
    grade?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GroupCountOrderByAggregateInput
    _avg?: GroupAvgOrderByAggregateInput
    _max?: GroupMaxOrderByAggregateInput
    _min?: GroupMinOrderByAggregateInput
    _sum?: GroupSumOrderByAggregateInput
  }

  export type GroupScalarWhereWithAggregatesInput = {
    AND?: GroupScalarWhereWithAggregatesInput | GroupScalarWhereWithAggregatesInput[]
    OR?: GroupScalarWhereWithAggregatesInput[]
    NOT?: GroupScalarWhereWithAggregatesInput | GroupScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Group"> | string
    name?: StringWithAggregatesFilter<"Group"> | string
    description?: StringNullableWithAggregatesFilter<"Group"> | string | null
    organizationId?: StringWithAggregatesFilter<"Group"> | string
    externalId?: StringNullableWithAggregatesFilter<"Group"> | string | null
    externalData?: JsonNullableWithAggregatesFilter<"Group">
    ageMin?: IntNullableWithAggregatesFilter<"Group"> | number | null
    ageMax?: IntNullableWithAggregatesFilter<"Group"> | number | null
    grade?: StringNullableWithAggregatesFilter<"Group"> | string | null
    isActive?: BoolWithAggregatesFilter<"Group"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Group"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Group"> | Date | string
  }

  export type GroupMemberWhereInput = {
    AND?: GroupMemberWhereInput | GroupMemberWhereInput[]
    OR?: GroupMemberWhereInput[]
    NOT?: GroupMemberWhereInput | GroupMemberWhereInput[]
    id?: StringFilter<"GroupMember"> | string
    userId?: StringFilter<"GroupMember"> | string
    groupId?: StringFilter<"GroupMember"> | string
    role?: StringFilter<"GroupMember"> | string
    createdAt?: DateTimeFilter<"GroupMember"> | Date | string
    updatedAt?: DateTimeFilter<"GroupMember"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    group?: XOR<GroupScalarRelationFilter, GroupWhereInput>
  }

  export type GroupMemberOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    group?: GroupOrderByWithRelationInput
  }

  export type GroupMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_groupId?: GroupMemberUserIdGroupIdCompoundUniqueInput
    AND?: GroupMemberWhereInput | GroupMemberWhereInput[]
    OR?: GroupMemberWhereInput[]
    NOT?: GroupMemberWhereInput | GroupMemberWhereInput[]
    userId?: StringFilter<"GroupMember"> | string
    groupId?: StringFilter<"GroupMember"> | string
    role?: StringFilter<"GroupMember"> | string
    createdAt?: DateTimeFilter<"GroupMember"> | Date | string
    updatedAt?: DateTimeFilter<"GroupMember"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    group?: XOR<GroupScalarRelationFilter, GroupWhereInput>
  }, "id" | "userId_groupId">

  export type GroupMemberOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GroupMemberCountOrderByAggregateInput
    _max?: GroupMemberMaxOrderByAggregateInput
    _min?: GroupMemberMinOrderByAggregateInput
  }

  export type GroupMemberScalarWhereWithAggregatesInput = {
    AND?: GroupMemberScalarWhereWithAggregatesInput | GroupMemberScalarWhereWithAggregatesInput[]
    OR?: GroupMemberScalarWhereWithAggregatesInput[]
    NOT?: GroupMemberScalarWhereWithAggregatesInput | GroupMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GroupMember"> | string
    userId?: StringWithAggregatesFilter<"GroupMember"> | string
    groupId?: StringWithAggregatesFilter<"GroupMember"> | string
    role?: StringWithAggregatesFilter<"GroupMember"> | string
    createdAt?: DateTimeWithAggregatesFilter<"GroupMember"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GroupMember"> | Date | string
  }

  export type ExternalIntegrationWhereInput = {
    AND?: ExternalIntegrationWhereInput | ExternalIntegrationWhereInput[]
    OR?: ExternalIntegrationWhereInput[]
    NOT?: ExternalIntegrationWhereInput | ExternalIntegrationWhereInput[]
    id?: StringFilter<"ExternalIntegration"> | string
    organizationId?: StringFilter<"ExternalIntegration"> | string
    provider?: EnumIntegrationProviderFilter<"ExternalIntegration"> | $Enums.IntegrationProvider
    status?: EnumIntegrationStatusFilter<"ExternalIntegration"> | $Enums.IntegrationStatus
    credentialsEncrypted?: StringFilter<"ExternalIntegration"> | string
    credentialsIV?: StringFilter<"ExternalIntegration"> | string
    credentialsTag?: StringFilter<"ExternalIntegration"> | string
    accessToken?: StringNullableFilter<"ExternalIntegration"> | string | null
    refreshToken?: StringNullableFilter<"ExternalIntegration"> | string | null
    tokenExpiresAt?: DateTimeNullableFilter<"ExternalIntegration"> | Date | string | null
    apiBaseUrl?: StringNullableFilter<"ExternalIntegration"> | string | null
    apiVersion?: StringNullableFilter<"ExternalIntegration"> | string | null
    syncEnabled?: BoolFilter<"ExternalIntegration"> | boolean
    syncFrequency?: EnumSyncFrequencyFilter<"ExternalIntegration"> | $Enums.SyncFrequency
    lastSyncAt?: DateTimeNullableFilter<"ExternalIntegration"> | Date | string | null
    lastSyncStatus?: EnumSyncStatusNullableFilter<"ExternalIntegration"> | $Enums.SyncStatus | null
    nextSyncAt?: DateTimeNullableFilter<"ExternalIntegration"> | Date | string | null
    createdAt?: DateTimeFilter<"ExternalIntegration"> | Date | string
    updatedAt?: DateTimeFilter<"ExternalIntegration"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    groupMappings?: ExternalGroupMappingListRelationFilter
    syncLogs?: SyncLogListRelationFilter
  }

  export type ExternalIntegrationOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    provider?: SortOrder
    status?: SortOrder
    credentialsEncrypted?: SortOrder
    credentialsIV?: SortOrder
    credentialsTag?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    tokenExpiresAt?: SortOrderInput | SortOrder
    apiBaseUrl?: SortOrderInput | SortOrder
    apiVersion?: SortOrderInput | SortOrder
    syncEnabled?: SortOrder
    syncFrequency?: SortOrder
    lastSyncAt?: SortOrderInput | SortOrder
    lastSyncStatus?: SortOrderInput | SortOrder
    nextSyncAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    groupMappings?: ExternalGroupMappingOrderByRelationAggregateInput
    syncLogs?: SyncLogOrderByRelationAggregateInput
  }

  export type ExternalIntegrationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExternalIntegrationWhereInput | ExternalIntegrationWhereInput[]
    OR?: ExternalIntegrationWhereInput[]
    NOT?: ExternalIntegrationWhereInput | ExternalIntegrationWhereInput[]
    organizationId?: StringFilter<"ExternalIntegration"> | string
    provider?: EnumIntegrationProviderFilter<"ExternalIntegration"> | $Enums.IntegrationProvider
    status?: EnumIntegrationStatusFilter<"ExternalIntegration"> | $Enums.IntegrationStatus
    credentialsEncrypted?: StringFilter<"ExternalIntegration"> | string
    credentialsIV?: StringFilter<"ExternalIntegration"> | string
    credentialsTag?: StringFilter<"ExternalIntegration"> | string
    accessToken?: StringNullableFilter<"ExternalIntegration"> | string | null
    refreshToken?: StringNullableFilter<"ExternalIntegration"> | string | null
    tokenExpiresAt?: DateTimeNullableFilter<"ExternalIntegration"> | Date | string | null
    apiBaseUrl?: StringNullableFilter<"ExternalIntegration"> | string | null
    apiVersion?: StringNullableFilter<"ExternalIntegration"> | string | null
    syncEnabled?: BoolFilter<"ExternalIntegration"> | boolean
    syncFrequency?: EnumSyncFrequencyFilter<"ExternalIntegration"> | $Enums.SyncFrequency
    lastSyncAt?: DateTimeNullableFilter<"ExternalIntegration"> | Date | string | null
    lastSyncStatus?: EnumSyncStatusNullableFilter<"ExternalIntegration"> | $Enums.SyncStatus | null
    nextSyncAt?: DateTimeNullableFilter<"ExternalIntegration"> | Date | string | null
    createdAt?: DateTimeFilter<"ExternalIntegration"> | Date | string
    updatedAt?: DateTimeFilter<"ExternalIntegration"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    groupMappings?: ExternalGroupMappingListRelationFilter
    syncLogs?: SyncLogListRelationFilter
  }, "id">

  export type ExternalIntegrationOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    provider?: SortOrder
    status?: SortOrder
    credentialsEncrypted?: SortOrder
    credentialsIV?: SortOrder
    credentialsTag?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    tokenExpiresAt?: SortOrderInput | SortOrder
    apiBaseUrl?: SortOrderInput | SortOrder
    apiVersion?: SortOrderInput | SortOrder
    syncEnabled?: SortOrder
    syncFrequency?: SortOrder
    lastSyncAt?: SortOrderInput | SortOrder
    lastSyncStatus?: SortOrderInput | SortOrder
    nextSyncAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExternalIntegrationCountOrderByAggregateInput
    _max?: ExternalIntegrationMaxOrderByAggregateInput
    _min?: ExternalIntegrationMinOrderByAggregateInput
  }

  export type ExternalIntegrationScalarWhereWithAggregatesInput = {
    AND?: ExternalIntegrationScalarWhereWithAggregatesInput | ExternalIntegrationScalarWhereWithAggregatesInput[]
    OR?: ExternalIntegrationScalarWhereWithAggregatesInput[]
    NOT?: ExternalIntegrationScalarWhereWithAggregatesInput | ExternalIntegrationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExternalIntegration"> | string
    organizationId?: StringWithAggregatesFilter<"ExternalIntegration"> | string
    provider?: EnumIntegrationProviderWithAggregatesFilter<"ExternalIntegration"> | $Enums.IntegrationProvider
    status?: EnumIntegrationStatusWithAggregatesFilter<"ExternalIntegration"> | $Enums.IntegrationStatus
    credentialsEncrypted?: StringWithAggregatesFilter<"ExternalIntegration"> | string
    credentialsIV?: StringWithAggregatesFilter<"ExternalIntegration"> | string
    credentialsTag?: StringWithAggregatesFilter<"ExternalIntegration"> | string
    accessToken?: StringNullableWithAggregatesFilter<"ExternalIntegration"> | string | null
    refreshToken?: StringNullableWithAggregatesFilter<"ExternalIntegration"> | string | null
    tokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"ExternalIntegration"> | Date | string | null
    apiBaseUrl?: StringNullableWithAggregatesFilter<"ExternalIntegration"> | string | null
    apiVersion?: StringNullableWithAggregatesFilter<"ExternalIntegration"> | string | null
    syncEnabled?: BoolWithAggregatesFilter<"ExternalIntegration"> | boolean
    syncFrequency?: EnumSyncFrequencyWithAggregatesFilter<"ExternalIntegration"> | $Enums.SyncFrequency
    lastSyncAt?: DateTimeNullableWithAggregatesFilter<"ExternalIntegration"> | Date | string | null
    lastSyncStatus?: EnumSyncStatusNullableWithAggregatesFilter<"ExternalIntegration"> | $Enums.SyncStatus | null
    nextSyncAt?: DateTimeNullableWithAggregatesFilter<"ExternalIntegration"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ExternalIntegration"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ExternalIntegration"> | Date | string
  }

  export type ExternalGroupMappingWhereInput = {
    AND?: ExternalGroupMappingWhereInput | ExternalGroupMappingWhereInput[]
    OR?: ExternalGroupMappingWhereInput[]
    NOT?: ExternalGroupMappingWhereInput | ExternalGroupMappingWhereInput[]
    id?: StringFilter<"ExternalGroupMapping"> | string
    integrationId?: StringFilter<"ExternalGroupMapping"> | string
    externalGroupId?: StringFilter<"ExternalGroupMapping"> | string
    externalGroupName?: StringFilter<"ExternalGroupMapping"> | string
    externalGroupType?: StringNullableFilter<"ExternalGroupMapping"> | string | null
    groupId?: StringNullableFilter<"ExternalGroupMapping"> | string | null
    syncMembers?: BoolFilter<"ExternalGroupMapping"> | boolean
    syncLeaders?: BoolFilter<"ExternalGroupMapping"> | boolean
    createdAt?: DateTimeFilter<"ExternalGroupMapping"> | Date | string
    updatedAt?: DateTimeFilter<"ExternalGroupMapping"> | Date | string
    integration?: XOR<ExternalIntegrationScalarRelationFilter, ExternalIntegrationWhereInput>
    group?: XOR<GroupNullableScalarRelationFilter, GroupWhereInput> | null
  }

  export type ExternalGroupMappingOrderByWithRelationInput = {
    id?: SortOrder
    integrationId?: SortOrder
    externalGroupId?: SortOrder
    externalGroupName?: SortOrder
    externalGroupType?: SortOrderInput | SortOrder
    groupId?: SortOrderInput | SortOrder
    syncMembers?: SortOrder
    syncLeaders?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    integration?: ExternalIntegrationOrderByWithRelationInput
    group?: GroupOrderByWithRelationInput
  }

  export type ExternalGroupMappingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    integrationId_externalGroupId?: ExternalGroupMappingIntegrationIdExternalGroupIdCompoundUniqueInput
    AND?: ExternalGroupMappingWhereInput | ExternalGroupMappingWhereInput[]
    OR?: ExternalGroupMappingWhereInput[]
    NOT?: ExternalGroupMappingWhereInput | ExternalGroupMappingWhereInput[]
    integrationId?: StringFilter<"ExternalGroupMapping"> | string
    externalGroupId?: StringFilter<"ExternalGroupMapping"> | string
    externalGroupName?: StringFilter<"ExternalGroupMapping"> | string
    externalGroupType?: StringNullableFilter<"ExternalGroupMapping"> | string | null
    groupId?: StringNullableFilter<"ExternalGroupMapping"> | string | null
    syncMembers?: BoolFilter<"ExternalGroupMapping"> | boolean
    syncLeaders?: BoolFilter<"ExternalGroupMapping"> | boolean
    createdAt?: DateTimeFilter<"ExternalGroupMapping"> | Date | string
    updatedAt?: DateTimeFilter<"ExternalGroupMapping"> | Date | string
    integration?: XOR<ExternalIntegrationScalarRelationFilter, ExternalIntegrationWhereInput>
    group?: XOR<GroupNullableScalarRelationFilter, GroupWhereInput> | null
  }, "id" | "integrationId_externalGroupId">

  export type ExternalGroupMappingOrderByWithAggregationInput = {
    id?: SortOrder
    integrationId?: SortOrder
    externalGroupId?: SortOrder
    externalGroupName?: SortOrder
    externalGroupType?: SortOrderInput | SortOrder
    groupId?: SortOrderInput | SortOrder
    syncMembers?: SortOrder
    syncLeaders?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExternalGroupMappingCountOrderByAggregateInput
    _max?: ExternalGroupMappingMaxOrderByAggregateInput
    _min?: ExternalGroupMappingMinOrderByAggregateInput
  }

  export type ExternalGroupMappingScalarWhereWithAggregatesInput = {
    AND?: ExternalGroupMappingScalarWhereWithAggregatesInput | ExternalGroupMappingScalarWhereWithAggregatesInput[]
    OR?: ExternalGroupMappingScalarWhereWithAggregatesInput[]
    NOT?: ExternalGroupMappingScalarWhereWithAggregatesInput | ExternalGroupMappingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExternalGroupMapping"> | string
    integrationId?: StringWithAggregatesFilter<"ExternalGroupMapping"> | string
    externalGroupId?: StringWithAggregatesFilter<"ExternalGroupMapping"> | string
    externalGroupName?: StringWithAggregatesFilter<"ExternalGroupMapping"> | string
    externalGroupType?: StringNullableWithAggregatesFilter<"ExternalGroupMapping"> | string | null
    groupId?: StringNullableWithAggregatesFilter<"ExternalGroupMapping"> | string | null
    syncMembers?: BoolWithAggregatesFilter<"ExternalGroupMapping"> | boolean
    syncLeaders?: BoolWithAggregatesFilter<"ExternalGroupMapping"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ExternalGroupMapping"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ExternalGroupMapping"> | Date | string
  }

  export type SyncLogWhereInput = {
    AND?: SyncLogWhereInput | SyncLogWhereInput[]
    OR?: SyncLogWhereInput[]
    NOT?: SyncLogWhereInput | SyncLogWhereInput[]
    id?: StringFilter<"SyncLog"> | string
    integrationId?: StringFilter<"SyncLog"> | string
    status?: EnumSyncStatusFilter<"SyncLog"> | $Enums.SyncStatus
    startedAt?: DateTimeFilter<"SyncLog"> | Date | string
    completedAt?: DateTimeNullableFilter<"SyncLog"> | Date | string | null
    durationMs?: IntNullableFilter<"SyncLog"> | number | null
    peopleAdded?: IntFilter<"SyncLog"> | number
    peopleUpdated?: IntFilter<"SyncLog"> | number
    peopleRemoved?: IntFilter<"SyncLog"> | number
    groupsAdded?: IntFilter<"SyncLog"> | number
    groupsUpdated?: IntFilter<"SyncLog"> | number
    groupsSkipped?: IntFilter<"SyncLog"> | number
    errorMessage?: StringNullableFilter<"SyncLog"> | string | null
    errorCode?: StringNullableFilter<"SyncLog"> | string | null
    errorDetails?: JsonNullableFilter<"SyncLog">
    metadata?: JsonNullableFilter<"SyncLog">
    integration?: XOR<ExternalIntegrationScalarRelationFilter, ExternalIntegrationWhereInput>
  }

  export type SyncLogOrderByWithRelationInput = {
    id?: SortOrder
    integrationId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    durationMs?: SortOrderInput | SortOrder
    peopleAdded?: SortOrder
    peopleUpdated?: SortOrder
    peopleRemoved?: SortOrder
    groupsAdded?: SortOrder
    groupsUpdated?: SortOrder
    groupsSkipped?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    errorCode?: SortOrderInput | SortOrder
    errorDetails?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    integration?: ExternalIntegrationOrderByWithRelationInput
  }

  export type SyncLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SyncLogWhereInput | SyncLogWhereInput[]
    OR?: SyncLogWhereInput[]
    NOT?: SyncLogWhereInput | SyncLogWhereInput[]
    integrationId?: StringFilter<"SyncLog"> | string
    status?: EnumSyncStatusFilter<"SyncLog"> | $Enums.SyncStatus
    startedAt?: DateTimeFilter<"SyncLog"> | Date | string
    completedAt?: DateTimeNullableFilter<"SyncLog"> | Date | string | null
    durationMs?: IntNullableFilter<"SyncLog"> | number | null
    peopleAdded?: IntFilter<"SyncLog"> | number
    peopleUpdated?: IntFilter<"SyncLog"> | number
    peopleRemoved?: IntFilter<"SyncLog"> | number
    groupsAdded?: IntFilter<"SyncLog"> | number
    groupsUpdated?: IntFilter<"SyncLog"> | number
    groupsSkipped?: IntFilter<"SyncLog"> | number
    errorMessage?: StringNullableFilter<"SyncLog"> | string | null
    errorCode?: StringNullableFilter<"SyncLog"> | string | null
    errorDetails?: JsonNullableFilter<"SyncLog">
    metadata?: JsonNullableFilter<"SyncLog">
    integration?: XOR<ExternalIntegrationScalarRelationFilter, ExternalIntegrationWhereInput>
  }, "id">

  export type SyncLogOrderByWithAggregationInput = {
    id?: SortOrder
    integrationId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    durationMs?: SortOrderInput | SortOrder
    peopleAdded?: SortOrder
    peopleUpdated?: SortOrder
    peopleRemoved?: SortOrder
    groupsAdded?: SortOrder
    groupsUpdated?: SortOrder
    groupsSkipped?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    errorCode?: SortOrderInput | SortOrder
    errorDetails?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: SyncLogCountOrderByAggregateInput
    _avg?: SyncLogAvgOrderByAggregateInput
    _max?: SyncLogMaxOrderByAggregateInput
    _min?: SyncLogMinOrderByAggregateInput
    _sum?: SyncLogSumOrderByAggregateInput
  }

  export type SyncLogScalarWhereWithAggregatesInput = {
    AND?: SyncLogScalarWhereWithAggregatesInput | SyncLogScalarWhereWithAggregatesInput[]
    OR?: SyncLogScalarWhereWithAggregatesInput[]
    NOT?: SyncLogScalarWhereWithAggregatesInput | SyncLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SyncLog"> | string
    integrationId?: StringWithAggregatesFilter<"SyncLog"> | string
    status?: EnumSyncStatusWithAggregatesFilter<"SyncLog"> | $Enums.SyncStatus
    startedAt?: DateTimeWithAggregatesFilter<"SyncLog"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"SyncLog"> | Date | string | null
    durationMs?: IntNullableWithAggregatesFilter<"SyncLog"> | number | null
    peopleAdded?: IntWithAggregatesFilter<"SyncLog"> | number
    peopleUpdated?: IntWithAggregatesFilter<"SyncLog"> | number
    peopleRemoved?: IntWithAggregatesFilter<"SyncLog"> | number
    groupsAdded?: IntWithAggregatesFilter<"SyncLog"> | number
    groupsUpdated?: IntWithAggregatesFilter<"SyncLog"> | number
    groupsSkipped?: IntWithAggregatesFilter<"SyncLog"> | number
    errorMessage?: StringNullableWithAggregatesFilter<"SyncLog"> | string | null
    errorCode?: StringNullableWithAggregatesFilter<"SyncLog"> | string | null
    errorDetails?: JsonNullableWithAggregatesFilter<"SyncLog">
    metadata?: JsonNullableWithAggregatesFilter<"SyncLog">
  }

  export type LessonWhereInput = {
    AND?: LessonWhereInput | LessonWhereInput[]
    OR?: LessonWhereInput[]
    NOT?: LessonWhereInput | LessonWhereInput[]
    id?: StringFilter<"Lesson"> | string
    organizationId?: StringFilter<"Lesson"> | string
    title?: StringFilter<"Lesson"> | string
    quarter?: IntFilter<"Lesson"> | number
    unit?: IntFilter<"Lesson"> | number
    lessonNumber?: IntFilter<"Lesson"> | number
    scripture?: StringFilter<"Lesson"> | string
    content?: JsonFilter<"Lesson">
    slides?: JsonNullableFilter<"Lesson">
    games?: JsonNullableFilter<"Lesson">
    isPublic?: BoolFilter<"Lesson"> | boolean
    isTemplate?: BoolFilter<"Lesson"> | boolean
    createdBy?: StringNullableFilter<"Lesson"> | string | null
    createdAt?: DateTimeFilter<"Lesson"> | Date | string
    updatedAt?: DateTimeFilter<"Lesson"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    groups?: LessonGroupListRelationFilter
  }

  export type LessonOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    title?: SortOrder
    quarter?: SortOrder
    unit?: SortOrder
    lessonNumber?: SortOrder
    scripture?: SortOrder
    content?: SortOrder
    slides?: SortOrderInput | SortOrder
    games?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    isTemplate?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    groups?: LessonGroupOrderByRelationAggregateInput
  }

  export type LessonWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    organizationId_quarter_unit_lessonNumber?: LessonOrganizationIdQuarterUnitLessonNumberCompoundUniqueInput
    AND?: LessonWhereInput | LessonWhereInput[]
    OR?: LessonWhereInput[]
    NOT?: LessonWhereInput | LessonWhereInput[]
    organizationId?: StringFilter<"Lesson"> | string
    title?: StringFilter<"Lesson"> | string
    quarter?: IntFilter<"Lesson"> | number
    unit?: IntFilter<"Lesson"> | number
    lessonNumber?: IntFilter<"Lesson"> | number
    scripture?: StringFilter<"Lesson"> | string
    content?: JsonFilter<"Lesson">
    slides?: JsonNullableFilter<"Lesson">
    games?: JsonNullableFilter<"Lesson">
    isPublic?: BoolFilter<"Lesson"> | boolean
    isTemplate?: BoolFilter<"Lesson"> | boolean
    createdBy?: StringNullableFilter<"Lesson"> | string | null
    createdAt?: DateTimeFilter<"Lesson"> | Date | string
    updatedAt?: DateTimeFilter<"Lesson"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    groups?: LessonGroupListRelationFilter
  }, "id" | "organizationId_quarter_unit_lessonNumber">

  export type LessonOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    title?: SortOrder
    quarter?: SortOrder
    unit?: SortOrder
    lessonNumber?: SortOrder
    scripture?: SortOrder
    content?: SortOrder
    slides?: SortOrderInput | SortOrder
    games?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    isTemplate?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LessonCountOrderByAggregateInput
    _avg?: LessonAvgOrderByAggregateInput
    _max?: LessonMaxOrderByAggregateInput
    _min?: LessonMinOrderByAggregateInput
    _sum?: LessonSumOrderByAggregateInput
  }

  export type LessonScalarWhereWithAggregatesInput = {
    AND?: LessonScalarWhereWithAggregatesInput | LessonScalarWhereWithAggregatesInput[]
    OR?: LessonScalarWhereWithAggregatesInput[]
    NOT?: LessonScalarWhereWithAggregatesInput | LessonScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Lesson"> | string
    organizationId?: StringWithAggregatesFilter<"Lesson"> | string
    title?: StringWithAggregatesFilter<"Lesson"> | string
    quarter?: IntWithAggregatesFilter<"Lesson"> | number
    unit?: IntWithAggregatesFilter<"Lesson"> | number
    lessonNumber?: IntWithAggregatesFilter<"Lesson"> | number
    scripture?: StringWithAggregatesFilter<"Lesson"> | string
    content?: JsonWithAggregatesFilter<"Lesson">
    slides?: JsonNullableWithAggregatesFilter<"Lesson">
    games?: JsonNullableWithAggregatesFilter<"Lesson">
    isPublic?: BoolWithAggregatesFilter<"Lesson"> | boolean
    isTemplate?: BoolWithAggregatesFilter<"Lesson"> | boolean
    createdBy?: StringNullableWithAggregatesFilter<"Lesson"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Lesson"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Lesson"> | Date | string
  }

  export type LessonGroupWhereInput = {
    AND?: LessonGroupWhereInput | LessonGroupWhereInput[]
    OR?: LessonGroupWhereInput[]
    NOT?: LessonGroupWhereInput | LessonGroupWhereInput[]
    id?: StringFilter<"LessonGroup"> | string
    lessonId?: StringFilter<"LessonGroup"> | string
    groupId?: StringFilter<"LessonGroup"> | string
    createdAt?: DateTimeFilter<"LessonGroup"> | Date | string
    lesson?: XOR<LessonScalarRelationFilter, LessonWhereInput>
    group?: XOR<GroupScalarRelationFilter, GroupWhereInput>
  }

  export type LessonGroupOrderByWithRelationInput = {
    id?: SortOrder
    lessonId?: SortOrder
    groupId?: SortOrder
    createdAt?: SortOrder
    lesson?: LessonOrderByWithRelationInput
    group?: GroupOrderByWithRelationInput
  }

  export type LessonGroupWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    lessonId_groupId?: LessonGroupLessonIdGroupIdCompoundUniqueInput
    AND?: LessonGroupWhereInput | LessonGroupWhereInput[]
    OR?: LessonGroupWhereInput[]
    NOT?: LessonGroupWhereInput | LessonGroupWhereInput[]
    lessonId?: StringFilter<"LessonGroup"> | string
    groupId?: StringFilter<"LessonGroup"> | string
    createdAt?: DateTimeFilter<"LessonGroup"> | Date | string
    lesson?: XOR<LessonScalarRelationFilter, LessonWhereInput>
    group?: XOR<GroupScalarRelationFilter, GroupWhereInput>
  }, "id" | "lessonId_groupId">

  export type LessonGroupOrderByWithAggregationInput = {
    id?: SortOrder
    lessonId?: SortOrder
    groupId?: SortOrder
    createdAt?: SortOrder
    _count?: LessonGroupCountOrderByAggregateInput
    _max?: LessonGroupMaxOrderByAggregateInput
    _min?: LessonGroupMinOrderByAggregateInput
  }

  export type LessonGroupScalarWhereWithAggregatesInput = {
    AND?: LessonGroupScalarWhereWithAggregatesInput | LessonGroupScalarWhereWithAggregatesInput[]
    OR?: LessonGroupScalarWhereWithAggregatesInput[]
    NOT?: LessonGroupScalarWhereWithAggregatesInput | LessonGroupScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LessonGroup"> | string
    lessonId?: StringWithAggregatesFilter<"LessonGroup"> | string
    groupId?: StringWithAggregatesFilter<"LessonGroup"> | string
    createdAt?: DateTimeWithAggregatesFilter<"LessonGroup"> | Date | string
  }

  export type AIFilterConfigWhereInput = {
    AND?: AIFilterConfigWhereInput | AIFilterConfigWhereInput[]
    OR?: AIFilterConfigWhereInput[]
    NOT?: AIFilterConfigWhereInput | AIFilterConfigWhereInput[]
    id?: StringFilter<"AIFilterConfig"> | string
    organizationId?: StringNullableFilter<"AIFilterConfig"> | string | null
    filterRules?: JsonFilter<"AIFilterConfig">
    customKeywords?: JsonNullableFilter<"AIFilterConfig">
    redirectMessage?: StringNullableFilter<"AIFilterConfig"> | string | null
    isActive?: BoolFilter<"AIFilterConfig"> | boolean
    createdAt?: DateTimeFilter<"AIFilterConfig"> | Date | string
    updatedAt?: DateTimeFilter<"AIFilterConfig"> | Date | string
    organization?: XOR<OrganizationNullableScalarRelationFilter, OrganizationWhereInput> | null
    metrics?: AIFilterMetricListRelationFilter
  }

  export type AIFilterConfigOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrderInput | SortOrder
    filterRules?: SortOrder
    customKeywords?: SortOrderInput | SortOrder
    redirectMessage?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    metrics?: AIFilterMetricOrderByRelationAggregateInput
  }

  export type AIFilterConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    organizationId?: string
    AND?: AIFilterConfigWhereInput | AIFilterConfigWhereInput[]
    OR?: AIFilterConfigWhereInput[]
    NOT?: AIFilterConfigWhereInput | AIFilterConfigWhereInput[]
    filterRules?: JsonFilter<"AIFilterConfig">
    customKeywords?: JsonNullableFilter<"AIFilterConfig">
    redirectMessage?: StringNullableFilter<"AIFilterConfig"> | string | null
    isActive?: BoolFilter<"AIFilterConfig"> | boolean
    createdAt?: DateTimeFilter<"AIFilterConfig"> | Date | string
    updatedAt?: DateTimeFilter<"AIFilterConfig"> | Date | string
    organization?: XOR<OrganizationNullableScalarRelationFilter, OrganizationWhereInput> | null
    metrics?: AIFilterMetricListRelationFilter
  }, "id" | "organizationId">

  export type AIFilterConfigOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrderInput | SortOrder
    filterRules?: SortOrder
    customKeywords?: SortOrderInput | SortOrder
    redirectMessage?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AIFilterConfigCountOrderByAggregateInput
    _max?: AIFilterConfigMaxOrderByAggregateInput
    _min?: AIFilterConfigMinOrderByAggregateInput
  }

  export type AIFilterConfigScalarWhereWithAggregatesInput = {
    AND?: AIFilterConfigScalarWhereWithAggregatesInput | AIFilterConfigScalarWhereWithAggregatesInput[]
    OR?: AIFilterConfigScalarWhereWithAggregatesInput[]
    NOT?: AIFilterConfigScalarWhereWithAggregatesInput | AIFilterConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AIFilterConfig"> | string
    organizationId?: StringNullableWithAggregatesFilter<"AIFilterConfig"> | string | null
    filterRules?: JsonWithAggregatesFilter<"AIFilterConfig">
    customKeywords?: JsonNullableWithAggregatesFilter<"AIFilterConfig">
    redirectMessage?: StringNullableWithAggregatesFilter<"AIFilterConfig"> | string | null
    isActive?: BoolWithAggregatesFilter<"AIFilterConfig"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AIFilterConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AIFilterConfig"> | Date | string
  }

  export type AIFilterMetricWhereInput = {
    AND?: AIFilterMetricWhereInput | AIFilterMetricWhereInput[]
    OR?: AIFilterMetricWhereInput[]
    NOT?: AIFilterMetricWhereInput | AIFilterMetricWhereInput[]
    id?: StringFilter<"AIFilterMetric"> | string
    filterId?: StringFilter<"AIFilterMetric"> | string
    organizationId?: StringNullableFilter<"AIFilterMetric"> | string | null
    query?: StringFilter<"AIFilterMetric"> | string
    detectedCategory?: EnumFilterCategoryFilter<"AIFilterMetric"> | $Enums.FilterCategory
    actionTaken?: EnumFilterActionFilter<"AIFilterMetric"> | $Enums.FilterAction
    userId?: StringNullableFilter<"AIFilterMetric"> | string | null
    groupId?: StringNullableFilter<"AIFilterMetric"> | string | null
    featureName?: StringNullableFilter<"AIFilterMetric"> | string | null
    leaderNotified?: BoolFilter<"AIFilterMetric"> | boolean
    leaderResponse?: StringNullableFilter<"AIFilterMetric"> | string | null
    resolvedAt?: DateTimeNullableFilter<"AIFilterMetric"> | Date | string | null
    createdAt?: DateTimeFilter<"AIFilterMetric"> | Date | string
    filter?: XOR<AIFilterConfigScalarRelationFilter, AIFilterConfigWhereInput>
  }

  export type AIFilterMetricOrderByWithRelationInput = {
    id?: SortOrder
    filterId?: SortOrder
    organizationId?: SortOrderInput | SortOrder
    query?: SortOrder
    detectedCategory?: SortOrder
    actionTaken?: SortOrder
    userId?: SortOrderInput | SortOrder
    groupId?: SortOrderInput | SortOrder
    featureName?: SortOrderInput | SortOrder
    leaderNotified?: SortOrder
    leaderResponse?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    filter?: AIFilterConfigOrderByWithRelationInput
  }

  export type AIFilterMetricWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AIFilterMetricWhereInput | AIFilterMetricWhereInput[]
    OR?: AIFilterMetricWhereInput[]
    NOT?: AIFilterMetricWhereInput | AIFilterMetricWhereInput[]
    filterId?: StringFilter<"AIFilterMetric"> | string
    organizationId?: StringNullableFilter<"AIFilterMetric"> | string | null
    query?: StringFilter<"AIFilterMetric"> | string
    detectedCategory?: EnumFilterCategoryFilter<"AIFilterMetric"> | $Enums.FilterCategory
    actionTaken?: EnumFilterActionFilter<"AIFilterMetric"> | $Enums.FilterAction
    userId?: StringNullableFilter<"AIFilterMetric"> | string | null
    groupId?: StringNullableFilter<"AIFilterMetric"> | string | null
    featureName?: StringNullableFilter<"AIFilterMetric"> | string | null
    leaderNotified?: BoolFilter<"AIFilterMetric"> | boolean
    leaderResponse?: StringNullableFilter<"AIFilterMetric"> | string | null
    resolvedAt?: DateTimeNullableFilter<"AIFilterMetric"> | Date | string | null
    createdAt?: DateTimeFilter<"AIFilterMetric"> | Date | string
    filter?: XOR<AIFilterConfigScalarRelationFilter, AIFilterConfigWhereInput>
  }, "id">

  export type AIFilterMetricOrderByWithAggregationInput = {
    id?: SortOrder
    filterId?: SortOrder
    organizationId?: SortOrderInput | SortOrder
    query?: SortOrder
    detectedCategory?: SortOrder
    actionTaken?: SortOrder
    userId?: SortOrderInput | SortOrder
    groupId?: SortOrderInput | SortOrder
    featureName?: SortOrderInput | SortOrder
    leaderNotified?: SortOrder
    leaderResponse?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AIFilterMetricCountOrderByAggregateInput
    _max?: AIFilterMetricMaxOrderByAggregateInput
    _min?: AIFilterMetricMinOrderByAggregateInput
  }

  export type AIFilterMetricScalarWhereWithAggregatesInput = {
    AND?: AIFilterMetricScalarWhereWithAggregatesInput | AIFilterMetricScalarWhereWithAggregatesInput[]
    OR?: AIFilterMetricScalarWhereWithAggregatesInput[]
    NOT?: AIFilterMetricScalarWhereWithAggregatesInput | AIFilterMetricScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AIFilterMetric"> | string
    filterId?: StringWithAggregatesFilter<"AIFilterMetric"> | string
    organizationId?: StringNullableWithAggregatesFilter<"AIFilterMetric"> | string | null
    query?: StringWithAggregatesFilter<"AIFilterMetric"> | string
    detectedCategory?: EnumFilterCategoryWithAggregatesFilter<"AIFilterMetric"> | $Enums.FilterCategory
    actionTaken?: EnumFilterActionWithAggregatesFilter<"AIFilterMetric"> | $Enums.FilterAction
    userId?: StringNullableWithAggregatesFilter<"AIFilterMetric"> | string | null
    groupId?: StringNullableWithAggregatesFilter<"AIFilterMetric"> | string | null
    featureName?: StringNullableWithAggregatesFilter<"AIFilterMetric"> | string | null
    leaderNotified?: BoolWithAggregatesFilter<"AIFilterMetric"> | boolean
    leaderResponse?: StringNullableWithAggregatesFilter<"AIFilterMetric"> | string | null
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"AIFilterMetric"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AIFilterMetric"> | Date | string
  }

  export type ComparativeThemeWhereInput = {
    AND?: ComparativeThemeWhereInput | ComparativeThemeWhereInput[]
    OR?: ComparativeThemeWhereInput[]
    NOT?: ComparativeThemeWhereInput | ComparativeThemeWhereInput[]
    id?: StringFilter<"ComparativeTheme"> | string
    organizationId?: StringFilter<"ComparativeTheme"> | string
    themeName?: StringFilter<"ComparativeTheme"> | string
    description?: StringNullableFilter<"ComparativeTheme"> | string | null
    category?: StringNullableFilter<"ComparativeTheme"> | string | null
    otPassages?: JsonFilter<"ComparativeTheme">
    ntPassages?: JsonFilter<"ComparativeTheme">
    themeNotes?: JsonNullableFilter<"ComparativeTheme">
    isPublic?: BoolFilter<"ComparativeTheme"> | boolean
    createdBy?: StringNullableFilter<"ComparativeTheme"> | string | null
    createdAt?: DateTimeFilter<"ComparativeTheme"> | Date | string
    updatedAt?: DateTimeFilter<"ComparativeTheme"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    metrics?: ThemeMetricListRelationFilter
  }

  export type ComparativeThemeOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    themeName?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    otPassages?: SortOrder
    ntPassages?: SortOrder
    themeNotes?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    metrics?: ThemeMetricOrderByRelationAggregateInput
  }

  export type ComparativeThemeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ComparativeThemeWhereInput | ComparativeThemeWhereInput[]
    OR?: ComparativeThemeWhereInput[]
    NOT?: ComparativeThemeWhereInput | ComparativeThemeWhereInput[]
    organizationId?: StringFilter<"ComparativeTheme"> | string
    themeName?: StringFilter<"ComparativeTheme"> | string
    description?: StringNullableFilter<"ComparativeTheme"> | string | null
    category?: StringNullableFilter<"ComparativeTheme"> | string | null
    otPassages?: JsonFilter<"ComparativeTheme">
    ntPassages?: JsonFilter<"ComparativeTheme">
    themeNotes?: JsonNullableFilter<"ComparativeTheme">
    isPublic?: BoolFilter<"ComparativeTheme"> | boolean
    createdBy?: StringNullableFilter<"ComparativeTheme"> | string | null
    createdAt?: DateTimeFilter<"ComparativeTheme"> | Date | string
    updatedAt?: DateTimeFilter<"ComparativeTheme"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    metrics?: ThemeMetricListRelationFilter
  }, "id">

  export type ComparativeThemeOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    themeName?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    otPassages?: SortOrder
    ntPassages?: SortOrder
    themeNotes?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ComparativeThemeCountOrderByAggregateInput
    _max?: ComparativeThemeMaxOrderByAggregateInput
    _min?: ComparativeThemeMinOrderByAggregateInput
  }

  export type ComparativeThemeScalarWhereWithAggregatesInput = {
    AND?: ComparativeThemeScalarWhereWithAggregatesInput | ComparativeThemeScalarWhereWithAggregatesInput[]
    OR?: ComparativeThemeScalarWhereWithAggregatesInput[]
    NOT?: ComparativeThemeScalarWhereWithAggregatesInput | ComparativeThemeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ComparativeTheme"> | string
    organizationId?: StringWithAggregatesFilter<"ComparativeTheme"> | string
    themeName?: StringWithAggregatesFilter<"ComparativeTheme"> | string
    description?: StringNullableWithAggregatesFilter<"ComparativeTheme"> | string | null
    category?: StringNullableWithAggregatesFilter<"ComparativeTheme"> | string | null
    otPassages?: JsonWithAggregatesFilter<"ComparativeTheme">
    ntPassages?: JsonWithAggregatesFilter<"ComparativeTheme">
    themeNotes?: JsonNullableWithAggregatesFilter<"ComparativeTheme">
    isPublic?: BoolWithAggregatesFilter<"ComparativeTheme"> | boolean
    createdBy?: StringNullableWithAggregatesFilter<"ComparativeTheme"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ComparativeTheme"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ComparativeTheme"> | Date | string
  }

  export type ThemeMetricWhereInput = {
    AND?: ThemeMetricWhereInput | ThemeMetricWhereInput[]
    OR?: ThemeMetricWhereInput[]
    NOT?: ThemeMetricWhereInput | ThemeMetricWhereInput[]
    id?: StringFilter<"ThemeMetric"> | string
    themeId?: StringFilter<"ThemeMetric"> | string
    organizationId?: StringFilter<"ThemeMetric"> | string
    viewCount?: IntFilter<"ThemeMetric"> | number
    lastViewedAt?: DateTimeFilter<"ThemeMetric"> | Date | string
    userId?: StringNullableFilter<"ThemeMetric"> | string | null
    featureContext?: StringNullableFilter<"ThemeMetric"> | string | null
    timeSpentMs?: IntNullableFilter<"ThemeMetric"> | number | null
    usedInLesson?: BoolFilter<"ThemeMetric"> | boolean
    lessonId?: StringNullableFilter<"ThemeMetric"> | string | null
    createdAt?: DateTimeFilter<"ThemeMetric"> | Date | string
    theme?: XOR<ComparativeThemeScalarRelationFilter, ComparativeThemeWhereInput>
  }

  export type ThemeMetricOrderByWithRelationInput = {
    id?: SortOrder
    themeId?: SortOrder
    organizationId?: SortOrder
    viewCount?: SortOrder
    lastViewedAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    featureContext?: SortOrderInput | SortOrder
    timeSpentMs?: SortOrderInput | SortOrder
    usedInLesson?: SortOrder
    lessonId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    theme?: ComparativeThemeOrderByWithRelationInput
  }

  export type ThemeMetricWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ThemeMetricWhereInput | ThemeMetricWhereInput[]
    OR?: ThemeMetricWhereInput[]
    NOT?: ThemeMetricWhereInput | ThemeMetricWhereInput[]
    themeId?: StringFilter<"ThemeMetric"> | string
    organizationId?: StringFilter<"ThemeMetric"> | string
    viewCount?: IntFilter<"ThemeMetric"> | number
    lastViewedAt?: DateTimeFilter<"ThemeMetric"> | Date | string
    userId?: StringNullableFilter<"ThemeMetric"> | string | null
    featureContext?: StringNullableFilter<"ThemeMetric"> | string | null
    timeSpentMs?: IntNullableFilter<"ThemeMetric"> | number | null
    usedInLesson?: BoolFilter<"ThemeMetric"> | boolean
    lessonId?: StringNullableFilter<"ThemeMetric"> | string | null
    createdAt?: DateTimeFilter<"ThemeMetric"> | Date | string
    theme?: XOR<ComparativeThemeScalarRelationFilter, ComparativeThemeWhereInput>
  }, "id">

  export type ThemeMetricOrderByWithAggregationInput = {
    id?: SortOrder
    themeId?: SortOrder
    organizationId?: SortOrder
    viewCount?: SortOrder
    lastViewedAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    featureContext?: SortOrderInput | SortOrder
    timeSpentMs?: SortOrderInput | SortOrder
    usedInLesson?: SortOrder
    lessonId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ThemeMetricCountOrderByAggregateInput
    _avg?: ThemeMetricAvgOrderByAggregateInput
    _max?: ThemeMetricMaxOrderByAggregateInput
    _min?: ThemeMetricMinOrderByAggregateInput
    _sum?: ThemeMetricSumOrderByAggregateInput
  }

  export type ThemeMetricScalarWhereWithAggregatesInput = {
    AND?: ThemeMetricScalarWhereWithAggregatesInput | ThemeMetricScalarWhereWithAggregatesInput[]
    OR?: ThemeMetricScalarWhereWithAggregatesInput[]
    NOT?: ThemeMetricScalarWhereWithAggregatesInput | ThemeMetricScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ThemeMetric"> | string
    themeId?: StringWithAggregatesFilter<"ThemeMetric"> | string
    organizationId?: StringWithAggregatesFilter<"ThemeMetric"> | string
    viewCount?: IntWithAggregatesFilter<"ThemeMetric"> | number
    lastViewedAt?: DateTimeWithAggregatesFilter<"ThemeMetric"> | Date | string
    userId?: StringNullableWithAggregatesFilter<"ThemeMetric"> | string | null
    featureContext?: StringNullableWithAggregatesFilter<"ThemeMetric"> | string | null
    timeSpentMs?: IntNullableWithAggregatesFilter<"ThemeMetric"> | number | null
    usedInLesson?: BoolWithAggregatesFilter<"ThemeMetric"> | boolean
    lessonId?: StringNullableWithAggregatesFilter<"ThemeMetric"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ThemeMetric"> | Date | string
  }

  export type NotificationPreferenceWhereInput = {
    AND?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    OR?: NotificationPreferenceWhereInput[]
    NOT?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    id?: StringFilter<"NotificationPreference"> | string
    userId?: StringFilter<"NotificationPreference"> | string
    emailEnabled?: BoolFilter<"NotificationPreference"> | boolean
    emailLessonReminders?: BoolFilter<"NotificationPreference"> | boolean
    emailEventReminders?: BoolFilter<"NotificationPreference"> | boolean
    emailAnnouncements?: BoolFilter<"NotificationPreference"> | boolean
    emailGroupUpdates?: BoolFilter<"NotificationPreference"> | boolean
    emailDigest?: BoolFilter<"NotificationPreference"> | boolean
    emailDigestFrequency?: EnumDigestFrequencyFilter<"NotificationPreference"> | $Enums.DigestFrequency
    inAppEnabled?: BoolFilter<"NotificationPreference"> | boolean
    inAppLessonReminders?: BoolFilter<"NotificationPreference"> | boolean
    inAppEventReminders?: BoolFilter<"NotificationPreference"> | boolean
    inAppAnnouncements?: BoolFilter<"NotificationPreference"> | boolean
    inAppGroupUpdates?: BoolFilter<"NotificationPreference"> | boolean
    quietHoursEnabled?: BoolFilter<"NotificationPreference"> | boolean
    quietHoursStart?: StringNullableFilter<"NotificationPreference"> | string | null
    quietHoursEnd?: StringNullableFilter<"NotificationPreference"> | string | null
    quietHoursTimezone?: StringFilter<"NotificationPreference"> | string
    preferredDays?: JsonNullableFilter<"NotificationPreference">
    lessonReminderDays?: IntFilter<"NotificationPreference"> | number
    lessonReminderTime?: StringFilter<"NotificationPreference"> | string
    eventReminderHours?: IntFilter<"NotificationPreference"> | number
    batchNotifications?: BoolFilter<"NotificationPreference"> | boolean
    maxNotificationsPerDay?: IntFilter<"NotificationPreference"> | number
    createdAt?: DateTimeFilter<"NotificationPreference"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationPreference"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationPreferenceOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    emailEnabled?: SortOrder
    emailLessonReminders?: SortOrder
    emailEventReminders?: SortOrder
    emailAnnouncements?: SortOrder
    emailGroupUpdates?: SortOrder
    emailDigest?: SortOrder
    emailDigestFrequency?: SortOrder
    inAppEnabled?: SortOrder
    inAppLessonReminders?: SortOrder
    inAppEventReminders?: SortOrder
    inAppAnnouncements?: SortOrder
    inAppGroupUpdates?: SortOrder
    quietHoursEnabled?: SortOrder
    quietHoursStart?: SortOrderInput | SortOrder
    quietHoursEnd?: SortOrderInput | SortOrder
    quietHoursTimezone?: SortOrder
    preferredDays?: SortOrderInput | SortOrder
    lessonReminderDays?: SortOrder
    lessonReminderTime?: SortOrder
    eventReminderHours?: SortOrder
    batchNotifications?: SortOrder
    maxNotificationsPerDay?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationPreferenceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    OR?: NotificationPreferenceWhereInput[]
    NOT?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    emailEnabled?: BoolFilter<"NotificationPreference"> | boolean
    emailLessonReminders?: BoolFilter<"NotificationPreference"> | boolean
    emailEventReminders?: BoolFilter<"NotificationPreference"> | boolean
    emailAnnouncements?: BoolFilter<"NotificationPreference"> | boolean
    emailGroupUpdates?: BoolFilter<"NotificationPreference"> | boolean
    emailDigest?: BoolFilter<"NotificationPreference"> | boolean
    emailDigestFrequency?: EnumDigestFrequencyFilter<"NotificationPreference"> | $Enums.DigestFrequency
    inAppEnabled?: BoolFilter<"NotificationPreference"> | boolean
    inAppLessonReminders?: BoolFilter<"NotificationPreference"> | boolean
    inAppEventReminders?: BoolFilter<"NotificationPreference"> | boolean
    inAppAnnouncements?: BoolFilter<"NotificationPreference"> | boolean
    inAppGroupUpdates?: BoolFilter<"NotificationPreference"> | boolean
    quietHoursEnabled?: BoolFilter<"NotificationPreference"> | boolean
    quietHoursStart?: StringNullableFilter<"NotificationPreference"> | string | null
    quietHoursEnd?: StringNullableFilter<"NotificationPreference"> | string | null
    quietHoursTimezone?: StringFilter<"NotificationPreference"> | string
    preferredDays?: JsonNullableFilter<"NotificationPreference">
    lessonReminderDays?: IntFilter<"NotificationPreference"> | number
    lessonReminderTime?: StringFilter<"NotificationPreference"> | string
    eventReminderHours?: IntFilter<"NotificationPreference"> | number
    batchNotifications?: BoolFilter<"NotificationPreference"> | boolean
    maxNotificationsPerDay?: IntFilter<"NotificationPreference"> | number
    createdAt?: DateTimeFilter<"NotificationPreference"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationPreference"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type NotificationPreferenceOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    emailEnabled?: SortOrder
    emailLessonReminders?: SortOrder
    emailEventReminders?: SortOrder
    emailAnnouncements?: SortOrder
    emailGroupUpdates?: SortOrder
    emailDigest?: SortOrder
    emailDigestFrequency?: SortOrder
    inAppEnabled?: SortOrder
    inAppLessonReminders?: SortOrder
    inAppEventReminders?: SortOrder
    inAppAnnouncements?: SortOrder
    inAppGroupUpdates?: SortOrder
    quietHoursEnabled?: SortOrder
    quietHoursStart?: SortOrderInput | SortOrder
    quietHoursEnd?: SortOrderInput | SortOrder
    quietHoursTimezone?: SortOrder
    preferredDays?: SortOrderInput | SortOrder
    lessonReminderDays?: SortOrder
    lessonReminderTime?: SortOrder
    eventReminderHours?: SortOrder
    batchNotifications?: SortOrder
    maxNotificationsPerDay?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationPreferenceCountOrderByAggregateInput
    _avg?: NotificationPreferenceAvgOrderByAggregateInput
    _max?: NotificationPreferenceMaxOrderByAggregateInput
    _min?: NotificationPreferenceMinOrderByAggregateInput
    _sum?: NotificationPreferenceSumOrderByAggregateInput
  }

  export type NotificationPreferenceScalarWhereWithAggregatesInput = {
    AND?: NotificationPreferenceScalarWhereWithAggregatesInput | NotificationPreferenceScalarWhereWithAggregatesInput[]
    OR?: NotificationPreferenceScalarWhereWithAggregatesInput[]
    NOT?: NotificationPreferenceScalarWhereWithAggregatesInput | NotificationPreferenceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationPreference"> | string
    userId?: StringWithAggregatesFilter<"NotificationPreference"> | string
    emailEnabled?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    emailLessonReminders?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    emailEventReminders?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    emailAnnouncements?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    emailGroupUpdates?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    emailDigest?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    emailDigestFrequency?: EnumDigestFrequencyWithAggregatesFilter<"NotificationPreference"> | $Enums.DigestFrequency
    inAppEnabled?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    inAppLessonReminders?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    inAppEventReminders?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    inAppAnnouncements?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    inAppGroupUpdates?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    quietHoursEnabled?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    quietHoursStart?: StringNullableWithAggregatesFilter<"NotificationPreference"> | string | null
    quietHoursEnd?: StringNullableWithAggregatesFilter<"NotificationPreference"> | string | null
    quietHoursTimezone?: StringWithAggregatesFilter<"NotificationPreference"> | string
    preferredDays?: JsonNullableWithAggregatesFilter<"NotificationPreference">
    lessonReminderDays?: IntWithAggregatesFilter<"NotificationPreference"> | number
    lessonReminderTime?: StringWithAggregatesFilter<"NotificationPreference"> | string
    eventReminderHours?: IntWithAggregatesFilter<"NotificationPreference"> | number
    batchNotifications?: BoolWithAggregatesFilter<"NotificationPreference"> | boolean
    maxNotificationsPerDay?: IntWithAggregatesFilter<"NotificationPreference"> | number
    createdAt?: DateTimeWithAggregatesFilter<"NotificationPreference"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NotificationPreference"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    organizationId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    actionUrl?: StringNullableFilter<"Notification"> | string | null
    deliveryMethod?: EnumNotificationDeliveryMethodFilter<"Notification"> | $Enums.NotificationDeliveryMethod
    priority?: EnumNotificationPriorityFilter<"Notification"> | $Enums.NotificationPriority
    scheduledFor?: DateTimeNullableFilter<"Notification"> | Date | string | null
    sentAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    status?: EnumNotificationStatusFilter<"Notification"> | $Enums.NotificationStatus
    deliveryStatus?: JsonNullableFilter<"Notification">
    failureReason?: StringNullableFilter<"Notification"> | string | null
    retryCount?: IntFilter<"Notification"> | number
    maxRetries?: IntFilter<"Notification"> | number
    groupId?: StringNullableFilter<"Notification"> | string | null
    lessonId?: StringNullableFilter<"Notification"> | string | null
    eventId?: StringNullableFilter<"Notification"> | string | null
    metadata?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    organizationId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    actionUrl?: SortOrderInput | SortOrder
    deliveryMethod?: SortOrder
    priority?: SortOrder
    scheduledFor?: SortOrderInput | SortOrder
    sentAt?: SortOrderInput | SortOrder
    readAt?: SortOrderInput | SortOrder
    status?: SortOrder
    deliveryStatus?: SortOrderInput | SortOrder
    failureReason?: SortOrderInput | SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
    groupId?: SortOrderInput | SortOrder
    lessonId?: SortOrderInput | SortOrder
    eventId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    organizationId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    actionUrl?: StringNullableFilter<"Notification"> | string | null
    deliveryMethod?: EnumNotificationDeliveryMethodFilter<"Notification"> | $Enums.NotificationDeliveryMethod
    priority?: EnumNotificationPriorityFilter<"Notification"> | $Enums.NotificationPriority
    scheduledFor?: DateTimeNullableFilter<"Notification"> | Date | string | null
    sentAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    status?: EnumNotificationStatusFilter<"Notification"> | $Enums.NotificationStatus
    deliveryStatus?: JsonNullableFilter<"Notification">
    failureReason?: StringNullableFilter<"Notification"> | string | null
    retryCount?: IntFilter<"Notification"> | number
    maxRetries?: IntFilter<"Notification"> | number
    groupId?: StringNullableFilter<"Notification"> | string | null
    lessonId?: StringNullableFilter<"Notification"> | string | null
    eventId?: StringNullableFilter<"Notification"> | string | null
    metadata?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    organizationId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    actionUrl?: SortOrderInput | SortOrder
    deliveryMethod?: SortOrder
    priority?: SortOrder
    scheduledFor?: SortOrderInput | SortOrder
    sentAt?: SortOrderInput | SortOrder
    readAt?: SortOrderInput | SortOrder
    status?: SortOrder
    deliveryStatus?: SortOrderInput | SortOrder
    failureReason?: SortOrderInput | SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
    groupId?: SortOrderInput | SortOrder
    lessonId?: SortOrderInput | SortOrder
    eventId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _avg?: NotificationAvgOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
    _sum?: NotificationSumOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    organizationId?: StringWithAggregatesFilter<"Notification"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    actionUrl?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    deliveryMethod?: EnumNotificationDeliveryMethodWithAggregatesFilter<"Notification"> | $Enums.NotificationDeliveryMethod
    priority?: EnumNotificationPriorityWithAggregatesFilter<"Notification"> | $Enums.NotificationPriority
    scheduledFor?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    sentAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    readAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    status?: EnumNotificationStatusWithAggregatesFilter<"Notification"> | $Enums.NotificationStatus
    deliveryStatus?: JsonNullableWithAggregatesFilter<"Notification">
    failureReason?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    retryCount?: IntWithAggregatesFilter<"Notification"> | number
    maxRetries?: IntWithAggregatesFilter<"Notification"> | number
    groupId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    lessonId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    eventId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Notification">
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type NotificationScheduleWhereInput = {
    AND?: NotificationScheduleWhereInput | NotificationScheduleWhereInput[]
    OR?: NotificationScheduleWhereInput[]
    NOT?: NotificationScheduleWhereInput | NotificationScheduleWhereInput[]
    id?: StringFilter<"NotificationSchedule"> | string
    organizationId?: StringFilter<"NotificationSchedule"> | string
    groupId?: StringNullableFilter<"NotificationSchedule"> | string | null
    name?: StringFilter<"NotificationSchedule"> | string
    description?: StringNullableFilter<"NotificationSchedule"> | string | null
    notificationType?: EnumNotificationTypeFilter<"NotificationSchedule"> | $Enums.NotificationType
    title?: StringFilter<"NotificationSchedule"> | string
    message?: StringFilter<"NotificationSchedule"> | string
    actionUrl?: StringNullableFilter<"NotificationSchedule"> | string | null
    frequency?: EnumScheduleFrequencyFilter<"NotificationSchedule"> | $Enums.ScheduleFrequency
    dayOfWeek?: IntNullableFilter<"NotificationSchedule"> | number | null
    dayOfMonth?: IntNullableFilter<"NotificationSchedule"> | number | null
    timeOfDay?: StringFilter<"NotificationSchedule"> | string
    timezone?: StringFilter<"NotificationSchedule"> | string
    offsetDays?: IntFilter<"NotificationSchedule"> | number
    offsetHours?: IntFilter<"NotificationSchedule"> | number
    targetRoles?: JsonNullableFilter<"NotificationSchedule">
    targetUserIds?: JsonNullableFilter<"NotificationSchedule">
    isActive?: BoolFilter<"NotificationSchedule"> | boolean
    lastRunAt?: DateTimeNullableFilter<"NotificationSchedule"> | Date | string | null
    nextRunAt?: DateTimeNullableFilter<"NotificationSchedule"> | Date | string | null
    createdAt?: DateTimeFilter<"NotificationSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationSchedule"> | Date | string
  }

  export type NotificationScheduleOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    groupId?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    notificationType?: SortOrder
    title?: SortOrder
    message?: SortOrder
    actionUrl?: SortOrderInput | SortOrder
    frequency?: SortOrder
    dayOfWeek?: SortOrderInput | SortOrder
    dayOfMonth?: SortOrderInput | SortOrder
    timeOfDay?: SortOrder
    timezone?: SortOrder
    offsetDays?: SortOrder
    offsetHours?: SortOrder
    targetRoles?: SortOrderInput | SortOrder
    targetUserIds?: SortOrderInput | SortOrder
    isActive?: SortOrder
    lastRunAt?: SortOrderInput | SortOrder
    nextRunAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationScheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationScheduleWhereInput | NotificationScheduleWhereInput[]
    OR?: NotificationScheduleWhereInput[]
    NOT?: NotificationScheduleWhereInput | NotificationScheduleWhereInput[]
    organizationId?: StringFilter<"NotificationSchedule"> | string
    groupId?: StringNullableFilter<"NotificationSchedule"> | string | null
    name?: StringFilter<"NotificationSchedule"> | string
    description?: StringNullableFilter<"NotificationSchedule"> | string | null
    notificationType?: EnumNotificationTypeFilter<"NotificationSchedule"> | $Enums.NotificationType
    title?: StringFilter<"NotificationSchedule"> | string
    message?: StringFilter<"NotificationSchedule"> | string
    actionUrl?: StringNullableFilter<"NotificationSchedule"> | string | null
    frequency?: EnumScheduleFrequencyFilter<"NotificationSchedule"> | $Enums.ScheduleFrequency
    dayOfWeek?: IntNullableFilter<"NotificationSchedule"> | number | null
    dayOfMonth?: IntNullableFilter<"NotificationSchedule"> | number | null
    timeOfDay?: StringFilter<"NotificationSchedule"> | string
    timezone?: StringFilter<"NotificationSchedule"> | string
    offsetDays?: IntFilter<"NotificationSchedule"> | number
    offsetHours?: IntFilter<"NotificationSchedule"> | number
    targetRoles?: JsonNullableFilter<"NotificationSchedule">
    targetUserIds?: JsonNullableFilter<"NotificationSchedule">
    isActive?: BoolFilter<"NotificationSchedule"> | boolean
    lastRunAt?: DateTimeNullableFilter<"NotificationSchedule"> | Date | string | null
    nextRunAt?: DateTimeNullableFilter<"NotificationSchedule"> | Date | string | null
    createdAt?: DateTimeFilter<"NotificationSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationSchedule"> | Date | string
  }, "id">

  export type NotificationScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    groupId?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    notificationType?: SortOrder
    title?: SortOrder
    message?: SortOrder
    actionUrl?: SortOrderInput | SortOrder
    frequency?: SortOrder
    dayOfWeek?: SortOrderInput | SortOrder
    dayOfMonth?: SortOrderInput | SortOrder
    timeOfDay?: SortOrder
    timezone?: SortOrder
    offsetDays?: SortOrder
    offsetHours?: SortOrder
    targetRoles?: SortOrderInput | SortOrder
    targetUserIds?: SortOrderInput | SortOrder
    isActive?: SortOrder
    lastRunAt?: SortOrderInput | SortOrder
    nextRunAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationScheduleCountOrderByAggregateInput
    _avg?: NotificationScheduleAvgOrderByAggregateInput
    _max?: NotificationScheduleMaxOrderByAggregateInput
    _min?: NotificationScheduleMinOrderByAggregateInput
    _sum?: NotificationScheduleSumOrderByAggregateInput
  }

  export type NotificationScheduleScalarWhereWithAggregatesInput = {
    AND?: NotificationScheduleScalarWhereWithAggregatesInput | NotificationScheduleScalarWhereWithAggregatesInput[]
    OR?: NotificationScheduleScalarWhereWithAggregatesInput[]
    NOT?: NotificationScheduleScalarWhereWithAggregatesInput | NotificationScheduleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationSchedule"> | string
    organizationId?: StringWithAggregatesFilter<"NotificationSchedule"> | string
    groupId?: StringNullableWithAggregatesFilter<"NotificationSchedule"> | string | null
    name?: StringWithAggregatesFilter<"NotificationSchedule"> | string
    description?: StringNullableWithAggregatesFilter<"NotificationSchedule"> | string | null
    notificationType?: EnumNotificationTypeWithAggregatesFilter<"NotificationSchedule"> | $Enums.NotificationType
    title?: StringWithAggregatesFilter<"NotificationSchedule"> | string
    message?: StringWithAggregatesFilter<"NotificationSchedule"> | string
    actionUrl?: StringNullableWithAggregatesFilter<"NotificationSchedule"> | string | null
    frequency?: EnumScheduleFrequencyWithAggregatesFilter<"NotificationSchedule"> | $Enums.ScheduleFrequency
    dayOfWeek?: IntNullableWithAggregatesFilter<"NotificationSchedule"> | number | null
    dayOfMonth?: IntNullableWithAggregatesFilter<"NotificationSchedule"> | number | null
    timeOfDay?: StringWithAggregatesFilter<"NotificationSchedule"> | string
    timezone?: StringWithAggregatesFilter<"NotificationSchedule"> | string
    offsetDays?: IntWithAggregatesFilter<"NotificationSchedule"> | number
    offsetHours?: IntWithAggregatesFilter<"NotificationSchedule"> | number
    targetRoles?: JsonNullableWithAggregatesFilter<"NotificationSchedule">
    targetUserIds?: JsonNullableWithAggregatesFilter<"NotificationSchedule">
    isActive?: BoolWithAggregatesFilter<"NotificationSchedule"> | boolean
    lastRunAt?: DateTimeNullableWithAggregatesFilter<"NotificationSchedule"> | Date | string | null
    nextRunAt?: DateTimeNullableWithAggregatesFilter<"NotificationSchedule"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"NotificationSchedule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NotificationSchedule"> | Date | string
  }

  export type OrganizationCreateInput = {
    id?: string
    name: string
    slug: string
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutOrganizationInput
    groups?: GroupCreateNestedManyWithoutOrganizationInput
    integrations?: ExternalIntegrationCreateNestedManyWithoutOrganizationInput
    lessons?: LessonCreateNestedManyWithoutOrganizationInput
    aiFilterConfigs?: AIFilterConfigCreateNestedManyWithoutOrganizationInput
    comparativeThemes?: ComparativeThemeCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    groups?: GroupUncheckedCreateNestedManyWithoutOrganizationInput
    integrations?: ExternalIntegrationUncheckedCreateNestedManyWithoutOrganizationInput
    lessons?: LessonUncheckedCreateNestedManyWithoutOrganizationInput
    aiFilterConfigs?: AIFilterConfigUncheckedCreateNestedManyWithoutOrganizationInput
    comparativeThemes?: ComparativeThemeUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutOrganizationNestedInput
    groups?: GroupUpdateManyWithoutOrganizationNestedInput
    integrations?: ExternalIntegrationUpdateManyWithoutOrganizationNestedInput
    lessons?: LessonUpdateManyWithoutOrganizationNestedInput
    aiFilterConfigs?: AIFilterConfigUpdateManyWithoutOrganizationNestedInput
    comparativeThemes?: ComparativeThemeUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    groups?: GroupUncheckedUpdateManyWithoutOrganizationNestedInput
    integrations?: ExternalIntegrationUncheckedUpdateManyWithoutOrganizationNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutOrganizationNestedInput
    aiFilterConfigs?: AIFilterConfigUncheckedUpdateManyWithoutOrganizationNestedInput
    comparativeThemes?: ComparativeThemeUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationCreateManyInput = {
    id?: string
    name: string
    slug: string
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.Role
    isActive?: boolean
    externalId?: string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutUsersInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.Role
    organizationId: string
    isActive?: boolean
    externalId?: string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutUsersNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    organizationId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.Role
    organizationId: string
    isActive?: boolean
    externalId?: string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    organizationId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutRefreshTokensInput
  }

  export type RefreshTokenUncheckedCreateInput = {
    id?: string
    userId: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type RefreshTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRefreshTokensNestedInput
  }

  export type RefreshTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateManyInput = {
    id?: string
    userId: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type RefreshTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupCreateInput = {
    id?: string
    name: string
    description?: string | null
    externalId?: string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    ageMin?: number | null
    ageMax?: number | null
    grade?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutGroupsInput
    members?: GroupMemberCreateNestedManyWithoutGroupInput
    mappings?: ExternalGroupMappingCreateNestedManyWithoutGroupInput
    lessons?: LessonGroupCreateNestedManyWithoutGroupInput
  }

  export type GroupUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    organizationId: string
    externalId?: string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    ageMin?: number | null
    ageMax?: number | null
    grade?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: GroupMemberUncheckedCreateNestedManyWithoutGroupInput
    mappings?: ExternalGroupMappingUncheckedCreateNestedManyWithoutGroupInput
    lessons?: LessonGroupUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    ageMin?: NullableIntFieldUpdateOperationsInput | number | null
    ageMax?: NullableIntFieldUpdateOperationsInput | number | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutGroupsNestedInput
    members?: GroupMemberUpdateManyWithoutGroupNestedInput
    mappings?: ExternalGroupMappingUpdateManyWithoutGroupNestedInput
    lessons?: LessonGroupUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    ageMin?: NullableIntFieldUpdateOperationsInput | number | null
    ageMax?: NullableIntFieldUpdateOperationsInput | number | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: GroupMemberUncheckedUpdateManyWithoutGroupNestedInput
    mappings?: ExternalGroupMappingUncheckedUpdateManyWithoutGroupNestedInput
    lessons?: LessonGroupUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type GroupCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    organizationId: string
    externalId?: string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    ageMin?: number | null
    ageMax?: number | null
    grade?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    ageMin?: NullableIntFieldUpdateOperationsInput | number | null
    ageMax?: NullableIntFieldUpdateOperationsInput | number | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    ageMin?: NullableIntFieldUpdateOperationsInput | number | null
    ageMax?: NullableIntFieldUpdateOperationsInput | number | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMemberCreateInput = {
    id?: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutGroupMembershipsInput
    group: GroupCreateNestedOneWithoutMembersInput
  }

  export type GroupMemberUncheckedCreateInput = {
    id?: string
    userId: string
    groupId: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutGroupMembershipsNestedInput
    group?: GroupUpdateOneRequiredWithoutMembersNestedInput
  }

  export type GroupMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMemberCreateManyInput = {
    id?: string
    userId: string
    groupId: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExternalIntegrationCreateInput = {
    id?: string
    provider: $Enums.IntegrationProvider
    status?: $Enums.IntegrationStatus
    credentialsEncrypted: string
    credentialsIV: string
    credentialsTag: string
    accessToken?: string | null
    refreshToken?: string | null
    tokenExpiresAt?: Date | string | null
    apiBaseUrl?: string | null
    apiVersion?: string | null
    syncEnabled?: boolean
    syncFrequency?: $Enums.SyncFrequency
    lastSyncAt?: Date | string | null
    lastSyncStatus?: $Enums.SyncStatus | null
    nextSyncAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutIntegrationsInput
    groupMappings?: ExternalGroupMappingCreateNestedManyWithoutIntegrationInput
    syncLogs?: SyncLogCreateNestedManyWithoutIntegrationInput
  }

  export type ExternalIntegrationUncheckedCreateInput = {
    id?: string
    organizationId: string
    provider: $Enums.IntegrationProvider
    status?: $Enums.IntegrationStatus
    credentialsEncrypted: string
    credentialsIV: string
    credentialsTag: string
    accessToken?: string | null
    refreshToken?: string | null
    tokenExpiresAt?: Date | string | null
    apiBaseUrl?: string | null
    apiVersion?: string | null
    syncEnabled?: boolean
    syncFrequency?: $Enums.SyncFrequency
    lastSyncAt?: Date | string | null
    lastSyncStatus?: $Enums.SyncStatus | null
    nextSyncAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    groupMappings?: ExternalGroupMappingUncheckedCreateNestedManyWithoutIntegrationInput
    syncLogs?: SyncLogUncheckedCreateNestedManyWithoutIntegrationInput
  }

  export type ExternalIntegrationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumIntegrationProviderFieldUpdateOperationsInput | $Enums.IntegrationProvider
    status?: EnumIntegrationStatusFieldUpdateOperationsInput | $Enums.IntegrationStatus
    credentialsEncrypted?: StringFieldUpdateOperationsInput | string
    credentialsIV?: StringFieldUpdateOperationsInput | string
    credentialsTag?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    apiBaseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    apiVersion?: NullableStringFieldUpdateOperationsInput | string | null
    syncEnabled?: BoolFieldUpdateOperationsInput | boolean
    syncFrequency?: EnumSyncFrequencyFieldUpdateOperationsInput | $Enums.SyncFrequency
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSyncStatus?: NullableEnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus | null
    nextSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutIntegrationsNestedInput
    groupMappings?: ExternalGroupMappingUpdateManyWithoutIntegrationNestedInput
    syncLogs?: SyncLogUpdateManyWithoutIntegrationNestedInput
  }

  export type ExternalIntegrationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    provider?: EnumIntegrationProviderFieldUpdateOperationsInput | $Enums.IntegrationProvider
    status?: EnumIntegrationStatusFieldUpdateOperationsInput | $Enums.IntegrationStatus
    credentialsEncrypted?: StringFieldUpdateOperationsInput | string
    credentialsIV?: StringFieldUpdateOperationsInput | string
    credentialsTag?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    apiBaseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    apiVersion?: NullableStringFieldUpdateOperationsInput | string | null
    syncEnabled?: BoolFieldUpdateOperationsInput | boolean
    syncFrequency?: EnumSyncFrequencyFieldUpdateOperationsInput | $Enums.SyncFrequency
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSyncStatus?: NullableEnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus | null
    nextSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupMappings?: ExternalGroupMappingUncheckedUpdateManyWithoutIntegrationNestedInput
    syncLogs?: SyncLogUncheckedUpdateManyWithoutIntegrationNestedInput
  }

  export type ExternalIntegrationCreateManyInput = {
    id?: string
    organizationId: string
    provider: $Enums.IntegrationProvider
    status?: $Enums.IntegrationStatus
    credentialsEncrypted: string
    credentialsIV: string
    credentialsTag: string
    accessToken?: string | null
    refreshToken?: string | null
    tokenExpiresAt?: Date | string | null
    apiBaseUrl?: string | null
    apiVersion?: string | null
    syncEnabled?: boolean
    syncFrequency?: $Enums.SyncFrequency
    lastSyncAt?: Date | string | null
    lastSyncStatus?: $Enums.SyncStatus | null
    nextSyncAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExternalIntegrationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumIntegrationProviderFieldUpdateOperationsInput | $Enums.IntegrationProvider
    status?: EnumIntegrationStatusFieldUpdateOperationsInput | $Enums.IntegrationStatus
    credentialsEncrypted?: StringFieldUpdateOperationsInput | string
    credentialsIV?: StringFieldUpdateOperationsInput | string
    credentialsTag?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    apiBaseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    apiVersion?: NullableStringFieldUpdateOperationsInput | string | null
    syncEnabled?: BoolFieldUpdateOperationsInput | boolean
    syncFrequency?: EnumSyncFrequencyFieldUpdateOperationsInput | $Enums.SyncFrequency
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSyncStatus?: NullableEnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus | null
    nextSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExternalIntegrationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    provider?: EnumIntegrationProviderFieldUpdateOperationsInput | $Enums.IntegrationProvider
    status?: EnumIntegrationStatusFieldUpdateOperationsInput | $Enums.IntegrationStatus
    credentialsEncrypted?: StringFieldUpdateOperationsInput | string
    credentialsIV?: StringFieldUpdateOperationsInput | string
    credentialsTag?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    apiBaseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    apiVersion?: NullableStringFieldUpdateOperationsInput | string | null
    syncEnabled?: BoolFieldUpdateOperationsInput | boolean
    syncFrequency?: EnumSyncFrequencyFieldUpdateOperationsInput | $Enums.SyncFrequency
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSyncStatus?: NullableEnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus | null
    nextSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExternalGroupMappingCreateInput = {
    id?: string
    externalGroupId: string
    externalGroupName: string
    externalGroupType?: string | null
    syncMembers?: boolean
    syncLeaders?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    integration: ExternalIntegrationCreateNestedOneWithoutGroupMappingsInput
    group?: GroupCreateNestedOneWithoutMappingsInput
  }

  export type ExternalGroupMappingUncheckedCreateInput = {
    id?: string
    integrationId: string
    externalGroupId: string
    externalGroupName: string
    externalGroupType?: string | null
    groupId?: string | null
    syncMembers?: boolean
    syncLeaders?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExternalGroupMappingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalGroupId?: StringFieldUpdateOperationsInput | string
    externalGroupName?: StringFieldUpdateOperationsInput | string
    externalGroupType?: NullableStringFieldUpdateOperationsInput | string | null
    syncMembers?: BoolFieldUpdateOperationsInput | boolean
    syncLeaders?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    integration?: ExternalIntegrationUpdateOneRequiredWithoutGroupMappingsNestedInput
    group?: GroupUpdateOneWithoutMappingsNestedInput
  }

  export type ExternalGroupMappingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    integrationId?: StringFieldUpdateOperationsInput | string
    externalGroupId?: StringFieldUpdateOperationsInput | string
    externalGroupName?: StringFieldUpdateOperationsInput | string
    externalGroupType?: NullableStringFieldUpdateOperationsInput | string | null
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    syncMembers?: BoolFieldUpdateOperationsInput | boolean
    syncLeaders?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExternalGroupMappingCreateManyInput = {
    id?: string
    integrationId: string
    externalGroupId: string
    externalGroupName: string
    externalGroupType?: string | null
    groupId?: string | null
    syncMembers?: boolean
    syncLeaders?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExternalGroupMappingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalGroupId?: StringFieldUpdateOperationsInput | string
    externalGroupName?: StringFieldUpdateOperationsInput | string
    externalGroupType?: NullableStringFieldUpdateOperationsInput | string | null
    syncMembers?: BoolFieldUpdateOperationsInput | boolean
    syncLeaders?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExternalGroupMappingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    integrationId?: StringFieldUpdateOperationsInput | string
    externalGroupId?: StringFieldUpdateOperationsInput | string
    externalGroupName?: StringFieldUpdateOperationsInput | string
    externalGroupType?: NullableStringFieldUpdateOperationsInput | string | null
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    syncMembers?: BoolFieldUpdateOperationsInput | boolean
    syncLeaders?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyncLogCreateInput = {
    id?: string
    status: $Enums.SyncStatus
    startedAt?: Date | string
    completedAt?: Date | string | null
    durationMs?: number | null
    peopleAdded?: number
    peopleUpdated?: number
    peopleRemoved?: number
    groupsAdded?: number
    groupsUpdated?: number
    groupsSkipped?: number
    errorMessage?: string | null
    errorCode?: string | null
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    integration: ExternalIntegrationCreateNestedOneWithoutSyncLogsInput
  }

  export type SyncLogUncheckedCreateInput = {
    id?: string
    integrationId: string
    status: $Enums.SyncStatus
    startedAt?: Date | string
    completedAt?: Date | string | null
    durationMs?: number | null
    peopleAdded?: number
    peopleUpdated?: number
    peopleRemoved?: number
    groupsAdded?: number
    groupsUpdated?: number
    groupsSkipped?: number
    errorMessage?: string | null
    errorCode?: string | null
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SyncLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    peopleAdded?: IntFieldUpdateOperationsInput | number
    peopleUpdated?: IntFieldUpdateOperationsInput | number
    peopleRemoved?: IntFieldUpdateOperationsInput | number
    groupsAdded?: IntFieldUpdateOperationsInput | number
    groupsUpdated?: IntFieldUpdateOperationsInput | number
    groupsSkipped?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    integration?: ExternalIntegrationUpdateOneRequiredWithoutSyncLogsNestedInput
  }

  export type SyncLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    integrationId?: StringFieldUpdateOperationsInput | string
    status?: EnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    peopleAdded?: IntFieldUpdateOperationsInput | number
    peopleUpdated?: IntFieldUpdateOperationsInput | number
    peopleRemoved?: IntFieldUpdateOperationsInput | number
    groupsAdded?: IntFieldUpdateOperationsInput | number
    groupsUpdated?: IntFieldUpdateOperationsInput | number
    groupsSkipped?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SyncLogCreateManyInput = {
    id?: string
    integrationId: string
    status: $Enums.SyncStatus
    startedAt?: Date | string
    completedAt?: Date | string | null
    durationMs?: number | null
    peopleAdded?: number
    peopleUpdated?: number
    peopleRemoved?: number
    groupsAdded?: number
    groupsUpdated?: number
    groupsSkipped?: number
    errorMessage?: string | null
    errorCode?: string | null
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SyncLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    peopleAdded?: IntFieldUpdateOperationsInput | number
    peopleUpdated?: IntFieldUpdateOperationsInput | number
    peopleRemoved?: IntFieldUpdateOperationsInput | number
    groupsAdded?: IntFieldUpdateOperationsInput | number
    groupsUpdated?: IntFieldUpdateOperationsInput | number
    groupsSkipped?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SyncLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    integrationId?: StringFieldUpdateOperationsInput | string
    status?: EnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    peopleAdded?: IntFieldUpdateOperationsInput | number
    peopleUpdated?: IntFieldUpdateOperationsInput | number
    peopleRemoved?: IntFieldUpdateOperationsInput | number
    groupsAdded?: IntFieldUpdateOperationsInput | number
    groupsUpdated?: IntFieldUpdateOperationsInput | number
    groupsSkipped?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type LessonCreateInput = {
    id?: string
    title: string
    quarter: number
    unit: number
    lessonNumber: number
    scripture: string
    content: JsonNullValueInput | InputJsonValue
    slides?: NullableJsonNullValueInput | InputJsonValue
    games?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: boolean
    isTemplate?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutLessonsInput
    groups?: LessonGroupCreateNestedManyWithoutLessonInput
  }

  export type LessonUncheckedCreateInput = {
    id?: string
    organizationId: string
    title: string
    quarter: number
    unit: number
    lessonNumber: number
    scripture: string
    content: JsonNullValueInput | InputJsonValue
    slides?: NullableJsonNullValueInput | InputJsonValue
    games?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: boolean
    isTemplate?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    groups?: LessonGroupUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    quarter?: IntFieldUpdateOperationsInput | number
    unit?: IntFieldUpdateOperationsInput | number
    lessonNumber?: IntFieldUpdateOperationsInput | number
    scripture?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    slides?: NullableJsonNullValueInput | InputJsonValue
    games?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutLessonsNestedInput
    groups?: LessonGroupUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    quarter?: IntFieldUpdateOperationsInput | number
    unit?: IntFieldUpdateOperationsInput | number
    lessonNumber?: IntFieldUpdateOperationsInput | number
    scripture?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    slides?: NullableJsonNullValueInput | InputJsonValue
    games?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groups?: LessonGroupUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type LessonCreateManyInput = {
    id?: string
    organizationId: string
    title: string
    quarter: number
    unit: number
    lessonNumber: number
    scripture: string
    content: JsonNullValueInput | InputJsonValue
    slides?: NullableJsonNullValueInput | InputJsonValue
    games?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: boolean
    isTemplate?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LessonUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    quarter?: IntFieldUpdateOperationsInput | number
    unit?: IntFieldUpdateOperationsInput | number
    lessonNumber?: IntFieldUpdateOperationsInput | number
    scripture?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    slides?: NullableJsonNullValueInput | InputJsonValue
    games?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    quarter?: IntFieldUpdateOperationsInput | number
    unit?: IntFieldUpdateOperationsInput | number
    lessonNumber?: IntFieldUpdateOperationsInput | number
    scripture?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    slides?: NullableJsonNullValueInput | InputJsonValue
    games?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonGroupCreateInput = {
    id?: string
    createdAt?: Date | string
    lesson: LessonCreateNestedOneWithoutGroupsInput
    group: GroupCreateNestedOneWithoutLessonsInput
  }

  export type LessonGroupUncheckedCreateInput = {
    id?: string
    lessonId: string
    groupId: string
    createdAt?: Date | string
  }

  export type LessonGroupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lesson?: LessonUpdateOneRequiredWithoutGroupsNestedInput
    group?: GroupUpdateOneRequiredWithoutLessonsNestedInput
  }

  export type LessonGroupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonGroupCreateManyInput = {
    id?: string
    lessonId: string
    groupId: string
    createdAt?: Date | string
  }

  export type LessonGroupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonGroupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIFilterConfigCreateInput = {
    id?: string
    filterRules: JsonNullValueInput | InputJsonValue
    customKeywords?: NullableJsonNullValueInput | InputJsonValue
    redirectMessage?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organization?: OrganizationCreateNestedOneWithoutAiFilterConfigsInput
    metrics?: AIFilterMetricCreateNestedManyWithoutFilterInput
  }

  export type AIFilterConfigUncheckedCreateInput = {
    id?: string
    organizationId?: string | null
    filterRules: JsonNullValueInput | InputJsonValue
    customKeywords?: NullableJsonNullValueInput | InputJsonValue
    redirectMessage?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    metrics?: AIFilterMetricUncheckedCreateNestedManyWithoutFilterInput
  }

  export type AIFilterConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filterRules?: JsonNullValueInput | InputJsonValue
    customKeywords?: NullableJsonNullValueInput | InputJsonValue
    redirectMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutAiFilterConfigsNestedInput
    metrics?: AIFilterMetricUpdateManyWithoutFilterNestedInput
  }

  export type AIFilterConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    filterRules?: JsonNullValueInput | InputJsonValue
    customKeywords?: NullableJsonNullValueInput | InputJsonValue
    redirectMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metrics?: AIFilterMetricUncheckedUpdateManyWithoutFilterNestedInput
  }

  export type AIFilterConfigCreateManyInput = {
    id?: string
    organizationId?: string | null
    filterRules: JsonNullValueInput | InputJsonValue
    customKeywords?: NullableJsonNullValueInput | InputJsonValue
    redirectMessage?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIFilterConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    filterRules?: JsonNullValueInput | InputJsonValue
    customKeywords?: NullableJsonNullValueInput | InputJsonValue
    redirectMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIFilterConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    filterRules?: JsonNullValueInput | InputJsonValue
    customKeywords?: NullableJsonNullValueInput | InputJsonValue
    redirectMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIFilterMetricCreateInput = {
    id?: string
    organizationId?: string | null
    query: string
    detectedCategory: $Enums.FilterCategory
    actionTaken: $Enums.FilterAction
    userId?: string | null
    groupId?: string | null
    featureName?: string | null
    leaderNotified?: boolean
    leaderResponse?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    filter: AIFilterConfigCreateNestedOneWithoutMetricsInput
  }

  export type AIFilterMetricUncheckedCreateInput = {
    id?: string
    filterId: string
    organizationId?: string | null
    query: string
    detectedCategory: $Enums.FilterCategory
    actionTaken: $Enums.FilterAction
    userId?: string | null
    groupId?: string | null
    featureName?: string | null
    leaderNotified?: boolean
    leaderResponse?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AIFilterMetricUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    query?: StringFieldUpdateOperationsInput | string
    detectedCategory?: EnumFilterCategoryFieldUpdateOperationsInput | $Enums.FilterCategory
    actionTaken?: EnumFilterActionFieldUpdateOperationsInput | $Enums.FilterAction
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    featureName?: NullableStringFieldUpdateOperationsInput | string | null
    leaderNotified?: BoolFieldUpdateOperationsInput | boolean
    leaderResponse?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    filter?: AIFilterConfigUpdateOneRequiredWithoutMetricsNestedInput
  }

  export type AIFilterMetricUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filterId?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    query?: StringFieldUpdateOperationsInput | string
    detectedCategory?: EnumFilterCategoryFieldUpdateOperationsInput | $Enums.FilterCategory
    actionTaken?: EnumFilterActionFieldUpdateOperationsInput | $Enums.FilterAction
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    featureName?: NullableStringFieldUpdateOperationsInput | string | null
    leaderNotified?: BoolFieldUpdateOperationsInput | boolean
    leaderResponse?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIFilterMetricCreateManyInput = {
    id?: string
    filterId: string
    organizationId?: string | null
    query: string
    detectedCategory: $Enums.FilterCategory
    actionTaken: $Enums.FilterAction
    userId?: string | null
    groupId?: string | null
    featureName?: string | null
    leaderNotified?: boolean
    leaderResponse?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AIFilterMetricUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    query?: StringFieldUpdateOperationsInput | string
    detectedCategory?: EnumFilterCategoryFieldUpdateOperationsInput | $Enums.FilterCategory
    actionTaken?: EnumFilterActionFieldUpdateOperationsInput | $Enums.FilterAction
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    featureName?: NullableStringFieldUpdateOperationsInput | string | null
    leaderNotified?: BoolFieldUpdateOperationsInput | boolean
    leaderResponse?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIFilterMetricUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    filterId?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    query?: StringFieldUpdateOperationsInput | string
    detectedCategory?: EnumFilterCategoryFieldUpdateOperationsInput | $Enums.FilterCategory
    actionTaken?: EnumFilterActionFieldUpdateOperationsInput | $Enums.FilterAction
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    featureName?: NullableStringFieldUpdateOperationsInput | string | null
    leaderNotified?: BoolFieldUpdateOperationsInput | boolean
    leaderResponse?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComparativeThemeCreateInput = {
    id?: string
    themeName: string
    description?: string | null
    category?: string | null
    otPassages: JsonNullValueInput | InputJsonValue
    ntPassages: JsonNullValueInput | InputJsonValue
    themeNotes?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutComparativeThemesInput
    metrics?: ThemeMetricCreateNestedManyWithoutThemeInput
  }

  export type ComparativeThemeUncheckedCreateInput = {
    id?: string
    organizationId: string
    themeName: string
    description?: string | null
    category?: string | null
    otPassages: JsonNullValueInput | InputJsonValue
    ntPassages: JsonNullValueInput | InputJsonValue
    themeNotes?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metrics?: ThemeMetricUncheckedCreateNestedManyWithoutThemeInput
  }

  export type ComparativeThemeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    themeName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    otPassages?: JsonNullValueInput | InputJsonValue
    ntPassages?: JsonNullValueInput | InputJsonValue
    themeNotes?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutComparativeThemesNestedInput
    metrics?: ThemeMetricUpdateManyWithoutThemeNestedInput
  }

  export type ComparativeThemeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    themeName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    otPassages?: JsonNullValueInput | InputJsonValue
    ntPassages?: JsonNullValueInput | InputJsonValue
    themeNotes?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metrics?: ThemeMetricUncheckedUpdateManyWithoutThemeNestedInput
  }

  export type ComparativeThemeCreateManyInput = {
    id?: string
    organizationId: string
    themeName: string
    description?: string | null
    category?: string | null
    otPassages: JsonNullValueInput | InputJsonValue
    ntPassages: JsonNullValueInput | InputJsonValue
    themeNotes?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComparativeThemeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    themeName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    otPassages?: JsonNullValueInput | InputJsonValue
    ntPassages?: JsonNullValueInput | InputJsonValue
    themeNotes?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComparativeThemeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    themeName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    otPassages?: JsonNullValueInput | InputJsonValue
    ntPassages?: JsonNullValueInput | InputJsonValue
    themeNotes?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ThemeMetricCreateInput = {
    id?: string
    organizationId: string
    viewCount?: number
    lastViewedAt?: Date | string
    userId?: string | null
    featureContext?: string | null
    timeSpentMs?: number | null
    usedInLesson?: boolean
    lessonId?: string | null
    createdAt?: Date | string
    theme: ComparativeThemeCreateNestedOneWithoutMetricsInput
  }

  export type ThemeMetricUncheckedCreateInput = {
    id?: string
    themeId: string
    organizationId: string
    viewCount?: number
    lastViewedAt?: Date | string
    userId?: string | null
    featureContext?: string | null
    timeSpentMs?: number | null
    usedInLesson?: boolean
    lessonId?: string | null
    createdAt?: Date | string
  }

  export type ThemeMetricUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    viewCount?: IntFieldUpdateOperationsInput | number
    lastViewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    featureContext?: NullableStringFieldUpdateOperationsInput | string | null
    timeSpentMs?: NullableIntFieldUpdateOperationsInput | number | null
    usedInLesson?: BoolFieldUpdateOperationsInput | boolean
    lessonId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    theme?: ComparativeThemeUpdateOneRequiredWithoutMetricsNestedInput
  }

  export type ThemeMetricUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    themeId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    viewCount?: IntFieldUpdateOperationsInput | number
    lastViewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    featureContext?: NullableStringFieldUpdateOperationsInput | string | null
    timeSpentMs?: NullableIntFieldUpdateOperationsInput | number | null
    usedInLesson?: BoolFieldUpdateOperationsInput | boolean
    lessonId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ThemeMetricCreateManyInput = {
    id?: string
    themeId: string
    organizationId: string
    viewCount?: number
    lastViewedAt?: Date | string
    userId?: string | null
    featureContext?: string | null
    timeSpentMs?: number | null
    usedInLesson?: boolean
    lessonId?: string | null
    createdAt?: Date | string
  }

  export type ThemeMetricUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    viewCount?: IntFieldUpdateOperationsInput | number
    lastViewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    featureContext?: NullableStringFieldUpdateOperationsInput | string | null
    timeSpentMs?: NullableIntFieldUpdateOperationsInput | number | null
    usedInLesson?: BoolFieldUpdateOperationsInput | boolean
    lessonId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ThemeMetricUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    themeId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    viewCount?: IntFieldUpdateOperationsInput | number
    lastViewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    featureContext?: NullableStringFieldUpdateOperationsInput | string | null
    timeSpentMs?: NullableIntFieldUpdateOperationsInput | number | null
    usedInLesson?: BoolFieldUpdateOperationsInput | boolean
    lessonId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceCreateInput = {
    id?: string
    emailEnabled?: boolean
    emailLessonReminders?: boolean
    emailEventReminders?: boolean
    emailAnnouncements?: boolean
    emailGroupUpdates?: boolean
    emailDigest?: boolean
    emailDigestFrequency?: $Enums.DigestFrequency
    inAppEnabled?: boolean
    inAppLessonReminders?: boolean
    inAppEventReminders?: boolean
    inAppAnnouncements?: boolean
    inAppGroupUpdates?: boolean
    quietHoursEnabled?: boolean
    quietHoursStart?: string | null
    quietHoursEnd?: string | null
    quietHoursTimezone?: string
    preferredDays?: NullableJsonNullValueInput | InputJsonValue
    lessonReminderDays?: number
    lessonReminderTime?: string
    eventReminderHours?: number
    batchNotifications?: boolean
    maxNotificationsPerDay?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationPreferenceInput
  }

  export type NotificationPreferenceUncheckedCreateInput = {
    id?: string
    userId: string
    emailEnabled?: boolean
    emailLessonReminders?: boolean
    emailEventReminders?: boolean
    emailAnnouncements?: boolean
    emailGroupUpdates?: boolean
    emailDigest?: boolean
    emailDigestFrequency?: $Enums.DigestFrequency
    inAppEnabled?: boolean
    inAppLessonReminders?: boolean
    inAppEventReminders?: boolean
    inAppAnnouncements?: boolean
    inAppGroupUpdates?: boolean
    quietHoursEnabled?: boolean
    quietHoursStart?: string | null
    quietHoursEnd?: string | null
    quietHoursTimezone?: string
    preferredDays?: NullableJsonNullValueInput | InputJsonValue
    lessonReminderDays?: number
    lessonReminderTime?: string
    eventReminderHours?: number
    batchNotifications?: boolean
    maxNotificationsPerDay?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPreferenceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    emailLessonReminders?: BoolFieldUpdateOperationsInput | boolean
    emailEventReminders?: BoolFieldUpdateOperationsInput | boolean
    emailAnnouncements?: BoolFieldUpdateOperationsInput | boolean
    emailGroupUpdates?: BoolFieldUpdateOperationsInput | boolean
    emailDigest?: BoolFieldUpdateOperationsInput | boolean
    emailDigestFrequency?: EnumDigestFrequencyFieldUpdateOperationsInput | $Enums.DigestFrequency
    inAppEnabled?: BoolFieldUpdateOperationsInput | boolean
    inAppLessonReminders?: BoolFieldUpdateOperationsInput | boolean
    inAppEventReminders?: BoolFieldUpdateOperationsInput | boolean
    inAppAnnouncements?: BoolFieldUpdateOperationsInput | boolean
    inAppGroupUpdates?: BoolFieldUpdateOperationsInput | boolean
    quietHoursEnabled?: BoolFieldUpdateOperationsInput | boolean
    quietHoursStart?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursEnd?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursTimezone?: StringFieldUpdateOperationsInput | string
    preferredDays?: NullableJsonNullValueInput | InputJsonValue
    lessonReminderDays?: IntFieldUpdateOperationsInput | number
    lessonReminderTime?: StringFieldUpdateOperationsInput | string
    eventReminderHours?: IntFieldUpdateOperationsInput | number
    batchNotifications?: BoolFieldUpdateOperationsInput | boolean
    maxNotificationsPerDay?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationPreferenceNestedInput
  }

  export type NotificationPreferenceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    emailLessonReminders?: BoolFieldUpdateOperationsInput | boolean
    emailEventReminders?: BoolFieldUpdateOperationsInput | boolean
    emailAnnouncements?: BoolFieldUpdateOperationsInput | boolean
    emailGroupUpdates?: BoolFieldUpdateOperationsInput | boolean
    emailDigest?: BoolFieldUpdateOperationsInput | boolean
    emailDigestFrequency?: EnumDigestFrequencyFieldUpdateOperationsInput | $Enums.DigestFrequency
    inAppEnabled?: BoolFieldUpdateOperationsInput | boolean
    inAppLessonReminders?: BoolFieldUpdateOperationsInput | boolean
    inAppEventReminders?: BoolFieldUpdateOperationsInput | boolean
    inAppAnnouncements?: BoolFieldUpdateOperationsInput | boolean
    inAppGroupUpdates?: BoolFieldUpdateOperationsInput | boolean
    quietHoursEnabled?: BoolFieldUpdateOperationsInput | boolean
    quietHoursStart?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursEnd?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursTimezone?: StringFieldUpdateOperationsInput | string
    preferredDays?: NullableJsonNullValueInput | InputJsonValue
    lessonReminderDays?: IntFieldUpdateOperationsInput | number
    lessonReminderTime?: StringFieldUpdateOperationsInput | string
    eventReminderHours?: IntFieldUpdateOperationsInput | number
    batchNotifications?: BoolFieldUpdateOperationsInput | boolean
    maxNotificationsPerDay?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceCreateManyInput = {
    id?: string
    userId: string
    emailEnabled?: boolean
    emailLessonReminders?: boolean
    emailEventReminders?: boolean
    emailAnnouncements?: boolean
    emailGroupUpdates?: boolean
    emailDigest?: boolean
    emailDigestFrequency?: $Enums.DigestFrequency
    inAppEnabled?: boolean
    inAppLessonReminders?: boolean
    inAppEventReminders?: boolean
    inAppAnnouncements?: boolean
    inAppGroupUpdates?: boolean
    quietHoursEnabled?: boolean
    quietHoursStart?: string | null
    quietHoursEnd?: string | null
    quietHoursTimezone?: string
    preferredDays?: NullableJsonNullValueInput | InputJsonValue
    lessonReminderDays?: number
    lessonReminderTime?: string
    eventReminderHours?: number
    batchNotifications?: boolean
    maxNotificationsPerDay?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPreferenceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    emailLessonReminders?: BoolFieldUpdateOperationsInput | boolean
    emailEventReminders?: BoolFieldUpdateOperationsInput | boolean
    emailAnnouncements?: BoolFieldUpdateOperationsInput | boolean
    emailGroupUpdates?: BoolFieldUpdateOperationsInput | boolean
    emailDigest?: BoolFieldUpdateOperationsInput | boolean
    emailDigestFrequency?: EnumDigestFrequencyFieldUpdateOperationsInput | $Enums.DigestFrequency
    inAppEnabled?: BoolFieldUpdateOperationsInput | boolean
    inAppLessonReminders?: BoolFieldUpdateOperationsInput | boolean
    inAppEventReminders?: BoolFieldUpdateOperationsInput | boolean
    inAppAnnouncements?: BoolFieldUpdateOperationsInput | boolean
    inAppGroupUpdates?: BoolFieldUpdateOperationsInput | boolean
    quietHoursEnabled?: BoolFieldUpdateOperationsInput | boolean
    quietHoursStart?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursEnd?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursTimezone?: StringFieldUpdateOperationsInput | string
    preferredDays?: NullableJsonNullValueInput | InputJsonValue
    lessonReminderDays?: IntFieldUpdateOperationsInput | number
    lessonReminderTime?: StringFieldUpdateOperationsInput | string
    eventReminderHours?: IntFieldUpdateOperationsInput | number
    batchNotifications?: BoolFieldUpdateOperationsInput | boolean
    maxNotificationsPerDay?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    emailLessonReminders?: BoolFieldUpdateOperationsInput | boolean
    emailEventReminders?: BoolFieldUpdateOperationsInput | boolean
    emailAnnouncements?: BoolFieldUpdateOperationsInput | boolean
    emailGroupUpdates?: BoolFieldUpdateOperationsInput | boolean
    emailDigest?: BoolFieldUpdateOperationsInput | boolean
    emailDigestFrequency?: EnumDigestFrequencyFieldUpdateOperationsInput | $Enums.DigestFrequency
    inAppEnabled?: BoolFieldUpdateOperationsInput | boolean
    inAppLessonReminders?: BoolFieldUpdateOperationsInput | boolean
    inAppEventReminders?: BoolFieldUpdateOperationsInput | boolean
    inAppAnnouncements?: BoolFieldUpdateOperationsInput | boolean
    inAppGroupUpdates?: BoolFieldUpdateOperationsInput | boolean
    quietHoursEnabled?: BoolFieldUpdateOperationsInput | boolean
    quietHoursStart?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursEnd?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursTimezone?: StringFieldUpdateOperationsInput | string
    preferredDays?: NullableJsonNullValueInput | InputJsonValue
    lessonReminderDays?: IntFieldUpdateOperationsInput | number
    lessonReminderTime?: StringFieldUpdateOperationsInput | string
    eventReminderHours?: IntFieldUpdateOperationsInput | number
    batchNotifications?: BoolFieldUpdateOperationsInput | boolean
    maxNotificationsPerDay?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    organizationId: string
    type: $Enums.NotificationType
    title: string
    message: string
    actionUrl?: string | null
    deliveryMethod?: $Enums.NotificationDeliveryMethod
    priority?: $Enums.NotificationPriority
    scheduledFor?: Date | string | null
    sentAt?: Date | string | null
    readAt?: Date | string | null
    status?: $Enums.NotificationStatus
    deliveryStatus?: NullableJsonNullValueInput | InputJsonValue
    failureReason?: string | null
    retryCount?: number
    maxRetries?: number
    groupId?: string | null
    lessonId?: string | null
    eventId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    organizationId: string
    type: $Enums.NotificationType
    title: string
    message: string
    actionUrl?: string | null
    deliveryMethod?: $Enums.NotificationDeliveryMethod
    priority?: $Enums.NotificationPriority
    scheduledFor?: Date | string | null
    sentAt?: Date | string | null
    readAt?: Date | string | null
    status?: $Enums.NotificationStatus
    deliveryStatus?: NullableJsonNullValueInput | InputJsonValue
    failureReason?: string | null
    retryCount?: number
    maxRetries?: number
    groupId?: string | null
    lessonId?: string | null
    eventId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryMethod?: EnumNotificationDeliveryMethodFieldUpdateOperationsInput | $Enums.NotificationDeliveryMethod
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    deliveryStatus?: NullableJsonNullValueInput | InputJsonValue
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    lessonId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryMethod?: EnumNotificationDeliveryMethodFieldUpdateOperationsInput | $Enums.NotificationDeliveryMethod
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    deliveryStatus?: NullableJsonNullValueInput | InputJsonValue
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    lessonId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    organizationId: string
    type: $Enums.NotificationType
    title: string
    message: string
    actionUrl?: string | null
    deliveryMethod?: $Enums.NotificationDeliveryMethod
    priority?: $Enums.NotificationPriority
    scheduledFor?: Date | string | null
    sentAt?: Date | string | null
    readAt?: Date | string | null
    status?: $Enums.NotificationStatus
    deliveryStatus?: NullableJsonNullValueInput | InputJsonValue
    failureReason?: string | null
    retryCount?: number
    maxRetries?: number
    groupId?: string | null
    lessonId?: string | null
    eventId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryMethod?: EnumNotificationDeliveryMethodFieldUpdateOperationsInput | $Enums.NotificationDeliveryMethod
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    deliveryStatus?: NullableJsonNullValueInput | InputJsonValue
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    lessonId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryMethod?: EnumNotificationDeliveryMethodFieldUpdateOperationsInput | $Enums.NotificationDeliveryMethod
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    deliveryStatus?: NullableJsonNullValueInput | InputJsonValue
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    lessonId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationScheduleCreateInput = {
    id?: string
    organizationId: string
    groupId?: string | null
    name: string
    description?: string | null
    notificationType: $Enums.NotificationType
    title: string
    message: string
    actionUrl?: string | null
    frequency: $Enums.ScheduleFrequency
    dayOfWeek?: number | null
    dayOfMonth?: number | null
    timeOfDay: string
    timezone?: string
    offsetDays?: number
    offsetHours?: number
    targetRoles?: NullableJsonNullValueInput | InputJsonValue
    targetUserIds?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastRunAt?: Date | string | null
    nextRunAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationScheduleUncheckedCreateInput = {
    id?: string
    organizationId: string
    groupId?: string | null
    name: string
    description?: string | null
    notificationType: $Enums.NotificationType
    title: string
    message: string
    actionUrl?: string | null
    frequency: $Enums.ScheduleFrequency
    dayOfWeek?: number | null
    dayOfMonth?: number | null
    timeOfDay: string
    timezone?: string
    offsetDays?: number
    offsetHours?: number
    targetRoles?: NullableJsonNullValueInput | InputJsonValue
    targetUserIds?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastRunAt?: Date | string | null
    nextRunAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationScheduleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notificationType?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: EnumScheduleFrequencyFieldUpdateOperationsInput | $Enums.ScheduleFrequency
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    dayOfMonth?: NullableIntFieldUpdateOperationsInput | number | null
    timeOfDay?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    offsetDays?: IntFieldUpdateOperationsInput | number
    offsetHours?: IntFieldUpdateOperationsInput | number
    targetRoles?: NullableJsonNullValueInput | InputJsonValue
    targetUserIds?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationScheduleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notificationType?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: EnumScheduleFrequencyFieldUpdateOperationsInput | $Enums.ScheduleFrequency
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    dayOfMonth?: NullableIntFieldUpdateOperationsInput | number | null
    timeOfDay?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    offsetDays?: IntFieldUpdateOperationsInput | number
    offsetHours?: IntFieldUpdateOperationsInput | number
    targetRoles?: NullableJsonNullValueInput | InputJsonValue
    targetUserIds?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationScheduleCreateManyInput = {
    id?: string
    organizationId: string
    groupId?: string | null
    name: string
    description?: string | null
    notificationType: $Enums.NotificationType
    title: string
    message: string
    actionUrl?: string | null
    frequency: $Enums.ScheduleFrequency
    dayOfWeek?: number | null
    dayOfMonth?: number | null
    timeOfDay: string
    timezone?: string
    offsetDays?: number
    offsetHours?: number
    targetRoles?: NullableJsonNullValueInput | InputJsonValue
    targetUserIds?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastRunAt?: Date | string | null
    nextRunAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationScheduleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notificationType?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: EnumScheduleFrequencyFieldUpdateOperationsInput | $Enums.ScheduleFrequency
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    dayOfMonth?: NullableIntFieldUpdateOperationsInput | number | null
    timeOfDay?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    offsetDays?: IntFieldUpdateOperationsInput | number
    offsetHours?: IntFieldUpdateOperationsInput | number
    targetRoles?: NullableJsonNullValueInput | InputJsonValue
    targetUserIds?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationScheduleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notificationType?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: EnumScheduleFrequencyFieldUpdateOperationsInput | $Enums.ScheduleFrequency
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    dayOfMonth?: NullableIntFieldUpdateOperationsInput | number | null
    timeOfDay?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    offsetDays?: IntFieldUpdateOperationsInput | number
    offsetHours?: IntFieldUpdateOperationsInput | number
    targetRoles?: NullableJsonNullValueInput | InputJsonValue
    targetUserIds?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type GroupListRelationFilter = {
    every?: GroupWhereInput
    some?: GroupWhereInput
    none?: GroupWhereInput
  }

  export type ExternalIntegrationListRelationFilter = {
    every?: ExternalIntegrationWhereInput
    some?: ExternalIntegrationWhereInput
    none?: ExternalIntegrationWhereInput
  }

  export type LessonListRelationFilter = {
    every?: LessonWhereInput
    some?: LessonWhereInput
    none?: LessonWhereInput
  }

  export type AIFilterConfigListRelationFilter = {
    every?: AIFilterConfigWhereInput
    some?: AIFilterConfigWhereInput
    none?: AIFilterConfigWhereInput
  }

  export type ComparativeThemeListRelationFilter = {
    every?: ComparativeThemeWhereInput
    some?: ComparativeThemeWhereInput
    none?: ComparativeThemeWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GroupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExternalIntegrationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LessonOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AIFilterConfigOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ComparativeThemeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganizationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    timezone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    timezone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    timezone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type OrganizationScalarRelationFilter = {
    is?: OrganizationWhereInput
    isNot?: OrganizationWhereInput
  }

  export type GroupMemberListRelationFilter = {
    every?: GroupMemberWhereInput
    some?: GroupMemberWhereInput
    none?: GroupMemberWhereInput
  }

  export type RefreshTokenListRelationFilter = {
    every?: RefreshTokenWhereInput
    some?: RefreshTokenWhereInput
    none?: RefreshTokenWhereInput
  }

  export type NotificationPreferenceNullableScalarRelationFilter = {
    is?: NotificationPreferenceWhereInput | null
    isNot?: NotificationPreferenceWhereInput | null
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type GroupMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RefreshTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    organizationId?: SortOrder
    isActive?: SortOrder
    externalId?: SortOrder
    externalData?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    organizationId?: SortOrder
    isActive?: SortOrder
    externalId?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    organizationId?: SortOrder
    isActive?: SortOrder
    externalId?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type RefreshTokenCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type RefreshTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type RefreshTokenMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ExternalGroupMappingListRelationFilter = {
    every?: ExternalGroupMappingWhereInput
    some?: ExternalGroupMappingWhereInput
    none?: ExternalGroupMappingWhereInput
  }

  export type LessonGroupListRelationFilter = {
    every?: LessonGroupWhereInput
    some?: LessonGroupWhereInput
    none?: LessonGroupWhereInput
  }

  export type ExternalGroupMappingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LessonGroupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GroupCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    organizationId?: SortOrder
    externalId?: SortOrder
    externalData?: SortOrder
    ageMin?: SortOrder
    ageMax?: SortOrder
    grade?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupAvgOrderByAggregateInput = {
    ageMin?: SortOrder
    ageMax?: SortOrder
  }

  export type GroupMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    organizationId?: SortOrder
    externalId?: SortOrder
    ageMin?: SortOrder
    ageMax?: SortOrder
    grade?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    organizationId?: SortOrder
    externalId?: SortOrder
    ageMin?: SortOrder
    ageMax?: SortOrder
    grade?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupSumOrderByAggregateInput = {
    ageMin?: SortOrder
    ageMax?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type GroupScalarRelationFilter = {
    is?: GroupWhereInput
    isNot?: GroupWhereInput
  }

  export type GroupMemberUserIdGroupIdCompoundUniqueInput = {
    userId: string
    groupId: string
  }

  export type GroupMemberCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupMemberMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumIntegrationProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.IntegrationProvider | EnumIntegrationProviderFieldRefInput<$PrismaModel>
    in?: $Enums.IntegrationProvider[] | ListEnumIntegrationProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.IntegrationProvider[] | ListEnumIntegrationProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumIntegrationProviderFilter<$PrismaModel> | $Enums.IntegrationProvider
  }

  export type EnumIntegrationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.IntegrationStatus | EnumIntegrationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IntegrationStatus[] | ListEnumIntegrationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IntegrationStatus[] | ListEnumIntegrationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIntegrationStatusFilter<$PrismaModel> | $Enums.IntegrationStatus
  }

  export type EnumSyncFrequencyFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncFrequency | EnumSyncFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.SyncFrequency[] | ListEnumSyncFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyncFrequency[] | ListEnumSyncFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumSyncFrequencyFilter<$PrismaModel> | $Enums.SyncFrequency
  }

  export type EnumSyncStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncStatus | EnumSyncStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSyncStatusNullableFilter<$PrismaModel> | $Enums.SyncStatus | null
  }

  export type SyncLogListRelationFilter = {
    every?: SyncLogWhereInput
    some?: SyncLogWhereInput
    none?: SyncLogWhereInput
  }

  export type SyncLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExternalIntegrationCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    provider?: SortOrder
    status?: SortOrder
    credentialsEncrypted?: SortOrder
    credentialsIV?: SortOrder
    credentialsTag?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    tokenExpiresAt?: SortOrder
    apiBaseUrl?: SortOrder
    apiVersion?: SortOrder
    syncEnabled?: SortOrder
    syncFrequency?: SortOrder
    lastSyncAt?: SortOrder
    lastSyncStatus?: SortOrder
    nextSyncAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExternalIntegrationMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    provider?: SortOrder
    status?: SortOrder
    credentialsEncrypted?: SortOrder
    credentialsIV?: SortOrder
    credentialsTag?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    tokenExpiresAt?: SortOrder
    apiBaseUrl?: SortOrder
    apiVersion?: SortOrder
    syncEnabled?: SortOrder
    syncFrequency?: SortOrder
    lastSyncAt?: SortOrder
    lastSyncStatus?: SortOrder
    nextSyncAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExternalIntegrationMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    provider?: SortOrder
    status?: SortOrder
    credentialsEncrypted?: SortOrder
    credentialsIV?: SortOrder
    credentialsTag?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    tokenExpiresAt?: SortOrder
    apiBaseUrl?: SortOrder
    apiVersion?: SortOrder
    syncEnabled?: SortOrder
    syncFrequency?: SortOrder
    lastSyncAt?: SortOrder
    lastSyncStatus?: SortOrder
    nextSyncAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumIntegrationProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IntegrationProvider | EnumIntegrationProviderFieldRefInput<$PrismaModel>
    in?: $Enums.IntegrationProvider[] | ListEnumIntegrationProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.IntegrationProvider[] | ListEnumIntegrationProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumIntegrationProviderWithAggregatesFilter<$PrismaModel> | $Enums.IntegrationProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIntegrationProviderFilter<$PrismaModel>
    _max?: NestedEnumIntegrationProviderFilter<$PrismaModel>
  }

  export type EnumIntegrationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IntegrationStatus | EnumIntegrationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IntegrationStatus[] | ListEnumIntegrationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IntegrationStatus[] | ListEnumIntegrationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIntegrationStatusWithAggregatesFilter<$PrismaModel> | $Enums.IntegrationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIntegrationStatusFilter<$PrismaModel>
    _max?: NestedEnumIntegrationStatusFilter<$PrismaModel>
  }

  export type EnumSyncFrequencyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncFrequency | EnumSyncFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.SyncFrequency[] | ListEnumSyncFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyncFrequency[] | ListEnumSyncFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumSyncFrequencyWithAggregatesFilter<$PrismaModel> | $Enums.SyncFrequency
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSyncFrequencyFilter<$PrismaModel>
    _max?: NestedEnumSyncFrequencyFilter<$PrismaModel>
  }

  export type EnumSyncStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncStatus | EnumSyncStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSyncStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.SyncStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSyncStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumSyncStatusNullableFilter<$PrismaModel>
  }

  export type ExternalIntegrationScalarRelationFilter = {
    is?: ExternalIntegrationWhereInput
    isNot?: ExternalIntegrationWhereInput
  }

  export type GroupNullableScalarRelationFilter = {
    is?: GroupWhereInput | null
    isNot?: GroupWhereInput | null
  }

  export type ExternalGroupMappingIntegrationIdExternalGroupIdCompoundUniqueInput = {
    integrationId: string
    externalGroupId: string
  }

  export type ExternalGroupMappingCountOrderByAggregateInput = {
    id?: SortOrder
    integrationId?: SortOrder
    externalGroupId?: SortOrder
    externalGroupName?: SortOrder
    externalGroupType?: SortOrder
    groupId?: SortOrder
    syncMembers?: SortOrder
    syncLeaders?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExternalGroupMappingMaxOrderByAggregateInput = {
    id?: SortOrder
    integrationId?: SortOrder
    externalGroupId?: SortOrder
    externalGroupName?: SortOrder
    externalGroupType?: SortOrder
    groupId?: SortOrder
    syncMembers?: SortOrder
    syncLeaders?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExternalGroupMappingMinOrderByAggregateInput = {
    id?: SortOrder
    integrationId?: SortOrder
    externalGroupId?: SortOrder
    externalGroupName?: SortOrder
    externalGroupType?: SortOrder
    groupId?: SortOrder
    syncMembers?: SortOrder
    syncLeaders?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumSyncStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncStatus | EnumSyncStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSyncStatusFilter<$PrismaModel> | $Enums.SyncStatus
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type SyncLogCountOrderByAggregateInput = {
    id?: SortOrder
    integrationId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    durationMs?: SortOrder
    peopleAdded?: SortOrder
    peopleUpdated?: SortOrder
    peopleRemoved?: SortOrder
    groupsAdded?: SortOrder
    groupsUpdated?: SortOrder
    groupsSkipped?: SortOrder
    errorMessage?: SortOrder
    errorCode?: SortOrder
    errorDetails?: SortOrder
    metadata?: SortOrder
  }

  export type SyncLogAvgOrderByAggregateInput = {
    durationMs?: SortOrder
    peopleAdded?: SortOrder
    peopleUpdated?: SortOrder
    peopleRemoved?: SortOrder
    groupsAdded?: SortOrder
    groupsUpdated?: SortOrder
    groupsSkipped?: SortOrder
  }

  export type SyncLogMaxOrderByAggregateInput = {
    id?: SortOrder
    integrationId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    durationMs?: SortOrder
    peopleAdded?: SortOrder
    peopleUpdated?: SortOrder
    peopleRemoved?: SortOrder
    groupsAdded?: SortOrder
    groupsUpdated?: SortOrder
    groupsSkipped?: SortOrder
    errorMessage?: SortOrder
    errorCode?: SortOrder
  }

  export type SyncLogMinOrderByAggregateInput = {
    id?: SortOrder
    integrationId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    durationMs?: SortOrder
    peopleAdded?: SortOrder
    peopleUpdated?: SortOrder
    peopleRemoved?: SortOrder
    groupsAdded?: SortOrder
    groupsUpdated?: SortOrder
    groupsSkipped?: SortOrder
    errorMessage?: SortOrder
    errorCode?: SortOrder
  }

  export type SyncLogSumOrderByAggregateInput = {
    durationMs?: SortOrder
    peopleAdded?: SortOrder
    peopleUpdated?: SortOrder
    peopleRemoved?: SortOrder
    groupsAdded?: SortOrder
    groupsUpdated?: SortOrder
    groupsSkipped?: SortOrder
  }

  export type EnumSyncStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncStatus | EnumSyncStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSyncStatusWithAggregatesFilter<$PrismaModel> | $Enums.SyncStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSyncStatusFilter<$PrismaModel>
    _max?: NestedEnumSyncStatusFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type LessonOrganizationIdQuarterUnitLessonNumberCompoundUniqueInput = {
    organizationId: string
    quarter: number
    unit: number
    lessonNumber: number
  }

  export type LessonCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    title?: SortOrder
    quarter?: SortOrder
    unit?: SortOrder
    lessonNumber?: SortOrder
    scripture?: SortOrder
    content?: SortOrder
    slides?: SortOrder
    games?: SortOrder
    isPublic?: SortOrder
    isTemplate?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LessonAvgOrderByAggregateInput = {
    quarter?: SortOrder
    unit?: SortOrder
    lessonNumber?: SortOrder
  }

  export type LessonMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    title?: SortOrder
    quarter?: SortOrder
    unit?: SortOrder
    lessonNumber?: SortOrder
    scripture?: SortOrder
    isPublic?: SortOrder
    isTemplate?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LessonMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    title?: SortOrder
    quarter?: SortOrder
    unit?: SortOrder
    lessonNumber?: SortOrder
    scripture?: SortOrder
    isPublic?: SortOrder
    isTemplate?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LessonSumOrderByAggregateInput = {
    quarter?: SortOrder
    unit?: SortOrder
    lessonNumber?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type LessonScalarRelationFilter = {
    is?: LessonWhereInput
    isNot?: LessonWhereInput
  }

  export type LessonGroupLessonIdGroupIdCompoundUniqueInput = {
    lessonId: string
    groupId: string
  }

  export type LessonGroupCountOrderByAggregateInput = {
    id?: SortOrder
    lessonId?: SortOrder
    groupId?: SortOrder
    createdAt?: SortOrder
  }

  export type LessonGroupMaxOrderByAggregateInput = {
    id?: SortOrder
    lessonId?: SortOrder
    groupId?: SortOrder
    createdAt?: SortOrder
  }

  export type LessonGroupMinOrderByAggregateInput = {
    id?: SortOrder
    lessonId?: SortOrder
    groupId?: SortOrder
    createdAt?: SortOrder
  }

  export type OrganizationNullableScalarRelationFilter = {
    is?: OrganizationWhereInput | null
    isNot?: OrganizationWhereInput | null
  }

  export type AIFilterMetricListRelationFilter = {
    every?: AIFilterMetricWhereInput
    some?: AIFilterMetricWhereInput
    none?: AIFilterMetricWhereInput
  }

  export type AIFilterMetricOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AIFilterConfigCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    filterRules?: SortOrder
    customKeywords?: SortOrder
    redirectMessage?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIFilterConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    redirectMessage?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIFilterConfigMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    redirectMessage?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumFilterCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.FilterCategory | EnumFilterCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.FilterCategory[] | ListEnumFilterCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.FilterCategory[] | ListEnumFilterCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumFilterCategoryFilter<$PrismaModel> | $Enums.FilterCategory
  }

  export type EnumFilterActionFilter<$PrismaModel = never> = {
    equals?: $Enums.FilterAction | EnumFilterActionFieldRefInput<$PrismaModel>
    in?: $Enums.FilterAction[] | ListEnumFilterActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.FilterAction[] | ListEnumFilterActionFieldRefInput<$PrismaModel>
    not?: NestedEnumFilterActionFilter<$PrismaModel> | $Enums.FilterAction
  }

  export type AIFilterConfigScalarRelationFilter = {
    is?: AIFilterConfigWhereInput
    isNot?: AIFilterConfigWhereInput
  }

  export type AIFilterMetricCountOrderByAggregateInput = {
    id?: SortOrder
    filterId?: SortOrder
    organizationId?: SortOrder
    query?: SortOrder
    detectedCategory?: SortOrder
    actionTaken?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
    featureName?: SortOrder
    leaderNotified?: SortOrder
    leaderResponse?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AIFilterMetricMaxOrderByAggregateInput = {
    id?: SortOrder
    filterId?: SortOrder
    organizationId?: SortOrder
    query?: SortOrder
    detectedCategory?: SortOrder
    actionTaken?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
    featureName?: SortOrder
    leaderNotified?: SortOrder
    leaderResponse?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AIFilterMetricMinOrderByAggregateInput = {
    id?: SortOrder
    filterId?: SortOrder
    organizationId?: SortOrder
    query?: SortOrder
    detectedCategory?: SortOrder
    actionTaken?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
    featureName?: SortOrder
    leaderNotified?: SortOrder
    leaderResponse?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumFilterCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FilterCategory | EnumFilterCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.FilterCategory[] | ListEnumFilterCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.FilterCategory[] | ListEnumFilterCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumFilterCategoryWithAggregatesFilter<$PrismaModel> | $Enums.FilterCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFilterCategoryFilter<$PrismaModel>
    _max?: NestedEnumFilterCategoryFilter<$PrismaModel>
  }

  export type EnumFilterActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FilterAction | EnumFilterActionFieldRefInput<$PrismaModel>
    in?: $Enums.FilterAction[] | ListEnumFilterActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.FilterAction[] | ListEnumFilterActionFieldRefInput<$PrismaModel>
    not?: NestedEnumFilterActionWithAggregatesFilter<$PrismaModel> | $Enums.FilterAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFilterActionFilter<$PrismaModel>
    _max?: NestedEnumFilterActionFilter<$PrismaModel>
  }

  export type ThemeMetricListRelationFilter = {
    every?: ThemeMetricWhereInput
    some?: ThemeMetricWhereInput
    none?: ThemeMetricWhereInput
  }

  export type ThemeMetricOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ComparativeThemeCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    themeName?: SortOrder
    description?: SortOrder
    category?: SortOrder
    otPassages?: SortOrder
    ntPassages?: SortOrder
    themeNotes?: SortOrder
    isPublic?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComparativeThemeMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    themeName?: SortOrder
    description?: SortOrder
    category?: SortOrder
    isPublic?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComparativeThemeMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    themeName?: SortOrder
    description?: SortOrder
    category?: SortOrder
    isPublic?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComparativeThemeScalarRelationFilter = {
    is?: ComparativeThemeWhereInput
    isNot?: ComparativeThemeWhereInput
  }

  export type ThemeMetricCountOrderByAggregateInput = {
    id?: SortOrder
    themeId?: SortOrder
    organizationId?: SortOrder
    viewCount?: SortOrder
    lastViewedAt?: SortOrder
    userId?: SortOrder
    featureContext?: SortOrder
    timeSpentMs?: SortOrder
    usedInLesson?: SortOrder
    lessonId?: SortOrder
    createdAt?: SortOrder
  }

  export type ThemeMetricAvgOrderByAggregateInput = {
    viewCount?: SortOrder
    timeSpentMs?: SortOrder
  }

  export type ThemeMetricMaxOrderByAggregateInput = {
    id?: SortOrder
    themeId?: SortOrder
    organizationId?: SortOrder
    viewCount?: SortOrder
    lastViewedAt?: SortOrder
    userId?: SortOrder
    featureContext?: SortOrder
    timeSpentMs?: SortOrder
    usedInLesson?: SortOrder
    lessonId?: SortOrder
    createdAt?: SortOrder
  }

  export type ThemeMetricMinOrderByAggregateInput = {
    id?: SortOrder
    themeId?: SortOrder
    organizationId?: SortOrder
    viewCount?: SortOrder
    lastViewedAt?: SortOrder
    userId?: SortOrder
    featureContext?: SortOrder
    timeSpentMs?: SortOrder
    usedInLesson?: SortOrder
    lessonId?: SortOrder
    createdAt?: SortOrder
  }

  export type ThemeMetricSumOrderByAggregateInput = {
    viewCount?: SortOrder
    timeSpentMs?: SortOrder
  }

  export type EnumDigestFrequencyFilter<$PrismaModel = never> = {
    equals?: $Enums.DigestFrequency | EnumDigestFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.DigestFrequency[] | ListEnumDigestFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.DigestFrequency[] | ListEnumDigestFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumDigestFrequencyFilter<$PrismaModel> | $Enums.DigestFrequency
  }

  export type NotificationPreferenceCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    emailEnabled?: SortOrder
    emailLessonReminders?: SortOrder
    emailEventReminders?: SortOrder
    emailAnnouncements?: SortOrder
    emailGroupUpdates?: SortOrder
    emailDigest?: SortOrder
    emailDigestFrequency?: SortOrder
    inAppEnabled?: SortOrder
    inAppLessonReminders?: SortOrder
    inAppEventReminders?: SortOrder
    inAppAnnouncements?: SortOrder
    inAppGroupUpdates?: SortOrder
    quietHoursEnabled?: SortOrder
    quietHoursStart?: SortOrder
    quietHoursEnd?: SortOrder
    quietHoursTimezone?: SortOrder
    preferredDays?: SortOrder
    lessonReminderDays?: SortOrder
    lessonReminderTime?: SortOrder
    eventReminderHours?: SortOrder
    batchNotifications?: SortOrder
    maxNotificationsPerDay?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationPreferenceAvgOrderByAggregateInput = {
    lessonReminderDays?: SortOrder
    eventReminderHours?: SortOrder
    maxNotificationsPerDay?: SortOrder
  }

  export type NotificationPreferenceMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    emailEnabled?: SortOrder
    emailLessonReminders?: SortOrder
    emailEventReminders?: SortOrder
    emailAnnouncements?: SortOrder
    emailGroupUpdates?: SortOrder
    emailDigest?: SortOrder
    emailDigestFrequency?: SortOrder
    inAppEnabled?: SortOrder
    inAppLessonReminders?: SortOrder
    inAppEventReminders?: SortOrder
    inAppAnnouncements?: SortOrder
    inAppGroupUpdates?: SortOrder
    quietHoursEnabled?: SortOrder
    quietHoursStart?: SortOrder
    quietHoursEnd?: SortOrder
    quietHoursTimezone?: SortOrder
    lessonReminderDays?: SortOrder
    lessonReminderTime?: SortOrder
    eventReminderHours?: SortOrder
    batchNotifications?: SortOrder
    maxNotificationsPerDay?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationPreferenceMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    emailEnabled?: SortOrder
    emailLessonReminders?: SortOrder
    emailEventReminders?: SortOrder
    emailAnnouncements?: SortOrder
    emailGroupUpdates?: SortOrder
    emailDigest?: SortOrder
    emailDigestFrequency?: SortOrder
    inAppEnabled?: SortOrder
    inAppLessonReminders?: SortOrder
    inAppEventReminders?: SortOrder
    inAppAnnouncements?: SortOrder
    inAppGroupUpdates?: SortOrder
    quietHoursEnabled?: SortOrder
    quietHoursStart?: SortOrder
    quietHoursEnd?: SortOrder
    quietHoursTimezone?: SortOrder
    lessonReminderDays?: SortOrder
    lessonReminderTime?: SortOrder
    eventReminderHours?: SortOrder
    batchNotifications?: SortOrder
    maxNotificationsPerDay?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationPreferenceSumOrderByAggregateInput = {
    lessonReminderDays?: SortOrder
    eventReminderHours?: SortOrder
    maxNotificationsPerDay?: SortOrder
  }

  export type EnumDigestFrequencyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DigestFrequency | EnumDigestFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.DigestFrequency[] | ListEnumDigestFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.DigestFrequency[] | ListEnumDigestFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumDigestFrequencyWithAggregatesFilter<$PrismaModel> | $Enums.DigestFrequency
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDigestFrequencyFilter<$PrismaModel>
    _max?: NestedEnumDigestFrequencyFilter<$PrismaModel>
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type EnumNotificationDeliveryMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationDeliveryMethod | EnumNotificationDeliveryMethodFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationDeliveryMethod[] | ListEnumNotificationDeliveryMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationDeliveryMethod[] | ListEnumNotificationDeliveryMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationDeliveryMethodFilter<$PrismaModel> | $Enums.NotificationDeliveryMethod
  }

  export type EnumNotificationPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationPriority | EnumNotificationPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationPriorityFilter<$PrismaModel> | $Enums.NotificationPriority
  }

  export type EnumNotificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusFilter<$PrismaModel> | $Enums.NotificationStatus
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    organizationId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    actionUrl?: SortOrder
    deliveryMethod?: SortOrder
    priority?: SortOrder
    scheduledFor?: SortOrder
    sentAt?: SortOrder
    readAt?: SortOrder
    status?: SortOrder
    deliveryStatus?: SortOrder
    failureReason?: SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
    groupId?: SortOrder
    lessonId?: SortOrder
    eventId?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationAvgOrderByAggregateInput = {
    retryCount?: SortOrder
    maxRetries?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    organizationId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    actionUrl?: SortOrder
    deliveryMethod?: SortOrder
    priority?: SortOrder
    scheduledFor?: SortOrder
    sentAt?: SortOrder
    readAt?: SortOrder
    status?: SortOrder
    failureReason?: SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
    groupId?: SortOrder
    lessonId?: SortOrder
    eventId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    organizationId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    actionUrl?: SortOrder
    deliveryMethod?: SortOrder
    priority?: SortOrder
    scheduledFor?: SortOrder
    sentAt?: SortOrder
    readAt?: SortOrder
    status?: SortOrder
    failureReason?: SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
    groupId?: SortOrder
    lessonId?: SortOrder
    eventId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationSumOrderByAggregateInput = {
    retryCount?: SortOrder
    maxRetries?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type EnumNotificationDeliveryMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationDeliveryMethod | EnumNotificationDeliveryMethodFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationDeliveryMethod[] | ListEnumNotificationDeliveryMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationDeliveryMethod[] | ListEnumNotificationDeliveryMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationDeliveryMethodWithAggregatesFilter<$PrismaModel> | $Enums.NotificationDeliveryMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationDeliveryMethodFilter<$PrismaModel>
    _max?: NestedEnumNotificationDeliveryMethodFilter<$PrismaModel>
  }

  export type EnumNotificationPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationPriority | EnumNotificationPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationPriorityWithAggregatesFilter<$PrismaModel> | $Enums.NotificationPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationPriorityFilter<$PrismaModel>
    _max?: NestedEnumNotificationPriorityFilter<$PrismaModel>
  }

  export type EnumNotificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.NotificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationStatusFilter<$PrismaModel>
    _max?: NestedEnumNotificationStatusFilter<$PrismaModel>
  }

  export type EnumScheduleFrequencyFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduleFrequency | EnumScheduleFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.ScheduleFrequency[] | ListEnumScheduleFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScheduleFrequency[] | ListEnumScheduleFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumScheduleFrequencyFilter<$PrismaModel> | $Enums.ScheduleFrequency
  }

  export type NotificationScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    groupId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    notificationType?: SortOrder
    title?: SortOrder
    message?: SortOrder
    actionUrl?: SortOrder
    frequency?: SortOrder
    dayOfWeek?: SortOrder
    dayOfMonth?: SortOrder
    timeOfDay?: SortOrder
    timezone?: SortOrder
    offsetDays?: SortOrder
    offsetHours?: SortOrder
    targetRoles?: SortOrder
    targetUserIds?: SortOrder
    isActive?: SortOrder
    lastRunAt?: SortOrder
    nextRunAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationScheduleAvgOrderByAggregateInput = {
    dayOfWeek?: SortOrder
    dayOfMonth?: SortOrder
    offsetDays?: SortOrder
    offsetHours?: SortOrder
  }

  export type NotificationScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    groupId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    notificationType?: SortOrder
    title?: SortOrder
    message?: SortOrder
    actionUrl?: SortOrder
    frequency?: SortOrder
    dayOfWeek?: SortOrder
    dayOfMonth?: SortOrder
    timeOfDay?: SortOrder
    timezone?: SortOrder
    offsetDays?: SortOrder
    offsetHours?: SortOrder
    isActive?: SortOrder
    lastRunAt?: SortOrder
    nextRunAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    groupId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    notificationType?: SortOrder
    title?: SortOrder
    message?: SortOrder
    actionUrl?: SortOrder
    frequency?: SortOrder
    dayOfWeek?: SortOrder
    dayOfMonth?: SortOrder
    timeOfDay?: SortOrder
    timezone?: SortOrder
    offsetDays?: SortOrder
    offsetHours?: SortOrder
    isActive?: SortOrder
    lastRunAt?: SortOrder
    nextRunAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationScheduleSumOrderByAggregateInput = {
    dayOfWeek?: SortOrder
    dayOfMonth?: SortOrder
    offsetDays?: SortOrder
    offsetHours?: SortOrder
  }

  export type EnumScheduleFrequencyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduleFrequency | EnumScheduleFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.ScheduleFrequency[] | ListEnumScheduleFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScheduleFrequency[] | ListEnumScheduleFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumScheduleFrequencyWithAggregatesFilter<$PrismaModel> | $Enums.ScheduleFrequency
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumScheduleFrequencyFilter<$PrismaModel>
    _max?: NestedEnumScheduleFrequencyFilter<$PrismaModel>
  }

  export type UserCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput> | UserCreateWithoutOrganizationInput[] | UserUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationInput | UserCreateOrConnectWithoutOrganizationInput[]
    createMany?: UserCreateManyOrganizationInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type GroupCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<GroupCreateWithoutOrganizationInput, GroupUncheckedCreateWithoutOrganizationInput> | GroupCreateWithoutOrganizationInput[] | GroupUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutOrganizationInput | GroupCreateOrConnectWithoutOrganizationInput[]
    createMany?: GroupCreateManyOrganizationInputEnvelope
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
  }

  export type ExternalIntegrationCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<ExternalIntegrationCreateWithoutOrganizationInput, ExternalIntegrationUncheckedCreateWithoutOrganizationInput> | ExternalIntegrationCreateWithoutOrganizationInput[] | ExternalIntegrationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ExternalIntegrationCreateOrConnectWithoutOrganizationInput | ExternalIntegrationCreateOrConnectWithoutOrganizationInput[]
    createMany?: ExternalIntegrationCreateManyOrganizationInputEnvelope
    connect?: ExternalIntegrationWhereUniqueInput | ExternalIntegrationWhereUniqueInput[]
  }

  export type LessonCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<LessonCreateWithoutOrganizationInput, LessonUncheckedCreateWithoutOrganizationInput> | LessonCreateWithoutOrganizationInput[] | LessonUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutOrganizationInput | LessonCreateOrConnectWithoutOrganizationInput[]
    createMany?: LessonCreateManyOrganizationInputEnvelope
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
  }

  export type AIFilterConfigCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<AIFilterConfigCreateWithoutOrganizationInput, AIFilterConfigUncheckedCreateWithoutOrganizationInput> | AIFilterConfigCreateWithoutOrganizationInput[] | AIFilterConfigUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: AIFilterConfigCreateOrConnectWithoutOrganizationInput | AIFilterConfigCreateOrConnectWithoutOrganizationInput[]
    createMany?: AIFilterConfigCreateManyOrganizationInputEnvelope
    connect?: AIFilterConfigWhereUniqueInput | AIFilterConfigWhereUniqueInput[]
  }

  export type ComparativeThemeCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<ComparativeThemeCreateWithoutOrganizationInput, ComparativeThemeUncheckedCreateWithoutOrganizationInput> | ComparativeThemeCreateWithoutOrganizationInput[] | ComparativeThemeUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ComparativeThemeCreateOrConnectWithoutOrganizationInput | ComparativeThemeCreateOrConnectWithoutOrganizationInput[]
    createMany?: ComparativeThemeCreateManyOrganizationInputEnvelope
    connect?: ComparativeThemeWhereUniqueInput | ComparativeThemeWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput> | UserCreateWithoutOrganizationInput[] | UserUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationInput | UserCreateOrConnectWithoutOrganizationInput[]
    createMany?: UserCreateManyOrganizationInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type GroupUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<GroupCreateWithoutOrganizationInput, GroupUncheckedCreateWithoutOrganizationInput> | GroupCreateWithoutOrganizationInput[] | GroupUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutOrganizationInput | GroupCreateOrConnectWithoutOrganizationInput[]
    createMany?: GroupCreateManyOrganizationInputEnvelope
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
  }

  export type ExternalIntegrationUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<ExternalIntegrationCreateWithoutOrganizationInput, ExternalIntegrationUncheckedCreateWithoutOrganizationInput> | ExternalIntegrationCreateWithoutOrganizationInput[] | ExternalIntegrationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ExternalIntegrationCreateOrConnectWithoutOrganizationInput | ExternalIntegrationCreateOrConnectWithoutOrganizationInput[]
    createMany?: ExternalIntegrationCreateManyOrganizationInputEnvelope
    connect?: ExternalIntegrationWhereUniqueInput | ExternalIntegrationWhereUniqueInput[]
  }

  export type LessonUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<LessonCreateWithoutOrganizationInput, LessonUncheckedCreateWithoutOrganizationInput> | LessonCreateWithoutOrganizationInput[] | LessonUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutOrganizationInput | LessonCreateOrConnectWithoutOrganizationInput[]
    createMany?: LessonCreateManyOrganizationInputEnvelope
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
  }

  export type AIFilterConfigUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<AIFilterConfigCreateWithoutOrganizationInput, AIFilterConfigUncheckedCreateWithoutOrganizationInput> | AIFilterConfigCreateWithoutOrganizationInput[] | AIFilterConfigUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: AIFilterConfigCreateOrConnectWithoutOrganizationInput | AIFilterConfigCreateOrConnectWithoutOrganizationInput[]
    createMany?: AIFilterConfigCreateManyOrganizationInputEnvelope
    connect?: AIFilterConfigWhereUniqueInput | AIFilterConfigWhereUniqueInput[]
  }

  export type ComparativeThemeUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<ComparativeThemeCreateWithoutOrganizationInput, ComparativeThemeUncheckedCreateWithoutOrganizationInput> | ComparativeThemeCreateWithoutOrganizationInput[] | ComparativeThemeUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ComparativeThemeCreateOrConnectWithoutOrganizationInput | ComparativeThemeCreateOrConnectWithoutOrganizationInput[]
    createMany?: ComparativeThemeCreateManyOrganizationInputEnvelope
    connect?: ComparativeThemeWhereUniqueInput | ComparativeThemeWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput> | UserCreateWithoutOrganizationInput[] | UserUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationInput | UserCreateOrConnectWithoutOrganizationInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutOrganizationInput | UserUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: UserCreateManyOrganizationInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutOrganizationInput | UserUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: UserUpdateManyWithWhereWithoutOrganizationInput | UserUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type GroupUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<GroupCreateWithoutOrganizationInput, GroupUncheckedCreateWithoutOrganizationInput> | GroupCreateWithoutOrganizationInput[] | GroupUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutOrganizationInput | GroupCreateOrConnectWithoutOrganizationInput[]
    upsert?: GroupUpsertWithWhereUniqueWithoutOrganizationInput | GroupUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: GroupCreateManyOrganizationInputEnvelope
    set?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    disconnect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    delete?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    update?: GroupUpdateWithWhereUniqueWithoutOrganizationInput | GroupUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: GroupUpdateManyWithWhereWithoutOrganizationInput | GroupUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: GroupScalarWhereInput | GroupScalarWhereInput[]
  }

  export type ExternalIntegrationUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<ExternalIntegrationCreateWithoutOrganizationInput, ExternalIntegrationUncheckedCreateWithoutOrganizationInput> | ExternalIntegrationCreateWithoutOrganizationInput[] | ExternalIntegrationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ExternalIntegrationCreateOrConnectWithoutOrganizationInput | ExternalIntegrationCreateOrConnectWithoutOrganizationInput[]
    upsert?: ExternalIntegrationUpsertWithWhereUniqueWithoutOrganizationInput | ExternalIntegrationUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: ExternalIntegrationCreateManyOrganizationInputEnvelope
    set?: ExternalIntegrationWhereUniqueInput | ExternalIntegrationWhereUniqueInput[]
    disconnect?: ExternalIntegrationWhereUniqueInput | ExternalIntegrationWhereUniqueInput[]
    delete?: ExternalIntegrationWhereUniqueInput | ExternalIntegrationWhereUniqueInput[]
    connect?: ExternalIntegrationWhereUniqueInput | ExternalIntegrationWhereUniqueInput[]
    update?: ExternalIntegrationUpdateWithWhereUniqueWithoutOrganizationInput | ExternalIntegrationUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: ExternalIntegrationUpdateManyWithWhereWithoutOrganizationInput | ExternalIntegrationUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: ExternalIntegrationScalarWhereInput | ExternalIntegrationScalarWhereInput[]
  }

  export type LessonUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<LessonCreateWithoutOrganizationInput, LessonUncheckedCreateWithoutOrganizationInput> | LessonCreateWithoutOrganizationInput[] | LessonUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutOrganizationInput | LessonCreateOrConnectWithoutOrganizationInput[]
    upsert?: LessonUpsertWithWhereUniqueWithoutOrganizationInput | LessonUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: LessonCreateManyOrganizationInputEnvelope
    set?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    disconnect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    delete?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    update?: LessonUpdateWithWhereUniqueWithoutOrganizationInput | LessonUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: LessonUpdateManyWithWhereWithoutOrganizationInput | LessonUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: LessonScalarWhereInput | LessonScalarWhereInput[]
  }

  export type AIFilterConfigUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<AIFilterConfigCreateWithoutOrganizationInput, AIFilterConfigUncheckedCreateWithoutOrganizationInput> | AIFilterConfigCreateWithoutOrganizationInput[] | AIFilterConfigUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: AIFilterConfigCreateOrConnectWithoutOrganizationInput | AIFilterConfigCreateOrConnectWithoutOrganizationInput[]
    upsert?: AIFilterConfigUpsertWithWhereUniqueWithoutOrganizationInput | AIFilterConfigUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: AIFilterConfigCreateManyOrganizationInputEnvelope
    set?: AIFilterConfigWhereUniqueInput | AIFilterConfigWhereUniqueInput[]
    disconnect?: AIFilterConfigWhereUniqueInput | AIFilterConfigWhereUniqueInput[]
    delete?: AIFilterConfigWhereUniqueInput | AIFilterConfigWhereUniqueInput[]
    connect?: AIFilterConfigWhereUniqueInput | AIFilterConfigWhereUniqueInput[]
    update?: AIFilterConfigUpdateWithWhereUniqueWithoutOrganizationInput | AIFilterConfigUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: AIFilterConfigUpdateManyWithWhereWithoutOrganizationInput | AIFilterConfigUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: AIFilterConfigScalarWhereInput | AIFilterConfigScalarWhereInput[]
  }

  export type ComparativeThemeUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<ComparativeThemeCreateWithoutOrganizationInput, ComparativeThemeUncheckedCreateWithoutOrganizationInput> | ComparativeThemeCreateWithoutOrganizationInput[] | ComparativeThemeUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ComparativeThemeCreateOrConnectWithoutOrganizationInput | ComparativeThemeCreateOrConnectWithoutOrganizationInput[]
    upsert?: ComparativeThemeUpsertWithWhereUniqueWithoutOrganizationInput | ComparativeThemeUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: ComparativeThemeCreateManyOrganizationInputEnvelope
    set?: ComparativeThemeWhereUniqueInput | ComparativeThemeWhereUniqueInput[]
    disconnect?: ComparativeThemeWhereUniqueInput | ComparativeThemeWhereUniqueInput[]
    delete?: ComparativeThemeWhereUniqueInput | ComparativeThemeWhereUniqueInput[]
    connect?: ComparativeThemeWhereUniqueInput | ComparativeThemeWhereUniqueInput[]
    update?: ComparativeThemeUpdateWithWhereUniqueWithoutOrganizationInput | ComparativeThemeUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: ComparativeThemeUpdateManyWithWhereWithoutOrganizationInput | ComparativeThemeUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: ComparativeThemeScalarWhereInput | ComparativeThemeScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput> | UserCreateWithoutOrganizationInput[] | UserUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationInput | UserCreateOrConnectWithoutOrganizationInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutOrganizationInput | UserUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: UserCreateManyOrganizationInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutOrganizationInput | UserUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: UserUpdateManyWithWhereWithoutOrganizationInput | UserUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type GroupUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<GroupCreateWithoutOrganizationInput, GroupUncheckedCreateWithoutOrganizationInput> | GroupCreateWithoutOrganizationInput[] | GroupUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutOrganizationInput | GroupCreateOrConnectWithoutOrganizationInput[]
    upsert?: GroupUpsertWithWhereUniqueWithoutOrganizationInput | GroupUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: GroupCreateManyOrganizationInputEnvelope
    set?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    disconnect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    delete?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    update?: GroupUpdateWithWhereUniqueWithoutOrganizationInput | GroupUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: GroupUpdateManyWithWhereWithoutOrganizationInput | GroupUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: GroupScalarWhereInput | GroupScalarWhereInput[]
  }

  export type ExternalIntegrationUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<ExternalIntegrationCreateWithoutOrganizationInput, ExternalIntegrationUncheckedCreateWithoutOrganizationInput> | ExternalIntegrationCreateWithoutOrganizationInput[] | ExternalIntegrationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ExternalIntegrationCreateOrConnectWithoutOrganizationInput | ExternalIntegrationCreateOrConnectWithoutOrganizationInput[]
    upsert?: ExternalIntegrationUpsertWithWhereUniqueWithoutOrganizationInput | ExternalIntegrationUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: ExternalIntegrationCreateManyOrganizationInputEnvelope
    set?: ExternalIntegrationWhereUniqueInput | ExternalIntegrationWhereUniqueInput[]
    disconnect?: ExternalIntegrationWhereUniqueInput | ExternalIntegrationWhereUniqueInput[]
    delete?: ExternalIntegrationWhereUniqueInput | ExternalIntegrationWhereUniqueInput[]
    connect?: ExternalIntegrationWhereUniqueInput | ExternalIntegrationWhereUniqueInput[]
    update?: ExternalIntegrationUpdateWithWhereUniqueWithoutOrganizationInput | ExternalIntegrationUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: ExternalIntegrationUpdateManyWithWhereWithoutOrganizationInput | ExternalIntegrationUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: ExternalIntegrationScalarWhereInput | ExternalIntegrationScalarWhereInput[]
  }

  export type LessonUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<LessonCreateWithoutOrganizationInput, LessonUncheckedCreateWithoutOrganizationInput> | LessonCreateWithoutOrganizationInput[] | LessonUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutOrganizationInput | LessonCreateOrConnectWithoutOrganizationInput[]
    upsert?: LessonUpsertWithWhereUniqueWithoutOrganizationInput | LessonUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: LessonCreateManyOrganizationInputEnvelope
    set?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    disconnect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    delete?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    update?: LessonUpdateWithWhereUniqueWithoutOrganizationInput | LessonUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: LessonUpdateManyWithWhereWithoutOrganizationInput | LessonUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: LessonScalarWhereInput | LessonScalarWhereInput[]
  }

  export type AIFilterConfigUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<AIFilterConfigCreateWithoutOrganizationInput, AIFilterConfigUncheckedCreateWithoutOrganizationInput> | AIFilterConfigCreateWithoutOrganizationInput[] | AIFilterConfigUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: AIFilterConfigCreateOrConnectWithoutOrganizationInput | AIFilterConfigCreateOrConnectWithoutOrganizationInput[]
    upsert?: AIFilterConfigUpsertWithWhereUniqueWithoutOrganizationInput | AIFilterConfigUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: AIFilterConfigCreateManyOrganizationInputEnvelope
    set?: AIFilterConfigWhereUniqueInput | AIFilterConfigWhereUniqueInput[]
    disconnect?: AIFilterConfigWhereUniqueInput | AIFilterConfigWhereUniqueInput[]
    delete?: AIFilterConfigWhereUniqueInput | AIFilterConfigWhereUniqueInput[]
    connect?: AIFilterConfigWhereUniqueInput | AIFilterConfigWhereUniqueInput[]
    update?: AIFilterConfigUpdateWithWhereUniqueWithoutOrganizationInput | AIFilterConfigUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: AIFilterConfigUpdateManyWithWhereWithoutOrganizationInput | AIFilterConfigUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: AIFilterConfigScalarWhereInput | AIFilterConfigScalarWhereInput[]
  }

  export type ComparativeThemeUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<ComparativeThemeCreateWithoutOrganizationInput, ComparativeThemeUncheckedCreateWithoutOrganizationInput> | ComparativeThemeCreateWithoutOrganizationInput[] | ComparativeThemeUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ComparativeThemeCreateOrConnectWithoutOrganizationInput | ComparativeThemeCreateOrConnectWithoutOrganizationInput[]
    upsert?: ComparativeThemeUpsertWithWhereUniqueWithoutOrganizationInput | ComparativeThemeUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: ComparativeThemeCreateManyOrganizationInputEnvelope
    set?: ComparativeThemeWhereUniqueInput | ComparativeThemeWhereUniqueInput[]
    disconnect?: ComparativeThemeWhereUniqueInput | ComparativeThemeWhereUniqueInput[]
    delete?: ComparativeThemeWhereUniqueInput | ComparativeThemeWhereUniqueInput[]
    connect?: ComparativeThemeWhereUniqueInput | ComparativeThemeWhereUniqueInput[]
    update?: ComparativeThemeUpdateWithWhereUniqueWithoutOrganizationInput | ComparativeThemeUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: ComparativeThemeUpdateManyWithWhereWithoutOrganizationInput | ComparativeThemeUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: ComparativeThemeScalarWhereInput | ComparativeThemeScalarWhereInput[]
  }

  export type OrganizationCreateNestedOneWithoutUsersInput = {
    create?: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutUsersInput
    connect?: OrganizationWhereUniqueInput
  }

  export type GroupMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<GroupMemberCreateWithoutUserInput, GroupMemberUncheckedCreateWithoutUserInput> | GroupMemberCreateWithoutUserInput[] | GroupMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutUserInput | GroupMemberCreateOrConnectWithoutUserInput[]
    createMany?: GroupMemberCreateManyUserInputEnvelope
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
  }

  export type RefreshTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type NotificationPreferenceCreateNestedOneWithoutUserInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput
    connect?: NotificationPreferenceWhereUniqueInput
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type GroupMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<GroupMemberCreateWithoutUserInput, GroupMemberUncheckedCreateWithoutUserInput> | GroupMemberCreateWithoutUserInput[] | GroupMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutUserInput | GroupMemberCreateOrConnectWithoutUserInput[]
    createMany?: GroupMemberCreateManyUserInputEnvelope
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
  }

  export type RefreshTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput
    connect?: NotificationPreferenceWhereUniqueInput
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type OrganizationUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutUsersInput
    upsert?: OrganizationUpsertWithoutUsersInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutUsersInput, OrganizationUpdateWithoutUsersInput>, OrganizationUncheckedUpdateWithoutUsersInput>
  }

  export type GroupMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<GroupMemberCreateWithoutUserInput, GroupMemberUncheckedCreateWithoutUserInput> | GroupMemberCreateWithoutUserInput[] | GroupMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutUserInput | GroupMemberCreateOrConnectWithoutUserInput[]
    upsert?: GroupMemberUpsertWithWhereUniqueWithoutUserInput | GroupMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GroupMemberCreateManyUserInputEnvelope
    set?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    disconnect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    delete?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    update?: GroupMemberUpdateWithWhereUniqueWithoutUserInput | GroupMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GroupMemberUpdateManyWithWhereWithoutUserInput | GroupMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GroupMemberScalarWhereInput | GroupMemberScalarWhereInput[]
  }

  export type RefreshTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type NotificationPreferenceUpdateOneWithoutUserNestedInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput
    upsert?: NotificationPreferenceUpsertWithoutUserInput
    disconnect?: NotificationPreferenceWhereInput | boolean
    delete?: NotificationPreferenceWhereInput | boolean
    connect?: NotificationPreferenceWhereUniqueInput
    update?: XOR<XOR<NotificationPreferenceUpdateToOneWithWhereWithoutUserInput, NotificationPreferenceUpdateWithoutUserInput>, NotificationPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type GroupMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<GroupMemberCreateWithoutUserInput, GroupMemberUncheckedCreateWithoutUserInput> | GroupMemberCreateWithoutUserInput[] | GroupMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutUserInput | GroupMemberCreateOrConnectWithoutUserInput[]
    upsert?: GroupMemberUpsertWithWhereUniqueWithoutUserInput | GroupMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GroupMemberCreateManyUserInputEnvelope
    set?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    disconnect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    delete?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    update?: GroupMemberUpdateWithWhereUniqueWithoutUserInput | GroupMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GroupMemberUpdateManyWithWhereWithoutUserInput | GroupMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GroupMemberScalarWhereInput | GroupMemberScalarWhereInput[]
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput
    upsert?: NotificationPreferenceUpsertWithoutUserInput
    disconnect?: NotificationPreferenceWhereInput | boolean
    delete?: NotificationPreferenceWhereInput | boolean
    connect?: NotificationPreferenceWhereUniqueInput
    update?: XOR<XOR<NotificationPreferenceUpdateToOneWithWhereWithoutUserInput, NotificationPreferenceUpdateWithoutUserInput>, NotificationPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutRefreshTokensInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRefreshTokensNestedInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    upsert?: UserUpsertWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRefreshTokensInput, UserUpdateWithoutRefreshTokensInput>, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type OrganizationCreateNestedOneWithoutGroupsInput = {
    create?: XOR<OrganizationCreateWithoutGroupsInput, OrganizationUncheckedCreateWithoutGroupsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutGroupsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type GroupMemberCreateNestedManyWithoutGroupInput = {
    create?: XOR<GroupMemberCreateWithoutGroupInput, GroupMemberUncheckedCreateWithoutGroupInput> | GroupMemberCreateWithoutGroupInput[] | GroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutGroupInput | GroupMemberCreateOrConnectWithoutGroupInput[]
    createMany?: GroupMemberCreateManyGroupInputEnvelope
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
  }

  export type ExternalGroupMappingCreateNestedManyWithoutGroupInput = {
    create?: XOR<ExternalGroupMappingCreateWithoutGroupInput, ExternalGroupMappingUncheckedCreateWithoutGroupInput> | ExternalGroupMappingCreateWithoutGroupInput[] | ExternalGroupMappingUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: ExternalGroupMappingCreateOrConnectWithoutGroupInput | ExternalGroupMappingCreateOrConnectWithoutGroupInput[]
    createMany?: ExternalGroupMappingCreateManyGroupInputEnvelope
    connect?: ExternalGroupMappingWhereUniqueInput | ExternalGroupMappingWhereUniqueInput[]
  }

  export type LessonGroupCreateNestedManyWithoutGroupInput = {
    create?: XOR<LessonGroupCreateWithoutGroupInput, LessonGroupUncheckedCreateWithoutGroupInput> | LessonGroupCreateWithoutGroupInput[] | LessonGroupUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: LessonGroupCreateOrConnectWithoutGroupInput | LessonGroupCreateOrConnectWithoutGroupInput[]
    createMany?: LessonGroupCreateManyGroupInputEnvelope
    connect?: LessonGroupWhereUniqueInput | LessonGroupWhereUniqueInput[]
  }

  export type GroupMemberUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<GroupMemberCreateWithoutGroupInput, GroupMemberUncheckedCreateWithoutGroupInput> | GroupMemberCreateWithoutGroupInput[] | GroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutGroupInput | GroupMemberCreateOrConnectWithoutGroupInput[]
    createMany?: GroupMemberCreateManyGroupInputEnvelope
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
  }

  export type ExternalGroupMappingUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<ExternalGroupMappingCreateWithoutGroupInput, ExternalGroupMappingUncheckedCreateWithoutGroupInput> | ExternalGroupMappingCreateWithoutGroupInput[] | ExternalGroupMappingUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: ExternalGroupMappingCreateOrConnectWithoutGroupInput | ExternalGroupMappingCreateOrConnectWithoutGroupInput[]
    createMany?: ExternalGroupMappingCreateManyGroupInputEnvelope
    connect?: ExternalGroupMappingWhereUniqueInput | ExternalGroupMappingWhereUniqueInput[]
  }

  export type LessonGroupUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<LessonGroupCreateWithoutGroupInput, LessonGroupUncheckedCreateWithoutGroupInput> | LessonGroupCreateWithoutGroupInput[] | LessonGroupUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: LessonGroupCreateOrConnectWithoutGroupInput | LessonGroupCreateOrConnectWithoutGroupInput[]
    createMany?: LessonGroupCreateManyGroupInputEnvelope
    connect?: LessonGroupWhereUniqueInput | LessonGroupWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type OrganizationUpdateOneRequiredWithoutGroupsNestedInput = {
    create?: XOR<OrganizationCreateWithoutGroupsInput, OrganizationUncheckedCreateWithoutGroupsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutGroupsInput
    upsert?: OrganizationUpsertWithoutGroupsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutGroupsInput, OrganizationUpdateWithoutGroupsInput>, OrganizationUncheckedUpdateWithoutGroupsInput>
  }

  export type GroupMemberUpdateManyWithoutGroupNestedInput = {
    create?: XOR<GroupMemberCreateWithoutGroupInput, GroupMemberUncheckedCreateWithoutGroupInput> | GroupMemberCreateWithoutGroupInput[] | GroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutGroupInput | GroupMemberCreateOrConnectWithoutGroupInput[]
    upsert?: GroupMemberUpsertWithWhereUniqueWithoutGroupInput | GroupMemberUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: GroupMemberCreateManyGroupInputEnvelope
    set?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    disconnect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    delete?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    update?: GroupMemberUpdateWithWhereUniqueWithoutGroupInput | GroupMemberUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: GroupMemberUpdateManyWithWhereWithoutGroupInput | GroupMemberUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: GroupMemberScalarWhereInput | GroupMemberScalarWhereInput[]
  }

  export type ExternalGroupMappingUpdateManyWithoutGroupNestedInput = {
    create?: XOR<ExternalGroupMappingCreateWithoutGroupInput, ExternalGroupMappingUncheckedCreateWithoutGroupInput> | ExternalGroupMappingCreateWithoutGroupInput[] | ExternalGroupMappingUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: ExternalGroupMappingCreateOrConnectWithoutGroupInput | ExternalGroupMappingCreateOrConnectWithoutGroupInput[]
    upsert?: ExternalGroupMappingUpsertWithWhereUniqueWithoutGroupInput | ExternalGroupMappingUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: ExternalGroupMappingCreateManyGroupInputEnvelope
    set?: ExternalGroupMappingWhereUniqueInput | ExternalGroupMappingWhereUniqueInput[]
    disconnect?: ExternalGroupMappingWhereUniqueInput | ExternalGroupMappingWhereUniqueInput[]
    delete?: ExternalGroupMappingWhereUniqueInput | ExternalGroupMappingWhereUniqueInput[]
    connect?: ExternalGroupMappingWhereUniqueInput | ExternalGroupMappingWhereUniqueInput[]
    update?: ExternalGroupMappingUpdateWithWhereUniqueWithoutGroupInput | ExternalGroupMappingUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: ExternalGroupMappingUpdateManyWithWhereWithoutGroupInput | ExternalGroupMappingUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: ExternalGroupMappingScalarWhereInput | ExternalGroupMappingScalarWhereInput[]
  }

  export type LessonGroupUpdateManyWithoutGroupNestedInput = {
    create?: XOR<LessonGroupCreateWithoutGroupInput, LessonGroupUncheckedCreateWithoutGroupInput> | LessonGroupCreateWithoutGroupInput[] | LessonGroupUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: LessonGroupCreateOrConnectWithoutGroupInput | LessonGroupCreateOrConnectWithoutGroupInput[]
    upsert?: LessonGroupUpsertWithWhereUniqueWithoutGroupInput | LessonGroupUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: LessonGroupCreateManyGroupInputEnvelope
    set?: LessonGroupWhereUniqueInput | LessonGroupWhereUniqueInput[]
    disconnect?: LessonGroupWhereUniqueInput | LessonGroupWhereUniqueInput[]
    delete?: LessonGroupWhereUniqueInput | LessonGroupWhereUniqueInput[]
    connect?: LessonGroupWhereUniqueInput | LessonGroupWhereUniqueInput[]
    update?: LessonGroupUpdateWithWhereUniqueWithoutGroupInput | LessonGroupUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: LessonGroupUpdateManyWithWhereWithoutGroupInput | LessonGroupUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: LessonGroupScalarWhereInput | LessonGroupScalarWhereInput[]
  }

  export type GroupMemberUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<GroupMemberCreateWithoutGroupInput, GroupMemberUncheckedCreateWithoutGroupInput> | GroupMemberCreateWithoutGroupInput[] | GroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: GroupMemberCreateOrConnectWithoutGroupInput | GroupMemberCreateOrConnectWithoutGroupInput[]
    upsert?: GroupMemberUpsertWithWhereUniqueWithoutGroupInput | GroupMemberUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: GroupMemberCreateManyGroupInputEnvelope
    set?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    disconnect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    delete?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    connect?: GroupMemberWhereUniqueInput | GroupMemberWhereUniqueInput[]
    update?: GroupMemberUpdateWithWhereUniqueWithoutGroupInput | GroupMemberUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: GroupMemberUpdateManyWithWhereWithoutGroupInput | GroupMemberUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: GroupMemberScalarWhereInput | GroupMemberScalarWhereInput[]
  }

  export type ExternalGroupMappingUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<ExternalGroupMappingCreateWithoutGroupInput, ExternalGroupMappingUncheckedCreateWithoutGroupInput> | ExternalGroupMappingCreateWithoutGroupInput[] | ExternalGroupMappingUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: ExternalGroupMappingCreateOrConnectWithoutGroupInput | ExternalGroupMappingCreateOrConnectWithoutGroupInput[]
    upsert?: ExternalGroupMappingUpsertWithWhereUniqueWithoutGroupInput | ExternalGroupMappingUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: ExternalGroupMappingCreateManyGroupInputEnvelope
    set?: ExternalGroupMappingWhereUniqueInput | ExternalGroupMappingWhereUniqueInput[]
    disconnect?: ExternalGroupMappingWhereUniqueInput | ExternalGroupMappingWhereUniqueInput[]
    delete?: ExternalGroupMappingWhereUniqueInput | ExternalGroupMappingWhereUniqueInput[]
    connect?: ExternalGroupMappingWhereUniqueInput | ExternalGroupMappingWhereUniqueInput[]
    update?: ExternalGroupMappingUpdateWithWhereUniqueWithoutGroupInput | ExternalGroupMappingUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: ExternalGroupMappingUpdateManyWithWhereWithoutGroupInput | ExternalGroupMappingUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: ExternalGroupMappingScalarWhereInput | ExternalGroupMappingScalarWhereInput[]
  }

  export type LessonGroupUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<LessonGroupCreateWithoutGroupInput, LessonGroupUncheckedCreateWithoutGroupInput> | LessonGroupCreateWithoutGroupInput[] | LessonGroupUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: LessonGroupCreateOrConnectWithoutGroupInput | LessonGroupCreateOrConnectWithoutGroupInput[]
    upsert?: LessonGroupUpsertWithWhereUniqueWithoutGroupInput | LessonGroupUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: LessonGroupCreateManyGroupInputEnvelope
    set?: LessonGroupWhereUniqueInput | LessonGroupWhereUniqueInput[]
    disconnect?: LessonGroupWhereUniqueInput | LessonGroupWhereUniqueInput[]
    delete?: LessonGroupWhereUniqueInput | LessonGroupWhereUniqueInput[]
    connect?: LessonGroupWhereUniqueInput | LessonGroupWhereUniqueInput[]
    update?: LessonGroupUpdateWithWhereUniqueWithoutGroupInput | LessonGroupUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: LessonGroupUpdateManyWithWhereWithoutGroupInput | LessonGroupUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: LessonGroupScalarWhereInput | LessonGroupScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutGroupMembershipsInput = {
    create?: XOR<UserCreateWithoutGroupMembershipsInput, UserUncheckedCreateWithoutGroupMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGroupMembershipsInput
    connect?: UserWhereUniqueInput
  }

  export type GroupCreateNestedOneWithoutMembersInput = {
    create?: XOR<GroupCreateWithoutMembersInput, GroupUncheckedCreateWithoutMembersInput>
    connectOrCreate?: GroupCreateOrConnectWithoutMembersInput
    connect?: GroupWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutGroupMembershipsNestedInput = {
    create?: XOR<UserCreateWithoutGroupMembershipsInput, UserUncheckedCreateWithoutGroupMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGroupMembershipsInput
    upsert?: UserUpsertWithoutGroupMembershipsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGroupMembershipsInput, UserUpdateWithoutGroupMembershipsInput>, UserUncheckedUpdateWithoutGroupMembershipsInput>
  }

  export type GroupUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<GroupCreateWithoutMembersInput, GroupUncheckedCreateWithoutMembersInput>
    connectOrCreate?: GroupCreateOrConnectWithoutMembersInput
    upsert?: GroupUpsertWithoutMembersInput
    connect?: GroupWhereUniqueInput
    update?: XOR<XOR<GroupUpdateToOneWithWhereWithoutMembersInput, GroupUpdateWithoutMembersInput>, GroupUncheckedUpdateWithoutMembersInput>
  }

  export type OrganizationCreateNestedOneWithoutIntegrationsInput = {
    create?: XOR<OrganizationCreateWithoutIntegrationsInput, OrganizationUncheckedCreateWithoutIntegrationsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutIntegrationsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type ExternalGroupMappingCreateNestedManyWithoutIntegrationInput = {
    create?: XOR<ExternalGroupMappingCreateWithoutIntegrationInput, ExternalGroupMappingUncheckedCreateWithoutIntegrationInput> | ExternalGroupMappingCreateWithoutIntegrationInput[] | ExternalGroupMappingUncheckedCreateWithoutIntegrationInput[]
    connectOrCreate?: ExternalGroupMappingCreateOrConnectWithoutIntegrationInput | ExternalGroupMappingCreateOrConnectWithoutIntegrationInput[]
    createMany?: ExternalGroupMappingCreateManyIntegrationInputEnvelope
    connect?: ExternalGroupMappingWhereUniqueInput | ExternalGroupMappingWhereUniqueInput[]
  }

  export type SyncLogCreateNestedManyWithoutIntegrationInput = {
    create?: XOR<SyncLogCreateWithoutIntegrationInput, SyncLogUncheckedCreateWithoutIntegrationInput> | SyncLogCreateWithoutIntegrationInput[] | SyncLogUncheckedCreateWithoutIntegrationInput[]
    connectOrCreate?: SyncLogCreateOrConnectWithoutIntegrationInput | SyncLogCreateOrConnectWithoutIntegrationInput[]
    createMany?: SyncLogCreateManyIntegrationInputEnvelope
    connect?: SyncLogWhereUniqueInput | SyncLogWhereUniqueInput[]
  }

  export type ExternalGroupMappingUncheckedCreateNestedManyWithoutIntegrationInput = {
    create?: XOR<ExternalGroupMappingCreateWithoutIntegrationInput, ExternalGroupMappingUncheckedCreateWithoutIntegrationInput> | ExternalGroupMappingCreateWithoutIntegrationInput[] | ExternalGroupMappingUncheckedCreateWithoutIntegrationInput[]
    connectOrCreate?: ExternalGroupMappingCreateOrConnectWithoutIntegrationInput | ExternalGroupMappingCreateOrConnectWithoutIntegrationInput[]
    createMany?: ExternalGroupMappingCreateManyIntegrationInputEnvelope
    connect?: ExternalGroupMappingWhereUniqueInput | ExternalGroupMappingWhereUniqueInput[]
  }

  export type SyncLogUncheckedCreateNestedManyWithoutIntegrationInput = {
    create?: XOR<SyncLogCreateWithoutIntegrationInput, SyncLogUncheckedCreateWithoutIntegrationInput> | SyncLogCreateWithoutIntegrationInput[] | SyncLogUncheckedCreateWithoutIntegrationInput[]
    connectOrCreate?: SyncLogCreateOrConnectWithoutIntegrationInput | SyncLogCreateOrConnectWithoutIntegrationInput[]
    createMany?: SyncLogCreateManyIntegrationInputEnvelope
    connect?: SyncLogWhereUniqueInput | SyncLogWhereUniqueInput[]
  }

  export type EnumIntegrationProviderFieldUpdateOperationsInput = {
    set?: $Enums.IntegrationProvider
  }

  export type EnumIntegrationStatusFieldUpdateOperationsInput = {
    set?: $Enums.IntegrationStatus
  }

  export type EnumSyncFrequencyFieldUpdateOperationsInput = {
    set?: $Enums.SyncFrequency
  }

  export type NullableEnumSyncStatusFieldUpdateOperationsInput = {
    set?: $Enums.SyncStatus | null
  }

  export type OrganizationUpdateOneRequiredWithoutIntegrationsNestedInput = {
    create?: XOR<OrganizationCreateWithoutIntegrationsInput, OrganizationUncheckedCreateWithoutIntegrationsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutIntegrationsInput
    upsert?: OrganizationUpsertWithoutIntegrationsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutIntegrationsInput, OrganizationUpdateWithoutIntegrationsInput>, OrganizationUncheckedUpdateWithoutIntegrationsInput>
  }

  export type ExternalGroupMappingUpdateManyWithoutIntegrationNestedInput = {
    create?: XOR<ExternalGroupMappingCreateWithoutIntegrationInput, ExternalGroupMappingUncheckedCreateWithoutIntegrationInput> | ExternalGroupMappingCreateWithoutIntegrationInput[] | ExternalGroupMappingUncheckedCreateWithoutIntegrationInput[]
    connectOrCreate?: ExternalGroupMappingCreateOrConnectWithoutIntegrationInput | ExternalGroupMappingCreateOrConnectWithoutIntegrationInput[]
    upsert?: ExternalGroupMappingUpsertWithWhereUniqueWithoutIntegrationInput | ExternalGroupMappingUpsertWithWhereUniqueWithoutIntegrationInput[]
    createMany?: ExternalGroupMappingCreateManyIntegrationInputEnvelope
    set?: ExternalGroupMappingWhereUniqueInput | ExternalGroupMappingWhereUniqueInput[]
    disconnect?: ExternalGroupMappingWhereUniqueInput | ExternalGroupMappingWhereUniqueInput[]
    delete?: ExternalGroupMappingWhereUniqueInput | ExternalGroupMappingWhereUniqueInput[]
    connect?: ExternalGroupMappingWhereUniqueInput | ExternalGroupMappingWhereUniqueInput[]
    update?: ExternalGroupMappingUpdateWithWhereUniqueWithoutIntegrationInput | ExternalGroupMappingUpdateWithWhereUniqueWithoutIntegrationInput[]
    updateMany?: ExternalGroupMappingUpdateManyWithWhereWithoutIntegrationInput | ExternalGroupMappingUpdateManyWithWhereWithoutIntegrationInput[]
    deleteMany?: ExternalGroupMappingScalarWhereInput | ExternalGroupMappingScalarWhereInput[]
  }

  export type SyncLogUpdateManyWithoutIntegrationNestedInput = {
    create?: XOR<SyncLogCreateWithoutIntegrationInput, SyncLogUncheckedCreateWithoutIntegrationInput> | SyncLogCreateWithoutIntegrationInput[] | SyncLogUncheckedCreateWithoutIntegrationInput[]
    connectOrCreate?: SyncLogCreateOrConnectWithoutIntegrationInput | SyncLogCreateOrConnectWithoutIntegrationInput[]
    upsert?: SyncLogUpsertWithWhereUniqueWithoutIntegrationInput | SyncLogUpsertWithWhereUniqueWithoutIntegrationInput[]
    createMany?: SyncLogCreateManyIntegrationInputEnvelope
    set?: SyncLogWhereUniqueInput | SyncLogWhereUniqueInput[]
    disconnect?: SyncLogWhereUniqueInput | SyncLogWhereUniqueInput[]
    delete?: SyncLogWhereUniqueInput | SyncLogWhereUniqueInput[]
    connect?: SyncLogWhereUniqueInput | SyncLogWhereUniqueInput[]
    update?: SyncLogUpdateWithWhereUniqueWithoutIntegrationInput | SyncLogUpdateWithWhereUniqueWithoutIntegrationInput[]
    updateMany?: SyncLogUpdateManyWithWhereWithoutIntegrationInput | SyncLogUpdateManyWithWhereWithoutIntegrationInput[]
    deleteMany?: SyncLogScalarWhereInput | SyncLogScalarWhereInput[]
  }

  export type ExternalGroupMappingUncheckedUpdateManyWithoutIntegrationNestedInput = {
    create?: XOR<ExternalGroupMappingCreateWithoutIntegrationInput, ExternalGroupMappingUncheckedCreateWithoutIntegrationInput> | ExternalGroupMappingCreateWithoutIntegrationInput[] | ExternalGroupMappingUncheckedCreateWithoutIntegrationInput[]
    connectOrCreate?: ExternalGroupMappingCreateOrConnectWithoutIntegrationInput | ExternalGroupMappingCreateOrConnectWithoutIntegrationInput[]
    upsert?: ExternalGroupMappingUpsertWithWhereUniqueWithoutIntegrationInput | ExternalGroupMappingUpsertWithWhereUniqueWithoutIntegrationInput[]
    createMany?: ExternalGroupMappingCreateManyIntegrationInputEnvelope
    set?: ExternalGroupMappingWhereUniqueInput | ExternalGroupMappingWhereUniqueInput[]
    disconnect?: ExternalGroupMappingWhereUniqueInput | ExternalGroupMappingWhereUniqueInput[]
    delete?: ExternalGroupMappingWhereUniqueInput | ExternalGroupMappingWhereUniqueInput[]
    connect?: ExternalGroupMappingWhereUniqueInput | ExternalGroupMappingWhereUniqueInput[]
    update?: ExternalGroupMappingUpdateWithWhereUniqueWithoutIntegrationInput | ExternalGroupMappingUpdateWithWhereUniqueWithoutIntegrationInput[]
    updateMany?: ExternalGroupMappingUpdateManyWithWhereWithoutIntegrationInput | ExternalGroupMappingUpdateManyWithWhereWithoutIntegrationInput[]
    deleteMany?: ExternalGroupMappingScalarWhereInput | ExternalGroupMappingScalarWhereInput[]
  }

  export type SyncLogUncheckedUpdateManyWithoutIntegrationNestedInput = {
    create?: XOR<SyncLogCreateWithoutIntegrationInput, SyncLogUncheckedCreateWithoutIntegrationInput> | SyncLogCreateWithoutIntegrationInput[] | SyncLogUncheckedCreateWithoutIntegrationInput[]
    connectOrCreate?: SyncLogCreateOrConnectWithoutIntegrationInput | SyncLogCreateOrConnectWithoutIntegrationInput[]
    upsert?: SyncLogUpsertWithWhereUniqueWithoutIntegrationInput | SyncLogUpsertWithWhereUniqueWithoutIntegrationInput[]
    createMany?: SyncLogCreateManyIntegrationInputEnvelope
    set?: SyncLogWhereUniqueInput | SyncLogWhereUniqueInput[]
    disconnect?: SyncLogWhereUniqueInput | SyncLogWhereUniqueInput[]
    delete?: SyncLogWhereUniqueInput | SyncLogWhereUniqueInput[]
    connect?: SyncLogWhereUniqueInput | SyncLogWhereUniqueInput[]
    update?: SyncLogUpdateWithWhereUniqueWithoutIntegrationInput | SyncLogUpdateWithWhereUniqueWithoutIntegrationInput[]
    updateMany?: SyncLogUpdateManyWithWhereWithoutIntegrationInput | SyncLogUpdateManyWithWhereWithoutIntegrationInput[]
    deleteMany?: SyncLogScalarWhereInput | SyncLogScalarWhereInput[]
  }

  export type ExternalIntegrationCreateNestedOneWithoutGroupMappingsInput = {
    create?: XOR<ExternalIntegrationCreateWithoutGroupMappingsInput, ExternalIntegrationUncheckedCreateWithoutGroupMappingsInput>
    connectOrCreate?: ExternalIntegrationCreateOrConnectWithoutGroupMappingsInput
    connect?: ExternalIntegrationWhereUniqueInput
  }

  export type GroupCreateNestedOneWithoutMappingsInput = {
    create?: XOR<GroupCreateWithoutMappingsInput, GroupUncheckedCreateWithoutMappingsInput>
    connectOrCreate?: GroupCreateOrConnectWithoutMappingsInput
    connect?: GroupWhereUniqueInput
  }

  export type ExternalIntegrationUpdateOneRequiredWithoutGroupMappingsNestedInput = {
    create?: XOR<ExternalIntegrationCreateWithoutGroupMappingsInput, ExternalIntegrationUncheckedCreateWithoutGroupMappingsInput>
    connectOrCreate?: ExternalIntegrationCreateOrConnectWithoutGroupMappingsInput
    upsert?: ExternalIntegrationUpsertWithoutGroupMappingsInput
    connect?: ExternalIntegrationWhereUniqueInput
    update?: XOR<XOR<ExternalIntegrationUpdateToOneWithWhereWithoutGroupMappingsInput, ExternalIntegrationUpdateWithoutGroupMappingsInput>, ExternalIntegrationUncheckedUpdateWithoutGroupMappingsInput>
  }

  export type GroupUpdateOneWithoutMappingsNestedInput = {
    create?: XOR<GroupCreateWithoutMappingsInput, GroupUncheckedCreateWithoutMappingsInput>
    connectOrCreate?: GroupCreateOrConnectWithoutMappingsInput
    upsert?: GroupUpsertWithoutMappingsInput
    disconnect?: GroupWhereInput | boolean
    delete?: GroupWhereInput | boolean
    connect?: GroupWhereUniqueInput
    update?: XOR<XOR<GroupUpdateToOneWithWhereWithoutMappingsInput, GroupUpdateWithoutMappingsInput>, GroupUncheckedUpdateWithoutMappingsInput>
  }

  export type ExternalIntegrationCreateNestedOneWithoutSyncLogsInput = {
    create?: XOR<ExternalIntegrationCreateWithoutSyncLogsInput, ExternalIntegrationUncheckedCreateWithoutSyncLogsInput>
    connectOrCreate?: ExternalIntegrationCreateOrConnectWithoutSyncLogsInput
    connect?: ExternalIntegrationWhereUniqueInput
  }

  export type EnumSyncStatusFieldUpdateOperationsInput = {
    set?: $Enums.SyncStatus
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ExternalIntegrationUpdateOneRequiredWithoutSyncLogsNestedInput = {
    create?: XOR<ExternalIntegrationCreateWithoutSyncLogsInput, ExternalIntegrationUncheckedCreateWithoutSyncLogsInput>
    connectOrCreate?: ExternalIntegrationCreateOrConnectWithoutSyncLogsInput
    upsert?: ExternalIntegrationUpsertWithoutSyncLogsInput
    connect?: ExternalIntegrationWhereUniqueInput
    update?: XOR<XOR<ExternalIntegrationUpdateToOneWithWhereWithoutSyncLogsInput, ExternalIntegrationUpdateWithoutSyncLogsInput>, ExternalIntegrationUncheckedUpdateWithoutSyncLogsInput>
  }

  export type OrganizationCreateNestedOneWithoutLessonsInput = {
    create?: XOR<OrganizationCreateWithoutLessonsInput, OrganizationUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutLessonsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type LessonGroupCreateNestedManyWithoutLessonInput = {
    create?: XOR<LessonGroupCreateWithoutLessonInput, LessonGroupUncheckedCreateWithoutLessonInput> | LessonGroupCreateWithoutLessonInput[] | LessonGroupUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: LessonGroupCreateOrConnectWithoutLessonInput | LessonGroupCreateOrConnectWithoutLessonInput[]
    createMany?: LessonGroupCreateManyLessonInputEnvelope
    connect?: LessonGroupWhereUniqueInput | LessonGroupWhereUniqueInput[]
  }

  export type LessonGroupUncheckedCreateNestedManyWithoutLessonInput = {
    create?: XOR<LessonGroupCreateWithoutLessonInput, LessonGroupUncheckedCreateWithoutLessonInput> | LessonGroupCreateWithoutLessonInput[] | LessonGroupUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: LessonGroupCreateOrConnectWithoutLessonInput | LessonGroupCreateOrConnectWithoutLessonInput[]
    createMany?: LessonGroupCreateManyLessonInputEnvelope
    connect?: LessonGroupWhereUniqueInput | LessonGroupWhereUniqueInput[]
  }

  export type OrganizationUpdateOneRequiredWithoutLessonsNestedInput = {
    create?: XOR<OrganizationCreateWithoutLessonsInput, OrganizationUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutLessonsInput
    upsert?: OrganizationUpsertWithoutLessonsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutLessonsInput, OrganizationUpdateWithoutLessonsInput>, OrganizationUncheckedUpdateWithoutLessonsInput>
  }

  export type LessonGroupUpdateManyWithoutLessonNestedInput = {
    create?: XOR<LessonGroupCreateWithoutLessonInput, LessonGroupUncheckedCreateWithoutLessonInput> | LessonGroupCreateWithoutLessonInput[] | LessonGroupUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: LessonGroupCreateOrConnectWithoutLessonInput | LessonGroupCreateOrConnectWithoutLessonInput[]
    upsert?: LessonGroupUpsertWithWhereUniqueWithoutLessonInput | LessonGroupUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: LessonGroupCreateManyLessonInputEnvelope
    set?: LessonGroupWhereUniqueInput | LessonGroupWhereUniqueInput[]
    disconnect?: LessonGroupWhereUniqueInput | LessonGroupWhereUniqueInput[]
    delete?: LessonGroupWhereUniqueInput | LessonGroupWhereUniqueInput[]
    connect?: LessonGroupWhereUniqueInput | LessonGroupWhereUniqueInput[]
    update?: LessonGroupUpdateWithWhereUniqueWithoutLessonInput | LessonGroupUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: LessonGroupUpdateManyWithWhereWithoutLessonInput | LessonGroupUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: LessonGroupScalarWhereInput | LessonGroupScalarWhereInput[]
  }

  export type LessonGroupUncheckedUpdateManyWithoutLessonNestedInput = {
    create?: XOR<LessonGroupCreateWithoutLessonInput, LessonGroupUncheckedCreateWithoutLessonInput> | LessonGroupCreateWithoutLessonInput[] | LessonGroupUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: LessonGroupCreateOrConnectWithoutLessonInput | LessonGroupCreateOrConnectWithoutLessonInput[]
    upsert?: LessonGroupUpsertWithWhereUniqueWithoutLessonInput | LessonGroupUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: LessonGroupCreateManyLessonInputEnvelope
    set?: LessonGroupWhereUniqueInput | LessonGroupWhereUniqueInput[]
    disconnect?: LessonGroupWhereUniqueInput | LessonGroupWhereUniqueInput[]
    delete?: LessonGroupWhereUniqueInput | LessonGroupWhereUniqueInput[]
    connect?: LessonGroupWhereUniqueInput | LessonGroupWhereUniqueInput[]
    update?: LessonGroupUpdateWithWhereUniqueWithoutLessonInput | LessonGroupUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: LessonGroupUpdateManyWithWhereWithoutLessonInput | LessonGroupUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: LessonGroupScalarWhereInput | LessonGroupScalarWhereInput[]
  }

  export type LessonCreateNestedOneWithoutGroupsInput = {
    create?: XOR<LessonCreateWithoutGroupsInput, LessonUncheckedCreateWithoutGroupsInput>
    connectOrCreate?: LessonCreateOrConnectWithoutGroupsInput
    connect?: LessonWhereUniqueInput
  }

  export type GroupCreateNestedOneWithoutLessonsInput = {
    create?: XOR<GroupCreateWithoutLessonsInput, GroupUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: GroupCreateOrConnectWithoutLessonsInput
    connect?: GroupWhereUniqueInput
  }

  export type LessonUpdateOneRequiredWithoutGroupsNestedInput = {
    create?: XOR<LessonCreateWithoutGroupsInput, LessonUncheckedCreateWithoutGroupsInput>
    connectOrCreate?: LessonCreateOrConnectWithoutGroupsInput
    upsert?: LessonUpsertWithoutGroupsInput
    connect?: LessonWhereUniqueInput
    update?: XOR<XOR<LessonUpdateToOneWithWhereWithoutGroupsInput, LessonUpdateWithoutGroupsInput>, LessonUncheckedUpdateWithoutGroupsInput>
  }

  export type GroupUpdateOneRequiredWithoutLessonsNestedInput = {
    create?: XOR<GroupCreateWithoutLessonsInput, GroupUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: GroupCreateOrConnectWithoutLessonsInput
    upsert?: GroupUpsertWithoutLessonsInput
    connect?: GroupWhereUniqueInput
    update?: XOR<XOR<GroupUpdateToOneWithWhereWithoutLessonsInput, GroupUpdateWithoutLessonsInput>, GroupUncheckedUpdateWithoutLessonsInput>
  }

  export type OrganizationCreateNestedOneWithoutAiFilterConfigsInput = {
    create?: XOR<OrganizationCreateWithoutAiFilterConfigsInput, OrganizationUncheckedCreateWithoutAiFilterConfigsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutAiFilterConfigsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type AIFilterMetricCreateNestedManyWithoutFilterInput = {
    create?: XOR<AIFilterMetricCreateWithoutFilterInput, AIFilterMetricUncheckedCreateWithoutFilterInput> | AIFilterMetricCreateWithoutFilterInput[] | AIFilterMetricUncheckedCreateWithoutFilterInput[]
    connectOrCreate?: AIFilterMetricCreateOrConnectWithoutFilterInput | AIFilterMetricCreateOrConnectWithoutFilterInput[]
    createMany?: AIFilterMetricCreateManyFilterInputEnvelope
    connect?: AIFilterMetricWhereUniqueInput | AIFilterMetricWhereUniqueInput[]
  }

  export type AIFilterMetricUncheckedCreateNestedManyWithoutFilterInput = {
    create?: XOR<AIFilterMetricCreateWithoutFilterInput, AIFilterMetricUncheckedCreateWithoutFilterInput> | AIFilterMetricCreateWithoutFilterInput[] | AIFilterMetricUncheckedCreateWithoutFilterInput[]
    connectOrCreate?: AIFilterMetricCreateOrConnectWithoutFilterInput | AIFilterMetricCreateOrConnectWithoutFilterInput[]
    createMany?: AIFilterMetricCreateManyFilterInputEnvelope
    connect?: AIFilterMetricWhereUniqueInput | AIFilterMetricWhereUniqueInput[]
  }

  export type OrganizationUpdateOneWithoutAiFilterConfigsNestedInput = {
    create?: XOR<OrganizationCreateWithoutAiFilterConfigsInput, OrganizationUncheckedCreateWithoutAiFilterConfigsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutAiFilterConfigsInput
    upsert?: OrganizationUpsertWithoutAiFilterConfigsInput
    disconnect?: OrganizationWhereInput | boolean
    delete?: OrganizationWhereInput | boolean
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutAiFilterConfigsInput, OrganizationUpdateWithoutAiFilterConfigsInput>, OrganizationUncheckedUpdateWithoutAiFilterConfigsInput>
  }

  export type AIFilterMetricUpdateManyWithoutFilterNestedInput = {
    create?: XOR<AIFilterMetricCreateWithoutFilterInput, AIFilterMetricUncheckedCreateWithoutFilterInput> | AIFilterMetricCreateWithoutFilterInput[] | AIFilterMetricUncheckedCreateWithoutFilterInput[]
    connectOrCreate?: AIFilterMetricCreateOrConnectWithoutFilterInput | AIFilterMetricCreateOrConnectWithoutFilterInput[]
    upsert?: AIFilterMetricUpsertWithWhereUniqueWithoutFilterInput | AIFilterMetricUpsertWithWhereUniqueWithoutFilterInput[]
    createMany?: AIFilterMetricCreateManyFilterInputEnvelope
    set?: AIFilterMetricWhereUniqueInput | AIFilterMetricWhereUniqueInput[]
    disconnect?: AIFilterMetricWhereUniqueInput | AIFilterMetricWhereUniqueInput[]
    delete?: AIFilterMetricWhereUniqueInput | AIFilterMetricWhereUniqueInput[]
    connect?: AIFilterMetricWhereUniqueInput | AIFilterMetricWhereUniqueInput[]
    update?: AIFilterMetricUpdateWithWhereUniqueWithoutFilterInput | AIFilterMetricUpdateWithWhereUniqueWithoutFilterInput[]
    updateMany?: AIFilterMetricUpdateManyWithWhereWithoutFilterInput | AIFilterMetricUpdateManyWithWhereWithoutFilterInput[]
    deleteMany?: AIFilterMetricScalarWhereInput | AIFilterMetricScalarWhereInput[]
  }

  export type AIFilterMetricUncheckedUpdateManyWithoutFilterNestedInput = {
    create?: XOR<AIFilterMetricCreateWithoutFilterInput, AIFilterMetricUncheckedCreateWithoutFilterInput> | AIFilterMetricCreateWithoutFilterInput[] | AIFilterMetricUncheckedCreateWithoutFilterInput[]
    connectOrCreate?: AIFilterMetricCreateOrConnectWithoutFilterInput | AIFilterMetricCreateOrConnectWithoutFilterInput[]
    upsert?: AIFilterMetricUpsertWithWhereUniqueWithoutFilterInput | AIFilterMetricUpsertWithWhereUniqueWithoutFilterInput[]
    createMany?: AIFilterMetricCreateManyFilterInputEnvelope
    set?: AIFilterMetricWhereUniqueInput | AIFilterMetricWhereUniqueInput[]
    disconnect?: AIFilterMetricWhereUniqueInput | AIFilterMetricWhereUniqueInput[]
    delete?: AIFilterMetricWhereUniqueInput | AIFilterMetricWhereUniqueInput[]
    connect?: AIFilterMetricWhereUniqueInput | AIFilterMetricWhereUniqueInput[]
    update?: AIFilterMetricUpdateWithWhereUniqueWithoutFilterInput | AIFilterMetricUpdateWithWhereUniqueWithoutFilterInput[]
    updateMany?: AIFilterMetricUpdateManyWithWhereWithoutFilterInput | AIFilterMetricUpdateManyWithWhereWithoutFilterInput[]
    deleteMany?: AIFilterMetricScalarWhereInput | AIFilterMetricScalarWhereInput[]
  }

  export type AIFilterConfigCreateNestedOneWithoutMetricsInput = {
    create?: XOR<AIFilterConfigCreateWithoutMetricsInput, AIFilterConfigUncheckedCreateWithoutMetricsInput>
    connectOrCreate?: AIFilterConfigCreateOrConnectWithoutMetricsInput
    connect?: AIFilterConfigWhereUniqueInput
  }

  export type EnumFilterCategoryFieldUpdateOperationsInput = {
    set?: $Enums.FilterCategory
  }

  export type EnumFilterActionFieldUpdateOperationsInput = {
    set?: $Enums.FilterAction
  }

  export type AIFilterConfigUpdateOneRequiredWithoutMetricsNestedInput = {
    create?: XOR<AIFilterConfigCreateWithoutMetricsInput, AIFilterConfigUncheckedCreateWithoutMetricsInput>
    connectOrCreate?: AIFilterConfigCreateOrConnectWithoutMetricsInput
    upsert?: AIFilterConfigUpsertWithoutMetricsInput
    connect?: AIFilterConfigWhereUniqueInput
    update?: XOR<XOR<AIFilterConfigUpdateToOneWithWhereWithoutMetricsInput, AIFilterConfigUpdateWithoutMetricsInput>, AIFilterConfigUncheckedUpdateWithoutMetricsInput>
  }

  export type OrganizationCreateNestedOneWithoutComparativeThemesInput = {
    create?: XOR<OrganizationCreateWithoutComparativeThemesInput, OrganizationUncheckedCreateWithoutComparativeThemesInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutComparativeThemesInput
    connect?: OrganizationWhereUniqueInput
  }

  export type ThemeMetricCreateNestedManyWithoutThemeInput = {
    create?: XOR<ThemeMetricCreateWithoutThemeInput, ThemeMetricUncheckedCreateWithoutThemeInput> | ThemeMetricCreateWithoutThemeInput[] | ThemeMetricUncheckedCreateWithoutThemeInput[]
    connectOrCreate?: ThemeMetricCreateOrConnectWithoutThemeInput | ThemeMetricCreateOrConnectWithoutThemeInput[]
    createMany?: ThemeMetricCreateManyThemeInputEnvelope
    connect?: ThemeMetricWhereUniqueInput | ThemeMetricWhereUniqueInput[]
  }

  export type ThemeMetricUncheckedCreateNestedManyWithoutThemeInput = {
    create?: XOR<ThemeMetricCreateWithoutThemeInput, ThemeMetricUncheckedCreateWithoutThemeInput> | ThemeMetricCreateWithoutThemeInput[] | ThemeMetricUncheckedCreateWithoutThemeInput[]
    connectOrCreate?: ThemeMetricCreateOrConnectWithoutThemeInput | ThemeMetricCreateOrConnectWithoutThemeInput[]
    createMany?: ThemeMetricCreateManyThemeInputEnvelope
    connect?: ThemeMetricWhereUniqueInput | ThemeMetricWhereUniqueInput[]
  }

  export type OrganizationUpdateOneRequiredWithoutComparativeThemesNestedInput = {
    create?: XOR<OrganizationCreateWithoutComparativeThemesInput, OrganizationUncheckedCreateWithoutComparativeThemesInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutComparativeThemesInput
    upsert?: OrganizationUpsertWithoutComparativeThemesInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutComparativeThemesInput, OrganizationUpdateWithoutComparativeThemesInput>, OrganizationUncheckedUpdateWithoutComparativeThemesInput>
  }

  export type ThemeMetricUpdateManyWithoutThemeNestedInput = {
    create?: XOR<ThemeMetricCreateWithoutThemeInput, ThemeMetricUncheckedCreateWithoutThemeInput> | ThemeMetricCreateWithoutThemeInput[] | ThemeMetricUncheckedCreateWithoutThemeInput[]
    connectOrCreate?: ThemeMetricCreateOrConnectWithoutThemeInput | ThemeMetricCreateOrConnectWithoutThemeInput[]
    upsert?: ThemeMetricUpsertWithWhereUniqueWithoutThemeInput | ThemeMetricUpsertWithWhereUniqueWithoutThemeInput[]
    createMany?: ThemeMetricCreateManyThemeInputEnvelope
    set?: ThemeMetricWhereUniqueInput | ThemeMetricWhereUniqueInput[]
    disconnect?: ThemeMetricWhereUniqueInput | ThemeMetricWhereUniqueInput[]
    delete?: ThemeMetricWhereUniqueInput | ThemeMetricWhereUniqueInput[]
    connect?: ThemeMetricWhereUniqueInput | ThemeMetricWhereUniqueInput[]
    update?: ThemeMetricUpdateWithWhereUniqueWithoutThemeInput | ThemeMetricUpdateWithWhereUniqueWithoutThemeInput[]
    updateMany?: ThemeMetricUpdateManyWithWhereWithoutThemeInput | ThemeMetricUpdateManyWithWhereWithoutThemeInput[]
    deleteMany?: ThemeMetricScalarWhereInput | ThemeMetricScalarWhereInput[]
  }

  export type ThemeMetricUncheckedUpdateManyWithoutThemeNestedInput = {
    create?: XOR<ThemeMetricCreateWithoutThemeInput, ThemeMetricUncheckedCreateWithoutThemeInput> | ThemeMetricCreateWithoutThemeInput[] | ThemeMetricUncheckedCreateWithoutThemeInput[]
    connectOrCreate?: ThemeMetricCreateOrConnectWithoutThemeInput | ThemeMetricCreateOrConnectWithoutThemeInput[]
    upsert?: ThemeMetricUpsertWithWhereUniqueWithoutThemeInput | ThemeMetricUpsertWithWhereUniqueWithoutThemeInput[]
    createMany?: ThemeMetricCreateManyThemeInputEnvelope
    set?: ThemeMetricWhereUniqueInput | ThemeMetricWhereUniqueInput[]
    disconnect?: ThemeMetricWhereUniqueInput | ThemeMetricWhereUniqueInput[]
    delete?: ThemeMetricWhereUniqueInput | ThemeMetricWhereUniqueInput[]
    connect?: ThemeMetricWhereUniqueInput | ThemeMetricWhereUniqueInput[]
    update?: ThemeMetricUpdateWithWhereUniqueWithoutThemeInput | ThemeMetricUpdateWithWhereUniqueWithoutThemeInput[]
    updateMany?: ThemeMetricUpdateManyWithWhereWithoutThemeInput | ThemeMetricUpdateManyWithWhereWithoutThemeInput[]
    deleteMany?: ThemeMetricScalarWhereInput | ThemeMetricScalarWhereInput[]
  }

  export type ComparativeThemeCreateNestedOneWithoutMetricsInput = {
    create?: XOR<ComparativeThemeCreateWithoutMetricsInput, ComparativeThemeUncheckedCreateWithoutMetricsInput>
    connectOrCreate?: ComparativeThemeCreateOrConnectWithoutMetricsInput
    connect?: ComparativeThemeWhereUniqueInput
  }

  export type ComparativeThemeUpdateOneRequiredWithoutMetricsNestedInput = {
    create?: XOR<ComparativeThemeCreateWithoutMetricsInput, ComparativeThemeUncheckedCreateWithoutMetricsInput>
    connectOrCreate?: ComparativeThemeCreateOrConnectWithoutMetricsInput
    upsert?: ComparativeThemeUpsertWithoutMetricsInput
    connect?: ComparativeThemeWhereUniqueInput
    update?: XOR<XOR<ComparativeThemeUpdateToOneWithWhereWithoutMetricsInput, ComparativeThemeUpdateWithoutMetricsInput>, ComparativeThemeUncheckedUpdateWithoutMetricsInput>
  }

  export type UserCreateNestedOneWithoutNotificationPreferenceInput = {
    create?: XOR<UserCreateWithoutNotificationPreferenceInput, UserUncheckedCreateWithoutNotificationPreferenceInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationPreferenceInput
    connect?: UserWhereUniqueInput
  }

  export type EnumDigestFrequencyFieldUpdateOperationsInput = {
    set?: $Enums.DigestFrequency
  }

  export type UserUpdateOneRequiredWithoutNotificationPreferenceNestedInput = {
    create?: XOR<UserCreateWithoutNotificationPreferenceInput, UserUncheckedCreateWithoutNotificationPreferenceInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationPreferenceInput
    upsert?: UserUpsertWithoutNotificationPreferenceInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationPreferenceInput, UserUpdateWithoutNotificationPreferenceInput>, UserUncheckedUpdateWithoutNotificationPreferenceInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type EnumNotificationDeliveryMethodFieldUpdateOperationsInput = {
    set?: $Enums.NotificationDeliveryMethod
  }

  export type EnumNotificationPriorityFieldUpdateOperationsInput = {
    set?: $Enums.NotificationPriority
  }

  export type EnumNotificationStatusFieldUpdateOperationsInput = {
    set?: $Enums.NotificationStatus
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type EnumScheduleFrequencyFieldUpdateOperationsInput = {
    set?: $Enums.ScheduleFrequency
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumIntegrationProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.IntegrationProvider | EnumIntegrationProviderFieldRefInput<$PrismaModel>
    in?: $Enums.IntegrationProvider[] | ListEnumIntegrationProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.IntegrationProvider[] | ListEnumIntegrationProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumIntegrationProviderFilter<$PrismaModel> | $Enums.IntegrationProvider
  }

  export type NestedEnumIntegrationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.IntegrationStatus | EnumIntegrationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IntegrationStatus[] | ListEnumIntegrationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IntegrationStatus[] | ListEnumIntegrationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIntegrationStatusFilter<$PrismaModel> | $Enums.IntegrationStatus
  }

  export type NestedEnumSyncFrequencyFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncFrequency | EnumSyncFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.SyncFrequency[] | ListEnumSyncFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyncFrequency[] | ListEnumSyncFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumSyncFrequencyFilter<$PrismaModel> | $Enums.SyncFrequency
  }

  export type NestedEnumSyncStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncStatus | EnumSyncStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSyncStatusNullableFilter<$PrismaModel> | $Enums.SyncStatus | null
  }

  export type NestedEnumIntegrationProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IntegrationProvider | EnumIntegrationProviderFieldRefInput<$PrismaModel>
    in?: $Enums.IntegrationProvider[] | ListEnumIntegrationProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.IntegrationProvider[] | ListEnumIntegrationProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumIntegrationProviderWithAggregatesFilter<$PrismaModel> | $Enums.IntegrationProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIntegrationProviderFilter<$PrismaModel>
    _max?: NestedEnumIntegrationProviderFilter<$PrismaModel>
  }

  export type NestedEnumIntegrationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IntegrationStatus | EnumIntegrationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IntegrationStatus[] | ListEnumIntegrationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IntegrationStatus[] | ListEnumIntegrationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIntegrationStatusWithAggregatesFilter<$PrismaModel> | $Enums.IntegrationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIntegrationStatusFilter<$PrismaModel>
    _max?: NestedEnumIntegrationStatusFilter<$PrismaModel>
  }

  export type NestedEnumSyncFrequencyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncFrequency | EnumSyncFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.SyncFrequency[] | ListEnumSyncFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyncFrequency[] | ListEnumSyncFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumSyncFrequencyWithAggregatesFilter<$PrismaModel> | $Enums.SyncFrequency
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSyncFrequencyFilter<$PrismaModel>
    _max?: NestedEnumSyncFrequencyFilter<$PrismaModel>
  }

  export type NestedEnumSyncStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncStatus | EnumSyncStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSyncStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.SyncStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSyncStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumSyncStatusNullableFilter<$PrismaModel>
  }

  export type NestedEnumSyncStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncStatus | EnumSyncStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSyncStatusFilter<$PrismaModel> | $Enums.SyncStatus
  }

  export type NestedEnumSyncStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncStatus | EnumSyncStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SyncStatus[] | ListEnumSyncStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSyncStatusWithAggregatesFilter<$PrismaModel> | $Enums.SyncStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSyncStatusFilter<$PrismaModel>
    _max?: NestedEnumSyncStatusFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumFilterCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.FilterCategory | EnumFilterCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.FilterCategory[] | ListEnumFilterCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.FilterCategory[] | ListEnumFilterCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumFilterCategoryFilter<$PrismaModel> | $Enums.FilterCategory
  }

  export type NestedEnumFilterActionFilter<$PrismaModel = never> = {
    equals?: $Enums.FilterAction | EnumFilterActionFieldRefInput<$PrismaModel>
    in?: $Enums.FilterAction[] | ListEnumFilterActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.FilterAction[] | ListEnumFilterActionFieldRefInput<$PrismaModel>
    not?: NestedEnumFilterActionFilter<$PrismaModel> | $Enums.FilterAction
  }

  export type NestedEnumFilterCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FilterCategory | EnumFilterCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.FilterCategory[] | ListEnumFilterCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.FilterCategory[] | ListEnumFilterCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumFilterCategoryWithAggregatesFilter<$PrismaModel> | $Enums.FilterCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFilterCategoryFilter<$PrismaModel>
    _max?: NestedEnumFilterCategoryFilter<$PrismaModel>
  }

  export type NestedEnumFilterActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FilterAction | EnumFilterActionFieldRefInput<$PrismaModel>
    in?: $Enums.FilterAction[] | ListEnumFilterActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.FilterAction[] | ListEnumFilterActionFieldRefInput<$PrismaModel>
    not?: NestedEnumFilterActionWithAggregatesFilter<$PrismaModel> | $Enums.FilterAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFilterActionFilter<$PrismaModel>
    _max?: NestedEnumFilterActionFilter<$PrismaModel>
  }

  export type NestedEnumDigestFrequencyFilter<$PrismaModel = never> = {
    equals?: $Enums.DigestFrequency | EnumDigestFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.DigestFrequency[] | ListEnumDigestFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.DigestFrequency[] | ListEnumDigestFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumDigestFrequencyFilter<$PrismaModel> | $Enums.DigestFrequency
  }

  export type NestedEnumDigestFrequencyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DigestFrequency | EnumDigestFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.DigestFrequency[] | ListEnumDigestFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.DigestFrequency[] | ListEnumDigestFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumDigestFrequencyWithAggregatesFilter<$PrismaModel> | $Enums.DigestFrequency
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDigestFrequencyFilter<$PrismaModel>
    _max?: NestedEnumDigestFrequencyFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationDeliveryMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationDeliveryMethod | EnumNotificationDeliveryMethodFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationDeliveryMethod[] | ListEnumNotificationDeliveryMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationDeliveryMethod[] | ListEnumNotificationDeliveryMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationDeliveryMethodFilter<$PrismaModel> | $Enums.NotificationDeliveryMethod
  }

  export type NestedEnumNotificationPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationPriority | EnumNotificationPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationPriorityFilter<$PrismaModel> | $Enums.NotificationPriority
  }

  export type NestedEnumNotificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusFilter<$PrismaModel> | $Enums.NotificationStatus
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumNotificationDeliveryMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationDeliveryMethod | EnumNotificationDeliveryMethodFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationDeliveryMethod[] | ListEnumNotificationDeliveryMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationDeliveryMethod[] | ListEnumNotificationDeliveryMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationDeliveryMethodWithAggregatesFilter<$PrismaModel> | $Enums.NotificationDeliveryMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationDeliveryMethodFilter<$PrismaModel>
    _max?: NestedEnumNotificationDeliveryMethodFilter<$PrismaModel>
  }

  export type NestedEnumNotificationPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationPriority | EnumNotificationPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationPriorityWithAggregatesFilter<$PrismaModel> | $Enums.NotificationPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationPriorityFilter<$PrismaModel>
    _max?: NestedEnumNotificationPriorityFilter<$PrismaModel>
  }

  export type NestedEnumNotificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.NotificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationStatusFilter<$PrismaModel>
    _max?: NestedEnumNotificationStatusFilter<$PrismaModel>
  }

  export type NestedEnumScheduleFrequencyFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduleFrequency | EnumScheduleFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.ScheduleFrequency[] | ListEnumScheduleFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScheduleFrequency[] | ListEnumScheduleFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumScheduleFrequencyFilter<$PrismaModel> | $Enums.ScheduleFrequency
  }

  export type NestedEnumScheduleFrequencyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduleFrequency | EnumScheduleFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.ScheduleFrequency[] | ListEnumScheduleFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScheduleFrequency[] | ListEnumScheduleFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumScheduleFrequencyWithAggregatesFilter<$PrismaModel> | $Enums.ScheduleFrequency
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumScheduleFrequencyFilter<$PrismaModel>
    _max?: NestedEnumScheduleFrequencyFilter<$PrismaModel>
  }

  export type UserCreateWithoutOrganizationInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.Role
    isActive?: boolean
    externalId?: string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOrganizationInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.Role
    isActive?: boolean
    externalId?: string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOrganizationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput>
  }

  export type UserCreateManyOrganizationInputEnvelope = {
    data: UserCreateManyOrganizationInput | UserCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type GroupCreateWithoutOrganizationInput = {
    id?: string
    name: string
    description?: string | null
    externalId?: string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    ageMin?: number | null
    ageMax?: number | null
    grade?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: GroupMemberCreateNestedManyWithoutGroupInput
    mappings?: ExternalGroupMappingCreateNestedManyWithoutGroupInput
    lessons?: LessonGroupCreateNestedManyWithoutGroupInput
  }

  export type GroupUncheckedCreateWithoutOrganizationInput = {
    id?: string
    name: string
    description?: string | null
    externalId?: string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    ageMin?: number | null
    ageMax?: number | null
    grade?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: GroupMemberUncheckedCreateNestedManyWithoutGroupInput
    mappings?: ExternalGroupMappingUncheckedCreateNestedManyWithoutGroupInput
    lessons?: LessonGroupUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupCreateOrConnectWithoutOrganizationInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutOrganizationInput, GroupUncheckedCreateWithoutOrganizationInput>
  }

  export type GroupCreateManyOrganizationInputEnvelope = {
    data: GroupCreateManyOrganizationInput | GroupCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type ExternalIntegrationCreateWithoutOrganizationInput = {
    id?: string
    provider: $Enums.IntegrationProvider
    status?: $Enums.IntegrationStatus
    credentialsEncrypted: string
    credentialsIV: string
    credentialsTag: string
    accessToken?: string | null
    refreshToken?: string | null
    tokenExpiresAt?: Date | string | null
    apiBaseUrl?: string | null
    apiVersion?: string | null
    syncEnabled?: boolean
    syncFrequency?: $Enums.SyncFrequency
    lastSyncAt?: Date | string | null
    lastSyncStatus?: $Enums.SyncStatus | null
    nextSyncAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    groupMappings?: ExternalGroupMappingCreateNestedManyWithoutIntegrationInput
    syncLogs?: SyncLogCreateNestedManyWithoutIntegrationInput
  }

  export type ExternalIntegrationUncheckedCreateWithoutOrganizationInput = {
    id?: string
    provider: $Enums.IntegrationProvider
    status?: $Enums.IntegrationStatus
    credentialsEncrypted: string
    credentialsIV: string
    credentialsTag: string
    accessToken?: string | null
    refreshToken?: string | null
    tokenExpiresAt?: Date | string | null
    apiBaseUrl?: string | null
    apiVersion?: string | null
    syncEnabled?: boolean
    syncFrequency?: $Enums.SyncFrequency
    lastSyncAt?: Date | string | null
    lastSyncStatus?: $Enums.SyncStatus | null
    nextSyncAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    groupMappings?: ExternalGroupMappingUncheckedCreateNestedManyWithoutIntegrationInput
    syncLogs?: SyncLogUncheckedCreateNestedManyWithoutIntegrationInput
  }

  export type ExternalIntegrationCreateOrConnectWithoutOrganizationInput = {
    where: ExternalIntegrationWhereUniqueInput
    create: XOR<ExternalIntegrationCreateWithoutOrganizationInput, ExternalIntegrationUncheckedCreateWithoutOrganizationInput>
  }

  export type ExternalIntegrationCreateManyOrganizationInputEnvelope = {
    data: ExternalIntegrationCreateManyOrganizationInput | ExternalIntegrationCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type LessonCreateWithoutOrganizationInput = {
    id?: string
    title: string
    quarter: number
    unit: number
    lessonNumber: number
    scripture: string
    content: JsonNullValueInput | InputJsonValue
    slides?: NullableJsonNullValueInput | InputJsonValue
    games?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: boolean
    isTemplate?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    groups?: LessonGroupCreateNestedManyWithoutLessonInput
  }

  export type LessonUncheckedCreateWithoutOrganizationInput = {
    id?: string
    title: string
    quarter: number
    unit: number
    lessonNumber: number
    scripture: string
    content: JsonNullValueInput | InputJsonValue
    slides?: NullableJsonNullValueInput | InputJsonValue
    games?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: boolean
    isTemplate?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    groups?: LessonGroupUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonCreateOrConnectWithoutOrganizationInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutOrganizationInput, LessonUncheckedCreateWithoutOrganizationInput>
  }

  export type LessonCreateManyOrganizationInputEnvelope = {
    data: LessonCreateManyOrganizationInput | LessonCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type AIFilterConfigCreateWithoutOrganizationInput = {
    id?: string
    filterRules: JsonNullValueInput | InputJsonValue
    customKeywords?: NullableJsonNullValueInput | InputJsonValue
    redirectMessage?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    metrics?: AIFilterMetricCreateNestedManyWithoutFilterInput
  }

  export type AIFilterConfigUncheckedCreateWithoutOrganizationInput = {
    id?: string
    filterRules: JsonNullValueInput | InputJsonValue
    customKeywords?: NullableJsonNullValueInput | InputJsonValue
    redirectMessage?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    metrics?: AIFilterMetricUncheckedCreateNestedManyWithoutFilterInput
  }

  export type AIFilterConfigCreateOrConnectWithoutOrganizationInput = {
    where: AIFilterConfigWhereUniqueInput
    create: XOR<AIFilterConfigCreateWithoutOrganizationInput, AIFilterConfigUncheckedCreateWithoutOrganizationInput>
  }

  export type AIFilterConfigCreateManyOrganizationInputEnvelope = {
    data: AIFilterConfigCreateManyOrganizationInput | AIFilterConfigCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type ComparativeThemeCreateWithoutOrganizationInput = {
    id?: string
    themeName: string
    description?: string | null
    category?: string | null
    otPassages: JsonNullValueInput | InputJsonValue
    ntPassages: JsonNullValueInput | InputJsonValue
    themeNotes?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metrics?: ThemeMetricCreateNestedManyWithoutThemeInput
  }

  export type ComparativeThemeUncheckedCreateWithoutOrganizationInput = {
    id?: string
    themeName: string
    description?: string | null
    category?: string | null
    otPassages: JsonNullValueInput | InputJsonValue
    ntPassages: JsonNullValueInput | InputJsonValue
    themeNotes?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metrics?: ThemeMetricUncheckedCreateNestedManyWithoutThemeInput
  }

  export type ComparativeThemeCreateOrConnectWithoutOrganizationInput = {
    where: ComparativeThemeWhereUniqueInput
    create: XOR<ComparativeThemeCreateWithoutOrganizationInput, ComparativeThemeUncheckedCreateWithoutOrganizationInput>
  }

  export type ComparativeThemeCreateManyOrganizationInputEnvelope = {
    data: ComparativeThemeCreateManyOrganizationInput | ComparativeThemeCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutOrganizationInput, UserUncheckedUpdateWithoutOrganizationInput>
    create: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput>
  }

  export type UserUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutOrganizationInput, UserUncheckedUpdateWithoutOrganizationInput>
  }

  export type UserUpdateManyWithWhereWithoutOrganizationInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    organizationId?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    externalId?: StringNullableFilter<"User"> | string | null
    externalData?: JsonNullableFilter<"User">
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type GroupUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: GroupWhereUniqueInput
    update: XOR<GroupUpdateWithoutOrganizationInput, GroupUncheckedUpdateWithoutOrganizationInput>
    create: XOR<GroupCreateWithoutOrganizationInput, GroupUncheckedCreateWithoutOrganizationInput>
  }

  export type GroupUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: GroupWhereUniqueInput
    data: XOR<GroupUpdateWithoutOrganizationInput, GroupUncheckedUpdateWithoutOrganizationInput>
  }

  export type GroupUpdateManyWithWhereWithoutOrganizationInput = {
    where: GroupScalarWhereInput
    data: XOR<GroupUpdateManyMutationInput, GroupUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type GroupScalarWhereInput = {
    AND?: GroupScalarWhereInput | GroupScalarWhereInput[]
    OR?: GroupScalarWhereInput[]
    NOT?: GroupScalarWhereInput | GroupScalarWhereInput[]
    id?: StringFilter<"Group"> | string
    name?: StringFilter<"Group"> | string
    description?: StringNullableFilter<"Group"> | string | null
    organizationId?: StringFilter<"Group"> | string
    externalId?: StringNullableFilter<"Group"> | string | null
    externalData?: JsonNullableFilter<"Group">
    ageMin?: IntNullableFilter<"Group"> | number | null
    ageMax?: IntNullableFilter<"Group"> | number | null
    grade?: StringNullableFilter<"Group"> | string | null
    isActive?: BoolFilter<"Group"> | boolean
    createdAt?: DateTimeFilter<"Group"> | Date | string
    updatedAt?: DateTimeFilter<"Group"> | Date | string
  }

  export type ExternalIntegrationUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: ExternalIntegrationWhereUniqueInput
    update: XOR<ExternalIntegrationUpdateWithoutOrganizationInput, ExternalIntegrationUncheckedUpdateWithoutOrganizationInput>
    create: XOR<ExternalIntegrationCreateWithoutOrganizationInput, ExternalIntegrationUncheckedCreateWithoutOrganizationInput>
  }

  export type ExternalIntegrationUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: ExternalIntegrationWhereUniqueInput
    data: XOR<ExternalIntegrationUpdateWithoutOrganizationInput, ExternalIntegrationUncheckedUpdateWithoutOrganizationInput>
  }

  export type ExternalIntegrationUpdateManyWithWhereWithoutOrganizationInput = {
    where: ExternalIntegrationScalarWhereInput
    data: XOR<ExternalIntegrationUpdateManyMutationInput, ExternalIntegrationUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type ExternalIntegrationScalarWhereInput = {
    AND?: ExternalIntegrationScalarWhereInput | ExternalIntegrationScalarWhereInput[]
    OR?: ExternalIntegrationScalarWhereInput[]
    NOT?: ExternalIntegrationScalarWhereInput | ExternalIntegrationScalarWhereInput[]
    id?: StringFilter<"ExternalIntegration"> | string
    organizationId?: StringFilter<"ExternalIntegration"> | string
    provider?: EnumIntegrationProviderFilter<"ExternalIntegration"> | $Enums.IntegrationProvider
    status?: EnumIntegrationStatusFilter<"ExternalIntegration"> | $Enums.IntegrationStatus
    credentialsEncrypted?: StringFilter<"ExternalIntegration"> | string
    credentialsIV?: StringFilter<"ExternalIntegration"> | string
    credentialsTag?: StringFilter<"ExternalIntegration"> | string
    accessToken?: StringNullableFilter<"ExternalIntegration"> | string | null
    refreshToken?: StringNullableFilter<"ExternalIntegration"> | string | null
    tokenExpiresAt?: DateTimeNullableFilter<"ExternalIntegration"> | Date | string | null
    apiBaseUrl?: StringNullableFilter<"ExternalIntegration"> | string | null
    apiVersion?: StringNullableFilter<"ExternalIntegration"> | string | null
    syncEnabled?: BoolFilter<"ExternalIntegration"> | boolean
    syncFrequency?: EnumSyncFrequencyFilter<"ExternalIntegration"> | $Enums.SyncFrequency
    lastSyncAt?: DateTimeNullableFilter<"ExternalIntegration"> | Date | string | null
    lastSyncStatus?: EnumSyncStatusNullableFilter<"ExternalIntegration"> | $Enums.SyncStatus | null
    nextSyncAt?: DateTimeNullableFilter<"ExternalIntegration"> | Date | string | null
    createdAt?: DateTimeFilter<"ExternalIntegration"> | Date | string
    updatedAt?: DateTimeFilter<"ExternalIntegration"> | Date | string
  }

  export type LessonUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: LessonWhereUniqueInput
    update: XOR<LessonUpdateWithoutOrganizationInput, LessonUncheckedUpdateWithoutOrganizationInput>
    create: XOR<LessonCreateWithoutOrganizationInput, LessonUncheckedCreateWithoutOrganizationInput>
  }

  export type LessonUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: LessonWhereUniqueInput
    data: XOR<LessonUpdateWithoutOrganizationInput, LessonUncheckedUpdateWithoutOrganizationInput>
  }

  export type LessonUpdateManyWithWhereWithoutOrganizationInput = {
    where: LessonScalarWhereInput
    data: XOR<LessonUpdateManyMutationInput, LessonUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type LessonScalarWhereInput = {
    AND?: LessonScalarWhereInput | LessonScalarWhereInput[]
    OR?: LessonScalarWhereInput[]
    NOT?: LessonScalarWhereInput | LessonScalarWhereInput[]
    id?: StringFilter<"Lesson"> | string
    organizationId?: StringFilter<"Lesson"> | string
    title?: StringFilter<"Lesson"> | string
    quarter?: IntFilter<"Lesson"> | number
    unit?: IntFilter<"Lesson"> | number
    lessonNumber?: IntFilter<"Lesson"> | number
    scripture?: StringFilter<"Lesson"> | string
    content?: JsonFilter<"Lesson">
    slides?: JsonNullableFilter<"Lesson">
    games?: JsonNullableFilter<"Lesson">
    isPublic?: BoolFilter<"Lesson"> | boolean
    isTemplate?: BoolFilter<"Lesson"> | boolean
    createdBy?: StringNullableFilter<"Lesson"> | string | null
    createdAt?: DateTimeFilter<"Lesson"> | Date | string
    updatedAt?: DateTimeFilter<"Lesson"> | Date | string
  }

  export type AIFilterConfigUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: AIFilterConfigWhereUniqueInput
    update: XOR<AIFilterConfigUpdateWithoutOrganizationInput, AIFilterConfigUncheckedUpdateWithoutOrganizationInput>
    create: XOR<AIFilterConfigCreateWithoutOrganizationInput, AIFilterConfigUncheckedCreateWithoutOrganizationInput>
  }

  export type AIFilterConfigUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: AIFilterConfigWhereUniqueInput
    data: XOR<AIFilterConfigUpdateWithoutOrganizationInput, AIFilterConfigUncheckedUpdateWithoutOrganizationInput>
  }

  export type AIFilterConfigUpdateManyWithWhereWithoutOrganizationInput = {
    where: AIFilterConfigScalarWhereInput
    data: XOR<AIFilterConfigUpdateManyMutationInput, AIFilterConfigUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type AIFilterConfigScalarWhereInput = {
    AND?: AIFilterConfigScalarWhereInput | AIFilterConfigScalarWhereInput[]
    OR?: AIFilterConfigScalarWhereInput[]
    NOT?: AIFilterConfigScalarWhereInput | AIFilterConfigScalarWhereInput[]
    id?: StringFilter<"AIFilterConfig"> | string
    organizationId?: StringNullableFilter<"AIFilterConfig"> | string | null
    filterRules?: JsonFilter<"AIFilterConfig">
    customKeywords?: JsonNullableFilter<"AIFilterConfig">
    redirectMessage?: StringNullableFilter<"AIFilterConfig"> | string | null
    isActive?: BoolFilter<"AIFilterConfig"> | boolean
    createdAt?: DateTimeFilter<"AIFilterConfig"> | Date | string
    updatedAt?: DateTimeFilter<"AIFilterConfig"> | Date | string
  }

  export type ComparativeThemeUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: ComparativeThemeWhereUniqueInput
    update: XOR<ComparativeThemeUpdateWithoutOrganizationInput, ComparativeThemeUncheckedUpdateWithoutOrganizationInput>
    create: XOR<ComparativeThemeCreateWithoutOrganizationInput, ComparativeThemeUncheckedCreateWithoutOrganizationInput>
  }

  export type ComparativeThemeUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: ComparativeThemeWhereUniqueInput
    data: XOR<ComparativeThemeUpdateWithoutOrganizationInput, ComparativeThemeUncheckedUpdateWithoutOrganizationInput>
  }

  export type ComparativeThemeUpdateManyWithWhereWithoutOrganizationInput = {
    where: ComparativeThemeScalarWhereInput
    data: XOR<ComparativeThemeUpdateManyMutationInput, ComparativeThemeUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type ComparativeThemeScalarWhereInput = {
    AND?: ComparativeThemeScalarWhereInput | ComparativeThemeScalarWhereInput[]
    OR?: ComparativeThemeScalarWhereInput[]
    NOT?: ComparativeThemeScalarWhereInput | ComparativeThemeScalarWhereInput[]
    id?: StringFilter<"ComparativeTheme"> | string
    organizationId?: StringFilter<"ComparativeTheme"> | string
    themeName?: StringFilter<"ComparativeTheme"> | string
    description?: StringNullableFilter<"ComparativeTheme"> | string | null
    category?: StringNullableFilter<"ComparativeTheme"> | string | null
    otPassages?: JsonFilter<"ComparativeTheme">
    ntPassages?: JsonFilter<"ComparativeTheme">
    themeNotes?: JsonNullableFilter<"ComparativeTheme">
    isPublic?: BoolFilter<"ComparativeTheme"> | boolean
    createdBy?: StringNullableFilter<"ComparativeTheme"> | string | null
    createdAt?: DateTimeFilter<"ComparativeTheme"> | Date | string
    updatedAt?: DateTimeFilter<"ComparativeTheme"> | Date | string
  }

  export type OrganizationCreateWithoutUsersInput = {
    id?: string
    name: string
    slug: string
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    groups?: GroupCreateNestedManyWithoutOrganizationInput
    integrations?: ExternalIntegrationCreateNestedManyWithoutOrganizationInput
    lessons?: LessonCreateNestedManyWithoutOrganizationInput
    aiFilterConfigs?: AIFilterConfigCreateNestedManyWithoutOrganizationInput
    comparativeThemes?: ComparativeThemeCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    slug: string
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    groups?: GroupUncheckedCreateNestedManyWithoutOrganizationInput
    integrations?: ExternalIntegrationUncheckedCreateNestedManyWithoutOrganizationInput
    lessons?: LessonUncheckedCreateNestedManyWithoutOrganizationInput
    aiFilterConfigs?: AIFilterConfigUncheckedCreateNestedManyWithoutOrganizationInput
    comparativeThemes?: ComparativeThemeUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutUsersInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>
  }

  export type GroupMemberCreateWithoutUserInput = {
    id?: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    group: GroupCreateNestedOneWithoutMembersInput
  }

  export type GroupMemberUncheckedCreateWithoutUserInput = {
    id?: string
    groupId: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupMemberCreateOrConnectWithoutUserInput = {
    where: GroupMemberWhereUniqueInput
    create: XOR<GroupMemberCreateWithoutUserInput, GroupMemberUncheckedCreateWithoutUserInput>
  }

  export type GroupMemberCreateManyUserInputEnvelope = {
    data: GroupMemberCreateManyUserInput | GroupMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RefreshTokenCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type RefreshTokenUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type RefreshTokenCreateOrConnectWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenCreateManyUserInputEnvelope = {
    data: RefreshTokenCreateManyUserInput | RefreshTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationPreferenceCreateWithoutUserInput = {
    id?: string
    emailEnabled?: boolean
    emailLessonReminders?: boolean
    emailEventReminders?: boolean
    emailAnnouncements?: boolean
    emailGroupUpdates?: boolean
    emailDigest?: boolean
    emailDigestFrequency?: $Enums.DigestFrequency
    inAppEnabled?: boolean
    inAppLessonReminders?: boolean
    inAppEventReminders?: boolean
    inAppAnnouncements?: boolean
    inAppGroupUpdates?: boolean
    quietHoursEnabled?: boolean
    quietHoursStart?: string | null
    quietHoursEnd?: string | null
    quietHoursTimezone?: string
    preferredDays?: NullableJsonNullValueInput | InputJsonValue
    lessonReminderDays?: number
    lessonReminderTime?: string
    eventReminderHours?: number
    batchNotifications?: boolean
    maxNotificationsPerDay?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPreferenceUncheckedCreateWithoutUserInput = {
    id?: string
    emailEnabled?: boolean
    emailLessonReminders?: boolean
    emailEventReminders?: boolean
    emailAnnouncements?: boolean
    emailGroupUpdates?: boolean
    emailDigest?: boolean
    emailDigestFrequency?: $Enums.DigestFrequency
    inAppEnabled?: boolean
    inAppLessonReminders?: boolean
    inAppEventReminders?: boolean
    inAppAnnouncements?: boolean
    inAppGroupUpdates?: boolean
    quietHoursEnabled?: boolean
    quietHoursStart?: string | null
    quietHoursEnd?: string | null
    quietHoursTimezone?: string
    preferredDays?: NullableJsonNullValueInput | InputJsonValue
    lessonReminderDays?: number
    lessonReminderTime?: string
    eventReminderHours?: number
    batchNotifications?: boolean
    maxNotificationsPerDay?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationPreferenceCreateOrConnectWithoutUserInput = {
    where: NotificationPreferenceWhereUniqueInput
    create: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    organizationId: string
    type: $Enums.NotificationType
    title: string
    message: string
    actionUrl?: string | null
    deliveryMethod?: $Enums.NotificationDeliveryMethod
    priority?: $Enums.NotificationPriority
    scheduledFor?: Date | string | null
    sentAt?: Date | string | null
    readAt?: Date | string | null
    status?: $Enums.NotificationStatus
    deliveryStatus?: NullableJsonNullValueInput | InputJsonValue
    failureReason?: string | null
    retryCount?: number
    maxRetries?: number
    groupId?: string | null
    lessonId?: string | null
    eventId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    organizationId: string
    type: $Enums.NotificationType
    title: string
    message: string
    actionUrl?: string | null
    deliveryMethod?: $Enums.NotificationDeliveryMethod
    priority?: $Enums.NotificationPriority
    scheduledFor?: Date | string | null
    sentAt?: Date | string | null
    readAt?: Date | string | null
    status?: $Enums.NotificationStatus
    deliveryStatus?: NullableJsonNullValueInput | InputJsonValue
    failureReason?: string | null
    retryCount?: number
    maxRetries?: number
    groupId?: string | null
    lessonId?: string | null
    eventId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutUsersInput = {
    update: XOR<OrganizationUpdateWithoutUsersInput, OrganizationUncheckedUpdateWithoutUsersInput>
    create: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutUsersInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutUsersInput, OrganizationUncheckedUpdateWithoutUsersInput>
  }

  export type OrganizationUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groups?: GroupUpdateManyWithoutOrganizationNestedInput
    integrations?: ExternalIntegrationUpdateManyWithoutOrganizationNestedInput
    lessons?: LessonUpdateManyWithoutOrganizationNestedInput
    aiFilterConfigs?: AIFilterConfigUpdateManyWithoutOrganizationNestedInput
    comparativeThemes?: ComparativeThemeUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groups?: GroupUncheckedUpdateManyWithoutOrganizationNestedInput
    integrations?: ExternalIntegrationUncheckedUpdateManyWithoutOrganizationNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutOrganizationNestedInput
    aiFilterConfigs?: AIFilterConfigUncheckedUpdateManyWithoutOrganizationNestedInput
    comparativeThemes?: ComparativeThemeUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type GroupMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: GroupMemberWhereUniqueInput
    update: XOR<GroupMemberUpdateWithoutUserInput, GroupMemberUncheckedUpdateWithoutUserInput>
    create: XOR<GroupMemberCreateWithoutUserInput, GroupMemberUncheckedCreateWithoutUserInput>
  }

  export type GroupMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: GroupMemberWhereUniqueInput
    data: XOR<GroupMemberUpdateWithoutUserInput, GroupMemberUncheckedUpdateWithoutUserInput>
  }

  export type GroupMemberUpdateManyWithWhereWithoutUserInput = {
    where: GroupMemberScalarWhereInput
    data: XOR<GroupMemberUpdateManyMutationInput, GroupMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type GroupMemberScalarWhereInput = {
    AND?: GroupMemberScalarWhereInput | GroupMemberScalarWhereInput[]
    OR?: GroupMemberScalarWhereInput[]
    NOT?: GroupMemberScalarWhereInput | GroupMemberScalarWhereInput[]
    id?: StringFilter<"GroupMember"> | string
    userId?: StringFilter<"GroupMember"> | string
    groupId?: StringFilter<"GroupMember"> | string
    role?: StringFilter<"GroupMember"> | string
    createdAt?: DateTimeFilter<"GroupMember"> | Date | string
    updatedAt?: DateTimeFilter<"GroupMember"> | Date | string
  }

  export type RefreshTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    update: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    data: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
  }

  export type RefreshTokenUpdateManyWithWhereWithoutUserInput = {
    where: RefreshTokenScalarWhereInput
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type RefreshTokenScalarWhereInput = {
    AND?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    OR?: RefreshTokenScalarWhereInput[]
    NOT?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    userId?: StringFilter<"RefreshToken"> | string
    token?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
  }

  export type NotificationPreferenceUpsertWithoutUserInput = {
    update: XOR<NotificationPreferenceUpdateWithoutUserInput, NotificationPreferenceUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
    where?: NotificationPreferenceWhereInput
  }

  export type NotificationPreferenceUpdateToOneWithWhereWithoutUserInput = {
    where?: NotificationPreferenceWhereInput
    data: XOR<NotificationPreferenceUpdateWithoutUserInput, NotificationPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type NotificationPreferenceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    emailLessonReminders?: BoolFieldUpdateOperationsInput | boolean
    emailEventReminders?: BoolFieldUpdateOperationsInput | boolean
    emailAnnouncements?: BoolFieldUpdateOperationsInput | boolean
    emailGroupUpdates?: BoolFieldUpdateOperationsInput | boolean
    emailDigest?: BoolFieldUpdateOperationsInput | boolean
    emailDigestFrequency?: EnumDigestFrequencyFieldUpdateOperationsInput | $Enums.DigestFrequency
    inAppEnabled?: BoolFieldUpdateOperationsInput | boolean
    inAppLessonReminders?: BoolFieldUpdateOperationsInput | boolean
    inAppEventReminders?: BoolFieldUpdateOperationsInput | boolean
    inAppAnnouncements?: BoolFieldUpdateOperationsInput | boolean
    inAppGroupUpdates?: BoolFieldUpdateOperationsInput | boolean
    quietHoursEnabled?: BoolFieldUpdateOperationsInput | boolean
    quietHoursStart?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursEnd?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursTimezone?: StringFieldUpdateOperationsInput | string
    preferredDays?: NullableJsonNullValueInput | InputJsonValue
    lessonReminderDays?: IntFieldUpdateOperationsInput | number
    lessonReminderTime?: StringFieldUpdateOperationsInput | string
    eventReminderHours?: IntFieldUpdateOperationsInput | number
    batchNotifications?: BoolFieldUpdateOperationsInput | boolean
    maxNotificationsPerDay?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    emailLessonReminders?: BoolFieldUpdateOperationsInput | boolean
    emailEventReminders?: BoolFieldUpdateOperationsInput | boolean
    emailAnnouncements?: BoolFieldUpdateOperationsInput | boolean
    emailGroupUpdates?: BoolFieldUpdateOperationsInput | boolean
    emailDigest?: BoolFieldUpdateOperationsInput | boolean
    emailDigestFrequency?: EnumDigestFrequencyFieldUpdateOperationsInput | $Enums.DigestFrequency
    inAppEnabled?: BoolFieldUpdateOperationsInput | boolean
    inAppLessonReminders?: BoolFieldUpdateOperationsInput | boolean
    inAppEventReminders?: BoolFieldUpdateOperationsInput | boolean
    inAppAnnouncements?: BoolFieldUpdateOperationsInput | boolean
    inAppGroupUpdates?: BoolFieldUpdateOperationsInput | boolean
    quietHoursEnabled?: BoolFieldUpdateOperationsInput | boolean
    quietHoursStart?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursEnd?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursTimezone?: StringFieldUpdateOperationsInput | string
    preferredDays?: NullableJsonNullValueInput | InputJsonValue
    lessonReminderDays?: IntFieldUpdateOperationsInput | number
    lessonReminderTime?: StringFieldUpdateOperationsInput | string
    eventReminderHours?: IntFieldUpdateOperationsInput | number
    batchNotifications?: BoolFieldUpdateOperationsInput | boolean
    maxNotificationsPerDay?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    organizationId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    actionUrl?: StringNullableFilter<"Notification"> | string | null
    deliveryMethod?: EnumNotificationDeliveryMethodFilter<"Notification"> | $Enums.NotificationDeliveryMethod
    priority?: EnumNotificationPriorityFilter<"Notification"> | $Enums.NotificationPriority
    scheduledFor?: DateTimeNullableFilter<"Notification"> | Date | string | null
    sentAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    status?: EnumNotificationStatusFilter<"Notification"> | $Enums.NotificationStatus
    deliveryStatus?: JsonNullableFilter<"Notification">
    failureReason?: StringNullableFilter<"Notification"> | string | null
    retryCount?: IntFilter<"Notification"> | number
    maxRetries?: IntFilter<"Notification"> | number
    groupId?: StringNullableFilter<"Notification"> | string | null
    lessonId?: StringNullableFilter<"Notification"> | string | null
    eventId?: StringNullableFilter<"Notification"> | string | null
    metadata?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type UserCreateWithoutRefreshTokensInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.Role
    isActive?: boolean
    externalId?: string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutUsersInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRefreshTokensInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.Role
    organizationId: string
    isActive?: boolean
    externalId?: string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRefreshTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
  }

  export type UserUpsertWithoutRefreshTokensInput = {
    update: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRefreshTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type UserUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutUsersNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    organizationId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrganizationCreateWithoutGroupsInput = {
    id?: string
    name: string
    slug: string
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutOrganizationInput
    integrations?: ExternalIntegrationCreateNestedManyWithoutOrganizationInput
    lessons?: LessonCreateNestedManyWithoutOrganizationInput
    aiFilterConfigs?: AIFilterConfigCreateNestedManyWithoutOrganizationInput
    comparativeThemes?: ComparativeThemeCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutGroupsInput = {
    id?: string
    name: string
    slug: string
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    integrations?: ExternalIntegrationUncheckedCreateNestedManyWithoutOrganizationInput
    lessons?: LessonUncheckedCreateNestedManyWithoutOrganizationInput
    aiFilterConfigs?: AIFilterConfigUncheckedCreateNestedManyWithoutOrganizationInput
    comparativeThemes?: ComparativeThemeUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutGroupsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutGroupsInput, OrganizationUncheckedCreateWithoutGroupsInput>
  }

  export type GroupMemberCreateWithoutGroupInput = {
    id?: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutGroupMembershipsInput
  }

  export type GroupMemberUncheckedCreateWithoutGroupInput = {
    id?: string
    userId: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupMemberCreateOrConnectWithoutGroupInput = {
    where: GroupMemberWhereUniqueInput
    create: XOR<GroupMemberCreateWithoutGroupInput, GroupMemberUncheckedCreateWithoutGroupInput>
  }

  export type GroupMemberCreateManyGroupInputEnvelope = {
    data: GroupMemberCreateManyGroupInput | GroupMemberCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type ExternalGroupMappingCreateWithoutGroupInput = {
    id?: string
    externalGroupId: string
    externalGroupName: string
    externalGroupType?: string | null
    syncMembers?: boolean
    syncLeaders?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    integration: ExternalIntegrationCreateNestedOneWithoutGroupMappingsInput
  }

  export type ExternalGroupMappingUncheckedCreateWithoutGroupInput = {
    id?: string
    integrationId: string
    externalGroupId: string
    externalGroupName: string
    externalGroupType?: string | null
    syncMembers?: boolean
    syncLeaders?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExternalGroupMappingCreateOrConnectWithoutGroupInput = {
    where: ExternalGroupMappingWhereUniqueInput
    create: XOR<ExternalGroupMappingCreateWithoutGroupInput, ExternalGroupMappingUncheckedCreateWithoutGroupInput>
  }

  export type ExternalGroupMappingCreateManyGroupInputEnvelope = {
    data: ExternalGroupMappingCreateManyGroupInput | ExternalGroupMappingCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type LessonGroupCreateWithoutGroupInput = {
    id?: string
    createdAt?: Date | string
    lesson: LessonCreateNestedOneWithoutGroupsInput
  }

  export type LessonGroupUncheckedCreateWithoutGroupInput = {
    id?: string
    lessonId: string
    createdAt?: Date | string
  }

  export type LessonGroupCreateOrConnectWithoutGroupInput = {
    where: LessonGroupWhereUniqueInput
    create: XOR<LessonGroupCreateWithoutGroupInput, LessonGroupUncheckedCreateWithoutGroupInput>
  }

  export type LessonGroupCreateManyGroupInputEnvelope = {
    data: LessonGroupCreateManyGroupInput | LessonGroupCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutGroupsInput = {
    update: XOR<OrganizationUpdateWithoutGroupsInput, OrganizationUncheckedUpdateWithoutGroupsInput>
    create: XOR<OrganizationCreateWithoutGroupsInput, OrganizationUncheckedCreateWithoutGroupsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutGroupsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutGroupsInput, OrganizationUncheckedUpdateWithoutGroupsInput>
  }

  export type OrganizationUpdateWithoutGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutOrganizationNestedInput
    integrations?: ExternalIntegrationUpdateManyWithoutOrganizationNestedInput
    lessons?: LessonUpdateManyWithoutOrganizationNestedInput
    aiFilterConfigs?: AIFilterConfigUpdateManyWithoutOrganizationNestedInput
    comparativeThemes?: ComparativeThemeUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    integrations?: ExternalIntegrationUncheckedUpdateManyWithoutOrganizationNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutOrganizationNestedInput
    aiFilterConfigs?: AIFilterConfigUncheckedUpdateManyWithoutOrganizationNestedInput
    comparativeThemes?: ComparativeThemeUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type GroupMemberUpsertWithWhereUniqueWithoutGroupInput = {
    where: GroupMemberWhereUniqueInput
    update: XOR<GroupMemberUpdateWithoutGroupInput, GroupMemberUncheckedUpdateWithoutGroupInput>
    create: XOR<GroupMemberCreateWithoutGroupInput, GroupMemberUncheckedCreateWithoutGroupInput>
  }

  export type GroupMemberUpdateWithWhereUniqueWithoutGroupInput = {
    where: GroupMemberWhereUniqueInput
    data: XOR<GroupMemberUpdateWithoutGroupInput, GroupMemberUncheckedUpdateWithoutGroupInput>
  }

  export type GroupMemberUpdateManyWithWhereWithoutGroupInput = {
    where: GroupMemberScalarWhereInput
    data: XOR<GroupMemberUpdateManyMutationInput, GroupMemberUncheckedUpdateManyWithoutGroupInput>
  }

  export type ExternalGroupMappingUpsertWithWhereUniqueWithoutGroupInput = {
    where: ExternalGroupMappingWhereUniqueInput
    update: XOR<ExternalGroupMappingUpdateWithoutGroupInput, ExternalGroupMappingUncheckedUpdateWithoutGroupInput>
    create: XOR<ExternalGroupMappingCreateWithoutGroupInput, ExternalGroupMappingUncheckedCreateWithoutGroupInput>
  }

  export type ExternalGroupMappingUpdateWithWhereUniqueWithoutGroupInput = {
    where: ExternalGroupMappingWhereUniqueInput
    data: XOR<ExternalGroupMappingUpdateWithoutGroupInput, ExternalGroupMappingUncheckedUpdateWithoutGroupInput>
  }

  export type ExternalGroupMappingUpdateManyWithWhereWithoutGroupInput = {
    where: ExternalGroupMappingScalarWhereInput
    data: XOR<ExternalGroupMappingUpdateManyMutationInput, ExternalGroupMappingUncheckedUpdateManyWithoutGroupInput>
  }

  export type ExternalGroupMappingScalarWhereInput = {
    AND?: ExternalGroupMappingScalarWhereInput | ExternalGroupMappingScalarWhereInput[]
    OR?: ExternalGroupMappingScalarWhereInput[]
    NOT?: ExternalGroupMappingScalarWhereInput | ExternalGroupMappingScalarWhereInput[]
    id?: StringFilter<"ExternalGroupMapping"> | string
    integrationId?: StringFilter<"ExternalGroupMapping"> | string
    externalGroupId?: StringFilter<"ExternalGroupMapping"> | string
    externalGroupName?: StringFilter<"ExternalGroupMapping"> | string
    externalGroupType?: StringNullableFilter<"ExternalGroupMapping"> | string | null
    groupId?: StringNullableFilter<"ExternalGroupMapping"> | string | null
    syncMembers?: BoolFilter<"ExternalGroupMapping"> | boolean
    syncLeaders?: BoolFilter<"ExternalGroupMapping"> | boolean
    createdAt?: DateTimeFilter<"ExternalGroupMapping"> | Date | string
    updatedAt?: DateTimeFilter<"ExternalGroupMapping"> | Date | string
  }

  export type LessonGroupUpsertWithWhereUniqueWithoutGroupInput = {
    where: LessonGroupWhereUniqueInput
    update: XOR<LessonGroupUpdateWithoutGroupInput, LessonGroupUncheckedUpdateWithoutGroupInput>
    create: XOR<LessonGroupCreateWithoutGroupInput, LessonGroupUncheckedCreateWithoutGroupInput>
  }

  export type LessonGroupUpdateWithWhereUniqueWithoutGroupInput = {
    where: LessonGroupWhereUniqueInput
    data: XOR<LessonGroupUpdateWithoutGroupInput, LessonGroupUncheckedUpdateWithoutGroupInput>
  }

  export type LessonGroupUpdateManyWithWhereWithoutGroupInput = {
    where: LessonGroupScalarWhereInput
    data: XOR<LessonGroupUpdateManyMutationInput, LessonGroupUncheckedUpdateManyWithoutGroupInput>
  }

  export type LessonGroupScalarWhereInput = {
    AND?: LessonGroupScalarWhereInput | LessonGroupScalarWhereInput[]
    OR?: LessonGroupScalarWhereInput[]
    NOT?: LessonGroupScalarWhereInput | LessonGroupScalarWhereInput[]
    id?: StringFilter<"LessonGroup"> | string
    lessonId?: StringFilter<"LessonGroup"> | string
    groupId?: StringFilter<"LessonGroup"> | string
    createdAt?: DateTimeFilter<"LessonGroup"> | Date | string
  }

  export type UserCreateWithoutGroupMembershipsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.Role
    isActive?: boolean
    externalId?: string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutUsersInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutGroupMembershipsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.Role
    organizationId: string
    isActive?: boolean
    externalId?: string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutGroupMembershipsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGroupMembershipsInput, UserUncheckedCreateWithoutGroupMembershipsInput>
  }

  export type GroupCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    externalId?: string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    ageMin?: number | null
    ageMax?: number | null
    grade?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutGroupsInput
    mappings?: ExternalGroupMappingCreateNestedManyWithoutGroupInput
    lessons?: LessonGroupCreateNestedManyWithoutGroupInput
  }

  export type GroupUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    organizationId: string
    externalId?: string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    ageMin?: number | null
    ageMax?: number | null
    grade?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mappings?: ExternalGroupMappingUncheckedCreateNestedManyWithoutGroupInput
    lessons?: LessonGroupUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupCreateOrConnectWithoutMembersInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutMembersInput, GroupUncheckedCreateWithoutMembersInput>
  }

  export type UserUpsertWithoutGroupMembershipsInput = {
    update: XOR<UserUpdateWithoutGroupMembershipsInput, UserUncheckedUpdateWithoutGroupMembershipsInput>
    create: XOR<UserCreateWithoutGroupMembershipsInput, UserUncheckedCreateWithoutGroupMembershipsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGroupMembershipsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGroupMembershipsInput, UserUncheckedUpdateWithoutGroupMembershipsInput>
  }

  export type UserUpdateWithoutGroupMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutUsersNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutGroupMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    organizationId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type GroupUpsertWithoutMembersInput = {
    update: XOR<GroupUpdateWithoutMembersInput, GroupUncheckedUpdateWithoutMembersInput>
    create: XOR<GroupCreateWithoutMembersInput, GroupUncheckedCreateWithoutMembersInput>
    where?: GroupWhereInput
  }

  export type GroupUpdateToOneWithWhereWithoutMembersInput = {
    where?: GroupWhereInput
    data: XOR<GroupUpdateWithoutMembersInput, GroupUncheckedUpdateWithoutMembersInput>
  }

  export type GroupUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    ageMin?: NullableIntFieldUpdateOperationsInput | number | null
    ageMax?: NullableIntFieldUpdateOperationsInput | number | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutGroupsNestedInput
    mappings?: ExternalGroupMappingUpdateManyWithoutGroupNestedInput
    lessons?: LessonGroupUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    ageMin?: NullableIntFieldUpdateOperationsInput | number | null
    ageMax?: NullableIntFieldUpdateOperationsInput | number | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mappings?: ExternalGroupMappingUncheckedUpdateManyWithoutGroupNestedInput
    lessons?: LessonGroupUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type OrganizationCreateWithoutIntegrationsInput = {
    id?: string
    name: string
    slug: string
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutOrganizationInput
    groups?: GroupCreateNestedManyWithoutOrganizationInput
    lessons?: LessonCreateNestedManyWithoutOrganizationInput
    aiFilterConfigs?: AIFilterConfigCreateNestedManyWithoutOrganizationInput
    comparativeThemes?: ComparativeThemeCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutIntegrationsInput = {
    id?: string
    name: string
    slug: string
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    groups?: GroupUncheckedCreateNestedManyWithoutOrganizationInput
    lessons?: LessonUncheckedCreateNestedManyWithoutOrganizationInput
    aiFilterConfigs?: AIFilterConfigUncheckedCreateNestedManyWithoutOrganizationInput
    comparativeThemes?: ComparativeThemeUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutIntegrationsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutIntegrationsInput, OrganizationUncheckedCreateWithoutIntegrationsInput>
  }

  export type ExternalGroupMappingCreateWithoutIntegrationInput = {
    id?: string
    externalGroupId: string
    externalGroupName: string
    externalGroupType?: string | null
    syncMembers?: boolean
    syncLeaders?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    group?: GroupCreateNestedOneWithoutMappingsInput
  }

  export type ExternalGroupMappingUncheckedCreateWithoutIntegrationInput = {
    id?: string
    externalGroupId: string
    externalGroupName: string
    externalGroupType?: string | null
    groupId?: string | null
    syncMembers?: boolean
    syncLeaders?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExternalGroupMappingCreateOrConnectWithoutIntegrationInput = {
    where: ExternalGroupMappingWhereUniqueInput
    create: XOR<ExternalGroupMappingCreateWithoutIntegrationInput, ExternalGroupMappingUncheckedCreateWithoutIntegrationInput>
  }

  export type ExternalGroupMappingCreateManyIntegrationInputEnvelope = {
    data: ExternalGroupMappingCreateManyIntegrationInput | ExternalGroupMappingCreateManyIntegrationInput[]
    skipDuplicates?: boolean
  }

  export type SyncLogCreateWithoutIntegrationInput = {
    id?: string
    status: $Enums.SyncStatus
    startedAt?: Date | string
    completedAt?: Date | string | null
    durationMs?: number | null
    peopleAdded?: number
    peopleUpdated?: number
    peopleRemoved?: number
    groupsAdded?: number
    groupsUpdated?: number
    groupsSkipped?: number
    errorMessage?: string | null
    errorCode?: string | null
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SyncLogUncheckedCreateWithoutIntegrationInput = {
    id?: string
    status: $Enums.SyncStatus
    startedAt?: Date | string
    completedAt?: Date | string | null
    durationMs?: number | null
    peopleAdded?: number
    peopleUpdated?: number
    peopleRemoved?: number
    groupsAdded?: number
    groupsUpdated?: number
    groupsSkipped?: number
    errorMessage?: string | null
    errorCode?: string | null
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SyncLogCreateOrConnectWithoutIntegrationInput = {
    where: SyncLogWhereUniqueInput
    create: XOR<SyncLogCreateWithoutIntegrationInput, SyncLogUncheckedCreateWithoutIntegrationInput>
  }

  export type SyncLogCreateManyIntegrationInputEnvelope = {
    data: SyncLogCreateManyIntegrationInput | SyncLogCreateManyIntegrationInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutIntegrationsInput = {
    update: XOR<OrganizationUpdateWithoutIntegrationsInput, OrganizationUncheckedUpdateWithoutIntegrationsInput>
    create: XOR<OrganizationCreateWithoutIntegrationsInput, OrganizationUncheckedCreateWithoutIntegrationsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutIntegrationsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutIntegrationsInput, OrganizationUncheckedUpdateWithoutIntegrationsInput>
  }

  export type OrganizationUpdateWithoutIntegrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutOrganizationNestedInput
    groups?: GroupUpdateManyWithoutOrganizationNestedInput
    lessons?: LessonUpdateManyWithoutOrganizationNestedInput
    aiFilterConfigs?: AIFilterConfigUpdateManyWithoutOrganizationNestedInput
    comparativeThemes?: ComparativeThemeUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutIntegrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    groups?: GroupUncheckedUpdateManyWithoutOrganizationNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutOrganizationNestedInput
    aiFilterConfigs?: AIFilterConfigUncheckedUpdateManyWithoutOrganizationNestedInput
    comparativeThemes?: ComparativeThemeUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type ExternalGroupMappingUpsertWithWhereUniqueWithoutIntegrationInput = {
    where: ExternalGroupMappingWhereUniqueInput
    update: XOR<ExternalGroupMappingUpdateWithoutIntegrationInput, ExternalGroupMappingUncheckedUpdateWithoutIntegrationInput>
    create: XOR<ExternalGroupMappingCreateWithoutIntegrationInput, ExternalGroupMappingUncheckedCreateWithoutIntegrationInput>
  }

  export type ExternalGroupMappingUpdateWithWhereUniqueWithoutIntegrationInput = {
    where: ExternalGroupMappingWhereUniqueInput
    data: XOR<ExternalGroupMappingUpdateWithoutIntegrationInput, ExternalGroupMappingUncheckedUpdateWithoutIntegrationInput>
  }

  export type ExternalGroupMappingUpdateManyWithWhereWithoutIntegrationInput = {
    where: ExternalGroupMappingScalarWhereInput
    data: XOR<ExternalGroupMappingUpdateManyMutationInput, ExternalGroupMappingUncheckedUpdateManyWithoutIntegrationInput>
  }

  export type SyncLogUpsertWithWhereUniqueWithoutIntegrationInput = {
    where: SyncLogWhereUniqueInput
    update: XOR<SyncLogUpdateWithoutIntegrationInput, SyncLogUncheckedUpdateWithoutIntegrationInput>
    create: XOR<SyncLogCreateWithoutIntegrationInput, SyncLogUncheckedCreateWithoutIntegrationInput>
  }

  export type SyncLogUpdateWithWhereUniqueWithoutIntegrationInput = {
    where: SyncLogWhereUniqueInput
    data: XOR<SyncLogUpdateWithoutIntegrationInput, SyncLogUncheckedUpdateWithoutIntegrationInput>
  }

  export type SyncLogUpdateManyWithWhereWithoutIntegrationInput = {
    where: SyncLogScalarWhereInput
    data: XOR<SyncLogUpdateManyMutationInput, SyncLogUncheckedUpdateManyWithoutIntegrationInput>
  }

  export type SyncLogScalarWhereInput = {
    AND?: SyncLogScalarWhereInput | SyncLogScalarWhereInput[]
    OR?: SyncLogScalarWhereInput[]
    NOT?: SyncLogScalarWhereInput | SyncLogScalarWhereInput[]
    id?: StringFilter<"SyncLog"> | string
    integrationId?: StringFilter<"SyncLog"> | string
    status?: EnumSyncStatusFilter<"SyncLog"> | $Enums.SyncStatus
    startedAt?: DateTimeFilter<"SyncLog"> | Date | string
    completedAt?: DateTimeNullableFilter<"SyncLog"> | Date | string | null
    durationMs?: IntNullableFilter<"SyncLog"> | number | null
    peopleAdded?: IntFilter<"SyncLog"> | number
    peopleUpdated?: IntFilter<"SyncLog"> | number
    peopleRemoved?: IntFilter<"SyncLog"> | number
    groupsAdded?: IntFilter<"SyncLog"> | number
    groupsUpdated?: IntFilter<"SyncLog"> | number
    groupsSkipped?: IntFilter<"SyncLog"> | number
    errorMessage?: StringNullableFilter<"SyncLog"> | string | null
    errorCode?: StringNullableFilter<"SyncLog"> | string | null
    errorDetails?: JsonNullableFilter<"SyncLog">
    metadata?: JsonNullableFilter<"SyncLog">
  }

  export type ExternalIntegrationCreateWithoutGroupMappingsInput = {
    id?: string
    provider: $Enums.IntegrationProvider
    status?: $Enums.IntegrationStatus
    credentialsEncrypted: string
    credentialsIV: string
    credentialsTag: string
    accessToken?: string | null
    refreshToken?: string | null
    tokenExpiresAt?: Date | string | null
    apiBaseUrl?: string | null
    apiVersion?: string | null
    syncEnabled?: boolean
    syncFrequency?: $Enums.SyncFrequency
    lastSyncAt?: Date | string | null
    lastSyncStatus?: $Enums.SyncStatus | null
    nextSyncAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutIntegrationsInput
    syncLogs?: SyncLogCreateNestedManyWithoutIntegrationInput
  }

  export type ExternalIntegrationUncheckedCreateWithoutGroupMappingsInput = {
    id?: string
    organizationId: string
    provider: $Enums.IntegrationProvider
    status?: $Enums.IntegrationStatus
    credentialsEncrypted: string
    credentialsIV: string
    credentialsTag: string
    accessToken?: string | null
    refreshToken?: string | null
    tokenExpiresAt?: Date | string | null
    apiBaseUrl?: string | null
    apiVersion?: string | null
    syncEnabled?: boolean
    syncFrequency?: $Enums.SyncFrequency
    lastSyncAt?: Date | string | null
    lastSyncStatus?: $Enums.SyncStatus | null
    nextSyncAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncLogs?: SyncLogUncheckedCreateNestedManyWithoutIntegrationInput
  }

  export type ExternalIntegrationCreateOrConnectWithoutGroupMappingsInput = {
    where: ExternalIntegrationWhereUniqueInput
    create: XOR<ExternalIntegrationCreateWithoutGroupMappingsInput, ExternalIntegrationUncheckedCreateWithoutGroupMappingsInput>
  }

  export type GroupCreateWithoutMappingsInput = {
    id?: string
    name: string
    description?: string | null
    externalId?: string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    ageMin?: number | null
    ageMax?: number | null
    grade?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutGroupsInput
    members?: GroupMemberCreateNestedManyWithoutGroupInput
    lessons?: LessonGroupCreateNestedManyWithoutGroupInput
  }

  export type GroupUncheckedCreateWithoutMappingsInput = {
    id?: string
    name: string
    description?: string | null
    organizationId: string
    externalId?: string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    ageMin?: number | null
    ageMax?: number | null
    grade?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: GroupMemberUncheckedCreateNestedManyWithoutGroupInput
    lessons?: LessonGroupUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupCreateOrConnectWithoutMappingsInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutMappingsInput, GroupUncheckedCreateWithoutMappingsInput>
  }

  export type ExternalIntegrationUpsertWithoutGroupMappingsInput = {
    update: XOR<ExternalIntegrationUpdateWithoutGroupMappingsInput, ExternalIntegrationUncheckedUpdateWithoutGroupMappingsInput>
    create: XOR<ExternalIntegrationCreateWithoutGroupMappingsInput, ExternalIntegrationUncheckedCreateWithoutGroupMappingsInput>
    where?: ExternalIntegrationWhereInput
  }

  export type ExternalIntegrationUpdateToOneWithWhereWithoutGroupMappingsInput = {
    where?: ExternalIntegrationWhereInput
    data: XOR<ExternalIntegrationUpdateWithoutGroupMappingsInput, ExternalIntegrationUncheckedUpdateWithoutGroupMappingsInput>
  }

  export type ExternalIntegrationUpdateWithoutGroupMappingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumIntegrationProviderFieldUpdateOperationsInput | $Enums.IntegrationProvider
    status?: EnumIntegrationStatusFieldUpdateOperationsInput | $Enums.IntegrationStatus
    credentialsEncrypted?: StringFieldUpdateOperationsInput | string
    credentialsIV?: StringFieldUpdateOperationsInput | string
    credentialsTag?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    apiBaseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    apiVersion?: NullableStringFieldUpdateOperationsInput | string | null
    syncEnabled?: BoolFieldUpdateOperationsInput | boolean
    syncFrequency?: EnumSyncFrequencyFieldUpdateOperationsInput | $Enums.SyncFrequency
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSyncStatus?: NullableEnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus | null
    nextSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutIntegrationsNestedInput
    syncLogs?: SyncLogUpdateManyWithoutIntegrationNestedInput
  }

  export type ExternalIntegrationUncheckedUpdateWithoutGroupMappingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    provider?: EnumIntegrationProviderFieldUpdateOperationsInput | $Enums.IntegrationProvider
    status?: EnumIntegrationStatusFieldUpdateOperationsInput | $Enums.IntegrationStatus
    credentialsEncrypted?: StringFieldUpdateOperationsInput | string
    credentialsIV?: StringFieldUpdateOperationsInput | string
    credentialsTag?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    apiBaseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    apiVersion?: NullableStringFieldUpdateOperationsInput | string | null
    syncEnabled?: BoolFieldUpdateOperationsInput | boolean
    syncFrequency?: EnumSyncFrequencyFieldUpdateOperationsInput | $Enums.SyncFrequency
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSyncStatus?: NullableEnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus | null
    nextSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncLogs?: SyncLogUncheckedUpdateManyWithoutIntegrationNestedInput
  }

  export type GroupUpsertWithoutMappingsInput = {
    update: XOR<GroupUpdateWithoutMappingsInput, GroupUncheckedUpdateWithoutMappingsInput>
    create: XOR<GroupCreateWithoutMappingsInput, GroupUncheckedCreateWithoutMappingsInput>
    where?: GroupWhereInput
  }

  export type GroupUpdateToOneWithWhereWithoutMappingsInput = {
    where?: GroupWhereInput
    data: XOR<GroupUpdateWithoutMappingsInput, GroupUncheckedUpdateWithoutMappingsInput>
  }

  export type GroupUpdateWithoutMappingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    ageMin?: NullableIntFieldUpdateOperationsInput | number | null
    ageMax?: NullableIntFieldUpdateOperationsInput | number | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutGroupsNestedInput
    members?: GroupMemberUpdateManyWithoutGroupNestedInput
    lessons?: LessonGroupUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateWithoutMappingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    ageMin?: NullableIntFieldUpdateOperationsInput | number | null
    ageMax?: NullableIntFieldUpdateOperationsInput | number | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: GroupMemberUncheckedUpdateManyWithoutGroupNestedInput
    lessons?: LessonGroupUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type ExternalIntegrationCreateWithoutSyncLogsInput = {
    id?: string
    provider: $Enums.IntegrationProvider
    status?: $Enums.IntegrationStatus
    credentialsEncrypted: string
    credentialsIV: string
    credentialsTag: string
    accessToken?: string | null
    refreshToken?: string | null
    tokenExpiresAt?: Date | string | null
    apiBaseUrl?: string | null
    apiVersion?: string | null
    syncEnabled?: boolean
    syncFrequency?: $Enums.SyncFrequency
    lastSyncAt?: Date | string | null
    lastSyncStatus?: $Enums.SyncStatus | null
    nextSyncAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutIntegrationsInput
    groupMappings?: ExternalGroupMappingCreateNestedManyWithoutIntegrationInput
  }

  export type ExternalIntegrationUncheckedCreateWithoutSyncLogsInput = {
    id?: string
    organizationId: string
    provider: $Enums.IntegrationProvider
    status?: $Enums.IntegrationStatus
    credentialsEncrypted: string
    credentialsIV: string
    credentialsTag: string
    accessToken?: string | null
    refreshToken?: string | null
    tokenExpiresAt?: Date | string | null
    apiBaseUrl?: string | null
    apiVersion?: string | null
    syncEnabled?: boolean
    syncFrequency?: $Enums.SyncFrequency
    lastSyncAt?: Date | string | null
    lastSyncStatus?: $Enums.SyncStatus | null
    nextSyncAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    groupMappings?: ExternalGroupMappingUncheckedCreateNestedManyWithoutIntegrationInput
  }

  export type ExternalIntegrationCreateOrConnectWithoutSyncLogsInput = {
    where: ExternalIntegrationWhereUniqueInput
    create: XOR<ExternalIntegrationCreateWithoutSyncLogsInput, ExternalIntegrationUncheckedCreateWithoutSyncLogsInput>
  }

  export type ExternalIntegrationUpsertWithoutSyncLogsInput = {
    update: XOR<ExternalIntegrationUpdateWithoutSyncLogsInput, ExternalIntegrationUncheckedUpdateWithoutSyncLogsInput>
    create: XOR<ExternalIntegrationCreateWithoutSyncLogsInput, ExternalIntegrationUncheckedCreateWithoutSyncLogsInput>
    where?: ExternalIntegrationWhereInput
  }

  export type ExternalIntegrationUpdateToOneWithWhereWithoutSyncLogsInput = {
    where?: ExternalIntegrationWhereInput
    data: XOR<ExternalIntegrationUpdateWithoutSyncLogsInput, ExternalIntegrationUncheckedUpdateWithoutSyncLogsInput>
  }

  export type ExternalIntegrationUpdateWithoutSyncLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumIntegrationProviderFieldUpdateOperationsInput | $Enums.IntegrationProvider
    status?: EnumIntegrationStatusFieldUpdateOperationsInput | $Enums.IntegrationStatus
    credentialsEncrypted?: StringFieldUpdateOperationsInput | string
    credentialsIV?: StringFieldUpdateOperationsInput | string
    credentialsTag?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    apiBaseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    apiVersion?: NullableStringFieldUpdateOperationsInput | string | null
    syncEnabled?: BoolFieldUpdateOperationsInput | boolean
    syncFrequency?: EnumSyncFrequencyFieldUpdateOperationsInput | $Enums.SyncFrequency
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSyncStatus?: NullableEnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus | null
    nextSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutIntegrationsNestedInput
    groupMappings?: ExternalGroupMappingUpdateManyWithoutIntegrationNestedInput
  }

  export type ExternalIntegrationUncheckedUpdateWithoutSyncLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    provider?: EnumIntegrationProviderFieldUpdateOperationsInput | $Enums.IntegrationProvider
    status?: EnumIntegrationStatusFieldUpdateOperationsInput | $Enums.IntegrationStatus
    credentialsEncrypted?: StringFieldUpdateOperationsInput | string
    credentialsIV?: StringFieldUpdateOperationsInput | string
    credentialsTag?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    apiBaseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    apiVersion?: NullableStringFieldUpdateOperationsInput | string | null
    syncEnabled?: BoolFieldUpdateOperationsInput | boolean
    syncFrequency?: EnumSyncFrequencyFieldUpdateOperationsInput | $Enums.SyncFrequency
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSyncStatus?: NullableEnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus | null
    nextSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupMappings?: ExternalGroupMappingUncheckedUpdateManyWithoutIntegrationNestedInput
  }

  export type OrganizationCreateWithoutLessonsInput = {
    id?: string
    name: string
    slug: string
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutOrganizationInput
    groups?: GroupCreateNestedManyWithoutOrganizationInput
    integrations?: ExternalIntegrationCreateNestedManyWithoutOrganizationInput
    aiFilterConfigs?: AIFilterConfigCreateNestedManyWithoutOrganizationInput
    comparativeThemes?: ComparativeThemeCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutLessonsInput = {
    id?: string
    name: string
    slug: string
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    groups?: GroupUncheckedCreateNestedManyWithoutOrganizationInput
    integrations?: ExternalIntegrationUncheckedCreateNestedManyWithoutOrganizationInput
    aiFilterConfigs?: AIFilterConfigUncheckedCreateNestedManyWithoutOrganizationInput
    comparativeThemes?: ComparativeThemeUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutLessonsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutLessonsInput, OrganizationUncheckedCreateWithoutLessonsInput>
  }

  export type LessonGroupCreateWithoutLessonInput = {
    id?: string
    createdAt?: Date | string
    group: GroupCreateNestedOneWithoutLessonsInput
  }

  export type LessonGroupUncheckedCreateWithoutLessonInput = {
    id?: string
    groupId: string
    createdAt?: Date | string
  }

  export type LessonGroupCreateOrConnectWithoutLessonInput = {
    where: LessonGroupWhereUniqueInput
    create: XOR<LessonGroupCreateWithoutLessonInput, LessonGroupUncheckedCreateWithoutLessonInput>
  }

  export type LessonGroupCreateManyLessonInputEnvelope = {
    data: LessonGroupCreateManyLessonInput | LessonGroupCreateManyLessonInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutLessonsInput = {
    update: XOR<OrganizationUpdateWithoutLessonsInput, OrganizationUncheckedUpdateWithoutLessonsInput>
    create: XOR<OrganizationCreateWithoutLessonsInput, OrganizationUncheckedCreateWithoutLessonsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutLessonsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutLessonsInput, OrganizationUncheckedUpdateWithoutLessonsInput>
  }

  export type OrganizationUpdateWithoutLessonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutOrganizationNestedInput
    groups?: GroupUpdateManyWithoutOrganizationNestedInput
    integrations?: ExternalIntegrationUpdateManyWithoutOrganizationNestedInput
    aiFilterConfigs?: AIFilterConfigUpdateManyWithoutOrganizationNestedInput
    comparativeThemes?: ComparativeThemeUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutLessonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    groups?: GroupUncheckedUpdateManyWithoutOrganizationNestedInput
    integrations?: ExternalIntegrationUncheckedUpdateManyWithoutOrganizationNestedInput
    aiFilterConfigs?: AIFilterConfigUncheckedUpdateManyWithoutOrganizationNestedInput
    comparativeThemes?: ComparativeThemeUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type LessonGroupUpsertWithWhereUniqueWithoutLessonInput = {
    where: LessonGroupWhereUniqueInput
    update: XOR<LessonGroupUpdateWithoutLessonInput, LessonGroupUncheckedUpdateWithoutLessonInput>
    create: XOR<LessonGroupCreateWithoutLessonInput, LessonGroupUncheckedCreateWithoutLessonInput>
  }

  export type LessonGroupUpdateWithWhereUniqueWithoutLessonInput = {
    where: LessonGroupWhereUniqueInput
    data: XOR<LessonGroupUpdateWithoutLessonInput, LessonGroupUncheckedUpdateWithoutLessonInput>
  }

  export type LessonGroupUpdateManyWithWhereWithoutLessonInput = {
    where: LessonGroupScalarWhereInput
    data: XOR<LessonGroupUpdateManyMutationInput, LessonGroupUncheckedUpdateManyWithoutLessonInput>
  }

  export type LessonCreateWithoutGroupsInput = {
    id?: string
    title: string
    quarter: number
    unit: number
    lessonNumber: number
    scripture: string
    content: JsonNullValueInput | InputJsonValue
    slides?: NullableJsonNullValueInput | InputJsonValue
    games?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: boolean
    isTemplate?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutLessonsInput
  }

  export type LessonUncheckedCreateWithoutGroupsInput = {
    id?: string
    organizationId: string
    title: string
    quarter: number
    unit: number
    lessonNumber: number
    scripture: string
    content: JsonNullValueInput | InputJsonValue
    slides?: NullableJsonNullValueInput | InputJsonValue
    games?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: boolean
    isTemplate?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LessonCreateOrConnectWithoutGroupsInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutGroupsInput, LessonUncheckedCreateWithoutGroupsInput>
  }

  export type GroupCreateWithoutLessonsInput = {
    id?: string
    name: string
    description?: string | null
    externalId?: string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    ageMin?: number | null
    ageMax?: number | null
    grade?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutGroupsInput
    members?: GroupMemberCreateNestedManyWithoutGroupInput
    mappings?: ExternalGroupMappingCreateNestedManyWithoutGroupInput
  }

  export type GroupUncheckedCreateWithoutLessonsInput = {
    id?: string
    name: string
    description?: string | null
    organizationId: string
    externalId?: string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    ageMin?: number | null
    ageMax?: number | null
    grade?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: GroupMemberUncheckedCreateNestedManyWithoutGroupInput
    mappings?: ExternalGroupMappingUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupCreateOrConnectWithoutLessonsInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutLessonsInput, GroupUncheckedCreateWithoutLessonsInput>
  }

  export type LessonUpsertWithoutGroupsInput = {
    update: XOR<LessonUpdateWithoutGroupsInput, LessonUncheckedUpdateWithoutGroupsInput>
    create: XOR<LessonCreateWithoutGroupsInput, LessonUncheckedCreateWithoutGroupsInput>
    where?: LessonWhereInput
  }

  export type LessonUpdateToOneWithWhereWithoutGroupsInput = {
    where?: LessonWhereInput
    data: XOR<LessonUpdateWithoutGroupsInput, LessonUncheckedUpdateWithoutGroupsInput>
  }

  export type LessonUpdateWithoutGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    quarter?: IntFieldUpdateOperationsInput | number
    unit?: IntFieldUpdateOperationsInput | number
    lessonNumber?: IntFieldUpdateOperationsInput | number
    scripture?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    slides?: NullableJsonNullValueInput | InputJsonValue
    games?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutLessonsNestedInput
  }

  export type LessonUncheckedUpdateWithoutGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    quarter?: IntFieldUpdateOperationsInput | number
    unit?: IntFieldUpdateOperationsInput | number
    lessonNumber?: IntFieldUpdateOperationsInput | number
    scripture?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    slides?: NullableJsonNullValueInput | InputJsonValue
    games?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupUpsertWithoutLessonsInput = {
    update: XOR<GroupUpdateWithoutLessonsInput, GroupUncheckedUpdateWithoutLessonsInput>
    create: XOR<GroupCreateWithoutLessonsInput, GroupUncheckedCreateWithoutLessonsInput>
    where?: GroupWhereInput
  }

  export type GroupUpdateToOneWithWhereWithoutLessonsInput = {
    where?: GroupWhereInput
    data: XOR<GroupUpdateWithoutLessonsInput, GroupUncheckedUpdateWithoutLessonsInput>
  }

  export type GroupUpdateWithoutLessonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    ageMin?: NullableIntFieldUpdateOperationsInput | number | null
    ageMax?: NullableIntFieldUpdateOperationsInput | number | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutGroupsNestedInput
    members?: GroupMemberUpdateManyWithoutGroupNestedInput
    mappings?: ExternalGroupMappingUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateWithoutLessonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    ageMin?: NullableIntFieldUpdateOperationsInput | number | null
    ageMax?: NullableIntFieldUpdateOperationsInput | number | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: GroupMemberUncheckedUpdateManyWithoutGroupNestedInput
    mappings?: ExternalGroupMappingUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type OrganizationCreateWithoutAiFilterConfigsInput = {
    id?: string
    name: string
    slug: string
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutOrganizationInput
    groups?: GroupCreateNestedManyWithoutOrganizationInput
    integrations?: ExternalIntegrationCreateNestedManyWithoutOrganizationInput
    lessons?: LessonCreateNestedManyWithoutOrganizationInput
    comparativeThemes?: ComparativeThemeCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutAiFilterConfigsInput = {
    id?: string
    name: string
    slug: string
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    groups?: GroupUncheckedCreateNestedManyWithoutOrganizationInput
    integrations?: ExternalIntegrationUncheckedCreateNestedManyWithoutOrganizationInput
    lessons?: LessonUncheckedCreateNestedManyWithoutOrganizationInput
    comparativeThemes?: ComparativeThemeUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutAiFilterConfigsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutAiFilterConfigsInput, OrganizationUncheckedCreateWithoutAiFilterConfigsInput>
  }

  export type AIFilterMetricCreateWithoutFilterInput = {
    id?: string
    organizationId?: string | null
    query: string
    detectedCategory: $Enums.FilterCategory
    actionTaken: $Enums.FilterAction
    userId?: string | null
    groupId?: string | null
    featureName?: string | null
    leaderNotified?: boolean
    leaderResponse?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AIFilterMetricUncheckedCreateWithoutFilterInput = {
    id?: string
    organizationId?: string | null
    query: string
    detectedCategory: $Enums.FilterCategory
    actionTaken: $Enums.FilterAction
    userId?: string | null
    groupId?: string | null
    featureName?: string | null
    leaderNotified?: boolean
    leaderResponse?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AIFilterMetricCreateOrConnectWithoutFilterInput = {
    where: AIFilterMetricWhereUniqueInput
    create: XOR<AIFilterMetricCreateWithoutFilterInput, AIFilterMetricUncheckedCreateWithoutFilterInput>
  }

  export type AIFilterMetricCreateManyFilterInputEnvelope = {
    data: AIFilterMetricCreateManyFilterInput | AIFilterMetricCreateManyFilterInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutAiFilterConfigsInput = {
    update: XOR<OrganizationUpdateWithoutAiFilterConfigsInput, OrganizationUncheckedUpdateWithoutAiFilterConfigsInput>
    create: XOR<OrganizationCreateWithoutAiFilterConfigsInput, OrganizationUncheckedCreateWithoutAiFilterConfigsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutAiFilterConfigsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutAiFilterConfigsInput, OrganizationUncheckedUpdateWithoutAiFilterConfigsInput>
  }

  export type OrganizationUpdateWithoutAiFilterConfigsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutOrganizationNestedInput
    groups?: GroupUpdateManyWithoutOrganizationNestedInput
    integrations?: ExternalIntegrationUpdateManyWithoutOrganizationNestedInput
    lessons?: LessonUpdateManyWithoutOrganizationNestedInput
    comparativeThemes?: ComparativeThemeUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutAiFilterConfigsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    groups?: GroupUncheckedUpdateManyWithoutOrganizationNestedInput
    integrations?: ExternalIntegrationUncheckedUpdateManyWithoutOrganizationNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutOrganizationNestedInput
    comparativeThemes?: ComparativeThemeUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type AIFilterMetricUpsertWithWhereUniqueWithoutFilterInput = {
    where: AIFilterMetricWhereUniqueInput
    update: XOR<AIFilterMetricUpdateWithoutFilterInput, AIFilterMetricUncheckedUpdateWithoutFilterInput>
    create: XOR<AIFilterMetricCreateWithoutFilterInput, AIFilterMetricUncheckedCreateWithoutFilterInput>
  }

  export type AIFilterMetricUpdateWithWhereUniqueWithoutFilterInput = {
    where: AIFilterMetricWhereUniqueInput
    data: XOR<AIFilterMetricUpdateWithoutFilterInput, AIFilterMetricUncheckedUpdateWithoutFilterInput>
  }

  export type AIFilterMetricUpdateManyWithWhereWithoutFilterInput = {
    where: AIFilterMetricScalarWhereInput
    data: XOR<AIFilterMetricUpdateManyMutationInput, AIFilterMetricUncheckedUpdateManyWithoutFilterInput>
  }

  export type AIFilterMetricScalarWhereInput = {
    AND?: AIFilterMetricScalarWhereInput | AIFilterMetricScalarWhereInput[]
    OR?: AIFilterMetricScalarWhereInput[]
    NOT?: AIFilterMetricScalarWhereInput | AIFilterMetricScalarWhereInput[]
    id?: StringFilter<"AIFilterMetric"> | string
    filterId?: StringFilter<"AIFilterMetric"> | string
    organizationId?: StringNullableFilter<"AIFilterMetric"> | string | null
    query?: StringFilter<"AIFilterMetric"> | string
    detectedCategory?: EnumFilterCategoryFilter<"AIFilterMetric"> | $Enums.FilterCategory
    actionTaken?: EnumFilterActionFilter<"AIFilterMetric"> | $Enums.FilterAction
    userId?: StringNullableFilter<"AIFilterMetric"> | string | null
    groupId?: StringNullableFilter<"AIFilterMetric"> | string | null
    featureName?: StringNullableFilter<"AIFilterMetric"> | string | null
    leaderNotified?: BoolFilter<"AIFilterMetric"> | boolean
    leaderResponse?: StringNullableFilter<"AIFilterMetric"> | string | null
    resolvedAt?: DateTimeNullableFilter<"AIFilterMetric"> | Date | string | null
    createdAt?: DateTimeFilter<"AIFilterMetric"> | Date | string
  }

  export type AIFilterConfigCreateWithoutMetricsInput = {
    id?: string
    filterRules: JsonNullValueInput | InputJsonValue
    customKeywords?: NullableJsonNullValueInput | InputJsonValue
    redirectMessage?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organization?: OrganizationCreateNestedOneWithoutAiFilterConfigsInput
  }

  export type AIFilterConfigUncheckedCreateWithoutMetricsInput = {
    id?: string
    organizationId?: string | null
    filterRules: JsonNullValueInput | InputJsonValue
    customKeywords?: NullableJsonNullValueInput | InputJsonValue
    redirectMessage?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIFilterConfigCreateOrConnectWithoutMetricsInput = {
    where: AIFilterConfigWhereUniqueInput
    create: XOR<AIFilterConfigCreateWithoutMetricsInput, AIFilterConfigUncheckedCreateWithoutMetricsInput>
  }

  export type AIFilterConfigUpsertWithoutMetricsInput = {
    update: XOR<AIFilterConfigUpdateWithoutMetricsInput, AIFilterConfigUncheckedUpdateWithoutMetricsInput>
    create: XOR<AIFilterConfigCreateWithoutMetricsInput, AIFilterConfigUncheckedCreateWithoutMetricsInput>
    where?: AIFilterConfigWhereInput
  }

  export type AIFilterConfigUpdateToOneWithWhereWithoutMetricsInput = {
    where?: AIFilterConfigWhereInput
    data: XOR<AIFilterConfigUpdateWithoutMetricsInput, AIFilterConfigUncheckedUpdateWithoutMetricsInput>
  }

  export type AIFilterConfigUpdateWithoutMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    filterRules?: JsonNullValueInput | InputJsonValue
    customKeywords?: NullableJsonNullValueInput | InputJsonValue
    redirectMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutAiFilterConfigsNestedInput
  }

  export type AIFilterConfigUncheckedUpdateWithoutMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    filterRules?: JsonNullValueInput | InputJsonValue
    customKeywords?: NullableJsonNullValueInput | InputJsonValue
    redirectMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationCreateWithoutComparativeThemesInput = {
    id?: string
    name: string
    slug: string
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutOrganizationInput
    groups?: GroupCreateNestedManyWithoutOrganizationInput
    integrations?: ExternalIntegrationCreateNestedManyWithoutOrganizationInput
    lessons?: LessonCreateNestedManyWithoutOrganizationInput
    aiFilterConfigs?: AIFilterConfigCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutComparativeThemesInput = {
    id?: string
    name: string
    slug: string
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    groups?: GroupUncheckedCreateNestedManyWithoutOrganizationInput
    integrations?: ExternalIntegrationUncheckedCreateNestedManyWithoutOrganizationInput
    lessons?: LessonUncheckedCreateNestedManyWithoutOrganizationInput
    aiFilterConfigs?: AIFilterConfigUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutComparativeThemesInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutComparativeThemesInput, OrganizationUncheckedCreateWithoutComparativeThemesInput>
  }

  export type ThemeMetricCreateWithoutThemeInput = {
    id?: string
    organizationId: string
    viewCount?: number
    lastViewedAt?: Date | string
    userId?: string | null
    featureContext?: string | null
    timeSpentMs?: number | null
    usedInLesson?: boolean
    lessonId?: string | null
    createdAt?: Date | string
  }

  export type ThemeMetricUncheckedCreateWithoutThemeInput = {
    id?: string
    organizationId: string
    viewCount?: number
    lastViewedAt?: Date | string
    userId?: string | null
    featureContext?: string | null
    timeSpentMs?: number | null
    usedInLesson?: boolean
    lessonId?: string | null
    createdAt?: Date | string
  }

  export type ThemeMetricCreateOrConnectWithoutThemeInput = {
    where: ThemeMetricWhereUniqueInput
    create: XOR<ThemeMetricCreateWithoutThemeInput, ThemeMetricUncheckedCreateWithoutThemeInput>
  }

  export type ThemeMetricCreateManyThemeInputEnvelope = {
    data: ThemeMetricCreateManyThemeInput | ThemeMetricCreateManyThemeInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutComparativeThemesInput = {
    update: XOR<OrganizationUpdateWithoutComparativeThemesInput, OrganizationUncheckedUpdateWithoutComparativeThemesInput>
    create: XOR<OrganizationCreateWithoutComparativeThemesInput, OrganizationUncheckedCreateWithoutComparativeThemesInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutComparativeThemesInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutComparativeThemesInput, OrganizationUncheckedUpdateWithoutComparativeThemesInput>
  }

  export type OrganizationUpdateWithoutComparativeThemesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutOrganizationNestedInput
    groups?: GroupUpdateManyWithoutOrganizationNestedInput
    integrations?: ExternalIntegrationUpdateManyWithoutOrganizationNestedInput
    lessons?: LessonUpdateManyWithoutOrganizationNestedInput
    aiFilterConfigs?: AIFilterConfigUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutComparativeThemesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    groups?: GroupUncheckedUpdateManyWithoutOrganizationNestedInput
    integrations?: ExternalIntegrationUncheckedUpdateManyWithoutOrganizationNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutOrganizationNestedInput
    aiFilterConfigs?: AIFilterConfigUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type ThemeMetricUpsertWithWhereUniqueWithoutThemeInput = {
    where: ThemeMetricWhereUniqueInput
    update: XOR<ThemeMetricUpdateWithoutThemeInput, ThemeMetricUncheckedUpdateWithoutThemeInput>
    create: XOR<ThemeMetricCreateWithoutThemeInput, ThemeMetricUncheckedCreateWithoutThemeInput>
  }

  export type ThemeMetricUpdateWithWhereUniqueWithoutThemeInput = {
    where: ThemeMetricWhereUniqueInput
    data: XOR<ThemeMetricUpdateWithoutThemeInput, ThemeMetricUncheckedUpdateWithoutThemeInput>
  }

  export type ThemeMetricUpdateManyWithWhereWithoutThemeInput = {
    where: ThemeMetricScalarWhereInput
    data: XOR<ThemeMetricUpdateManyMutationInput, ThemeMetricUncheckedUpdateManyWithoutThemeInput>
  }

  export type ThemeMetricScalarWhereInput = {
    AND?: ThemeMetricScalarWhereInput | ThemeMetricScalarWhereInput[]
    OR?: ThemeMetricScalarWhereInput[]
    NOT?: ThemeMetricScalarWhereInput | ThemeMetricScalarWhereInput[]
    id?: StringFilter<"ThemeMetric"> | string
    themeId?: StringFilter<"ThemeMetric"> | string
    organizationId?: StringFilter<"ThemeMetric"> | string
    viewCount?: IntFilter<"ThemeMetric"> | number
    lastViewedAt?: DateTimeFilter<"ThemeMetric"> | Date | string
    userId?: StringNullableFilter<"ThemeMetric"> | string | null
    featureContext?: StringNullableFilter<"ThemeMetric"> | string | null
    timeSpentMs?: IntNullableFilter<"ThemeMetric"> | number | null
    usedInLesson?: BoolFilter<"ThemeMetric"> | boolean
    lessonId?: StringNullableFilter<"ThemeMetric"> | string | null
    createdAt?: DateTimeFilter<"ThemeMetric"> | Date | string
  }

  export type ComparativeThemeCreateWithoutMetricsInput = {
    id?: string
    themeName: string
    description?: string | null
    category?: string | null
    otPassages: JsonNullValueInput | InputJsonValue
    ntPassages: JsonNullValueInput | InputJsonValue
    themeNotes?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutComparativeThemesInput
  }

  export type ComparativeThemeUncheckedCreateWithoutMetricsInput = {
    id?: string
    organizationId: string
    themeName: string
    description?: string | null
    category?: string | null
    otPassages: JsonNullValueInput | InputJsonValue
    ntPassages: JsonNullValueInput | InputJsonValue
    themeNotes?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComparativeThemeCreateOrConnectWithoutMetricsInput = {
    where: ComparativeThemeWhereUniqueInput
    create: XOR<ComparativeThemeCreateWithoutMetricsInput, ComparativeThemeUncheckedCreateWithoutMetricsInput>
  }

  export type ComparativeThemeUpsertWithoutMetricsInput = {
    update: XOR<ComparativeThemeUpdateWithoutMetricsInput, ComparativeThemeUncheckedUpdateWithoutMetricsInput>
    create: XOR<ComparativeThemeCreateWithoutMetricsInput, ComparativeThemeUncheckedCreateWithoutMetricsInput>
    where?: ComparativeThemeWhereInput
  }

  export type ComparativeThemeUpdateToOneWithWhereWithoutMetricsInput = {
    where?: ComparativeThemeWhereInput
    data: XOR<ComparativeThemeUpdateWithoutMetricsInput, ComparativeThemeUncheckedUpdateWithoutMetricsInput>
  }

  export type ComparativeThemeUpdateWithoutMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    themeName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    otPassages?: JsonNullValueInput | InputJsonValue
    ntPassages?: JsonNullValueInput | InputJsonValue
    themeNotes?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutComparativeThemesNestedInput
  }

  export type ComparativeThemeUncheckedUpdateWithoutMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    themeName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    otPassages?: JsonNullValueInput | InputJsonValue
    ntPassages?: JsonNullValueInput | InputJsonValue
    themeNotes?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutNotificationPreferenceInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.Role
    isActive?: boolean
    externalId?: string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutUsersInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationPreferenceInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.Role
    organizationId: string
    isActive?: boolean
    externalId?: string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationPreferenceInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationPreferenceInput, UserUncheckedCreateWithoutNotificationPreferenceInput>
  }

  export type UserUpsertWithoutNotificationPreferenceInput = {
    update: XOR<UserUpdateWithoutNotificationPreferenceInput, UserUncheckedUpdateWithoutNotificationPreferenceInput>
    create: XOR<UserCreateWithoutNotificationPreferenceInput, UserUncheckedCreateWithoutNotificationPreferenceInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationPreferenceInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationPreferenceInput, UserUncheckedUpdateWithoutNotificationPreferenceInput>
  }

  export type UserUpdateWithoutNotificationPreferenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutUsersNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationPreferenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    organizationId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.Role
    isActive?: boolean
    externalId?: string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutUsersInput
    groupMemberships?: GroupMemberCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.Role
    organizationId: string
    isActive?: boolean
    externalId?: string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    groupMemberships?: GroupMemberUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    notificationPreference?: NotificationPreferenceUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutUsersNestedInput
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    organizationId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyOrganizationInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.Role
    isActive?: boolean
    externalId?: string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupCreateManyOrganizationInput = {
    id?: string
    name: string
    description?: string | null
    externalId?: string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    ageMin?: number | null
    ageMax?: number | null
    grade?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExternalIntegrationCreateManyOrganizationInput = {
    id?: string
    provider: $Enums.IntegrationProvider
    status?: $Enums.IntegrationStatus
    credentialsEncrypted: string
    credentialsIV: string
    credentialsTag: string
    accessToken?: string | null
    refreshToken?: string | null
    tokenExpiresAt?: Date | string | null
    apiBaseUrl?: string | null
    apiVersion?: string | null
    syncEnabled?: boolean
    syncFrequency?: $Enums.SyncFrequency
    lastSyncAt?: Date | string | null
    lastSyncStatus?: $Enums.SyncStatus | null
    nextSyncAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LessonCreateManyOrganizationInput = {
    id?: string
    title: string
    quarter: number
    unit: number
    lessonNumber: number
    scripture: string
    content: JsonNullValueInput | InputJsonValue
    slides?: NullableJsonNullValueInput | InputJsonValue
    games?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: boolean
    isTemplate?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIFilterConfigCreateManyOrganizationInput = {
    id?: string
    filterRules: JsonNullValueInput | InputJsonValue
    customKeywords?: NullableJsonNullValueInput | InputJsonValue
    redirectMessage?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComparativeThemeCreateManyOrganizationInput = {
    id?: string
    themeName: string
    description?: string | null
    category?: string | null
    otPassages: JsonNullValueInput | InputJsonValue
    ntPassages: JsonNullValueInput | InputJsonValue
    themeNotes?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupMemberships?: GroupMemberUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupMemberships?: GroupMemberUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    notificationPreference?: NotificationPreferenceUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    ageMin?: NullableIntFieldUpdateOperationsInput | number | null
    ageMax?: NullableIntFieldUpdateOperationsInput | number | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: GroupMemberUpdateManyWithoutGroupNestedInput
    mappings?: ExternalGroupMappingUpdateManyWithoutGroupNestedInput
    lessons?: LessonGroupUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    ageMin?: NullableIntFieldUpdateOperationsInput | number | null
    ageMax?: NullableIntFieldUpdateOperationsInput | number | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: GroupMemberUncheckedUpdateManyWithoutGroupNestedInput
    mappings?: ExternalGroupMappingUncheckedUpdateManyWithoutGroupNestedInput
    lessons?: LessonGroupUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    ageMin?: NullableIntFieldUpdateOperationsInput | number | null
    ageMax?: NullableIntFieldUpdateOperationsInput | number | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExternalIntegrationUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumIntegrationProviderFieldUpdateOperationsInput | $Enums.IntegrationProvider
    status?: EnumIntegrationStatusFieldUpdateOperationsInput | $Enums.IntegrationStatus
    credentialsEncrypted?: StringFieldUpdateOperationsInput | string
    credentialsIV?: StringFieldUpdateOperationsInput | string
    credentialsTag?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    apiBaseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    apiVersion?: NullableStringFieldUpdateOperationsInput | string | null
    syncEnabled?: BoolFieldUpdateOperationsInput | boolean
    syncFrequency?: EnumSyncFrequencyFieldUpdateOperationsInput | $Enums.SyncFrequency
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSyncStatus?: NullableEnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus | null
    nextSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupMappings?: ExternalGroupMappingUpdateManyWithoutIntegrationNestedInput
    syncLogs?: SyncLogUpdateManyWithoutIntegrationNestedInput
  }

  export type ExternalIntegrationUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumIntegrationProviderFieldUpdateOperationsInput | $Enums.IntegrationProvider
    status?: EnumIntegrationStatusFieldUpdateOperationsInput | $Enums.IntegrationStatus
    credentialsEncrypted?: StringFieldUpdateOperationsInput | string
    credentialsIV?: StringFieldUpdateOperationsInput | string
    credentialsTag?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    apiBaseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    apiVersion?: NullableStringFieldUpdateOperationsInput | string | null
    syncEnabled?: BoolFieldUpdateOperationsInput | boolean
    syncFrequency?: EnumSyncFrequencyFieldUpdateOperationsInput | $Enums.SyncFrequency
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSyncStatus?: NullableEnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus | null
    nextSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupMappings?: ExternalGroupMappingUncheckedUpdateManyWithoutIntegrationNestedInput
    syncLogs?: SyncLogUncheckedUpdateManyWithoutIntegrationNestedInput
  }

  export type ExternalIntegrationUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumIntegrationProviderFieldUpdateOperationsInput | $Enums.IntegrationProvider
    status?: EnumIntegrationStatusFieldUpdateOperationsInput | $Enums.IntegrationStatus
    credentialsEncrypted?: StringFieldUpdateOperationsInput | string
    credentialsIV?: StringFieldUpdateOperationsInput | string
    credentialsTag?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    apiBaseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    apiVersion?: NullableStringFieldUpdateOperationsInput | string | null
    syncEnabled?: BoolFieldUpdateOperationsInput | boolean
    syncFrequency?: EnumSyncFrequencyFieldUpdateOperationsInput | $Enums.SyncFrequency
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSyncStatus?: NullableEnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus | null
    nextSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    quarter?: IntFieldUpdateOperationsInput | number
    unit?: IntFieldUpdateOperationsInput | number
    lessonNumber?: IntFieldUpdateOperationsInput | number
    scripture?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    slides?: NullableJsonNullValueInput | InputJsonValue
    games?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groups?: LessonGroupUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    quarter?: IntFieldUpdateOperationsInput | number
    unit?: IntFieldUpdateOperationsInput | number
    lessonNumber?: IntFieldUpdateOperationsInput | number
    scripture?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    slides?: NullableJsonNullValueInput | InputJsonValue
    games?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groups?: LessonGroupUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    quarter?: IntFieldUpdateOperationsInput | number
    unit?: IntFieldUpdateOperationsInput | number
    lessonNumber?: IntFieldUpdateOperationsInput | number
    scripture?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    slides?: NullableJsonNullValueInput | InputJsonValue
    games?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIFilterConfigUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    filterRules?: JsonNullValueInput | InputJsonValue
    customKeywords?: NullableJsonNullValueInput | InputJsonValue
    redirectMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metrics?: AIFilterMetricUpdateManyWithoutFilterNestedInput
  }

  export type AIFilterConfigUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    filterRules?: JsonNullValueInput | InputJsonValue
    customKeywords?: NullableJsonNullValueInput | InputJsonValue
    redirectMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metrics?: AIFilterMetricUncheckedUpdateManyWithoutFilterNestedInput
  }

  export type AIFilterConfigUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    filterRules?: JsonNullValueInput | InputJsonValue
    customKeywords?: NullableJsonNullValueInput | InputJsonValue
    redirectMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComparativeThemeUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    themeName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    otPassages?: JsonNullValueInput | InputJsonValue
    ntPassages?: JsonNullValueInput | InputJsonValue
    themeNotes?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metrics?: ThemeMetricUpdateManyWithoutThemeNestedInput
  }

  export type ComparativeThemeUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    themeName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    otPassages?: JsonNullValueInput | InputJsonValue
    ntPassages?: JsonNullValueInput | InputJsonValue
    themeNotes?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metrics?: ThemeMetricUncheckedUpdateManyWithoutThemeNestedInput
  }

  export type ComparativeThemeUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    themeName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    otPassages?: JsonNullValueInput | InputJsonValue
    ntPassages?: JsonNullValueInput | InputJsonValue
    themeNotes?: NullableJsonNullValueInput | InputJsonValue
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMemberCreateManyUserInput = {
    id?: string
    groupId: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RefreshTokenCreateManyUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    organizationId: string
    type: $Enums.NotificationType
    title: string
    message: string
    actionUrl?: string | null
    deliveryMethod?: $Enums.NotificationDeliveryMethod
    priority?: $Enums.NotificationPriority
    scheduledFor?: Date | string | null
    sentAt?: Date | string | null
    readAt?: Date | string | null
    status?: $Enums.NotificationStatus
    deliveryStatus?: NullableJsonNullValueInput | InputJsonValue
    failureReason?: string | null
    retryCount?: number
    maxRetries?: number
    groupId?: string | null
    lessonId?: string | null
    eventId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupMemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: GroupUpdateOneRequiredWithoutMembersNestedInput
  }

  export type GroupMemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryMethod?: EnumNotificationDeliveryMethodFieldUpdateOperationsInput | $Enums.NotificationDeliveryMethod
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    deliveryStatus?: NullableJsonNullValueInput | InputJsonValue
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    lessonId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryMethod?: EnumNotificationDeliveryMethodFieldUpdateOperationsInput | $Enums.NotificationDeliveryMethod
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    deliveryStatus?: NullableJsonNullValueInput | InputJsonValue
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    lessonId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryMethod?: EnumNotificationDeliveryMethodFieldUpdateOperationsInput | $Enums.NotificationDeliveryMethod
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    deliveryStatus?: NullableJsonNullValueInput | InputJsonValue
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    lessonId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMemberCreateManyGroupInput = {
    id?: string
    userId: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExternalGroupMappingCreateManyGroupInput = {
    id?: string
    integrationId: string
    externalGroupId: string
    externalGroupName: string
    externalGroupType?: string | null
    syncMembers?: boolean
    syncLeaders?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LessonGroupCreateManyGroupInput = {
    id?: string
    lessonId: string
    createdAt?: Date | string
  }

  export type GroupMemberUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutGroupMembershipsNestedInput
  }

  export type GroupMemberUncheckedUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMemberUncheckedUpdateManyWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExternalGroupMappingUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalGroupId?: StringFieldUpdateOperationsInput | string
    externalGroupName?: StringFieldUpdateOperationsInput | string
    externalGroupType?: NullableStringFieldUpdateOperationsInput | string | null
    syncMembers?: BoolFieldUpdateOperationsInput | boolean
    syncLeaders?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    integration?: ExternalIntegrationUpdateOneRequiredWithoutGroupMappingsNestedInput
  }

  export type ExternalGroupMappingUncheckedUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    integrationId?: StringFieldUpdateOperationsInput | string
    externalGroupId?: StringFieldUpdateOperationsInput | string
    externalGroupName?: StringFieldUpdateOperationsInput | string
    externalGroupType?: NullableStringFieldUpdateOperationsInput | string | null
    syncMembers?: BoolFieldUpdateOperationsInput | boolean
    syncLeaders?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExternalGroupMappingUncheckedUpdateManyWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    integrationId?: StringFieldUpdateOperationsInput | string
    externalGroupId?: StringFieldUpdateOperationsInput | string
    externalGroupName?: StringFieldUpdateOperationsInput | string
    externalGroupType?: NullableStringFieldUpdateOperationsInput | string | null
    syncMembers?: BoolFieldUpdateOperationsInput | boolean
    syncLeaders?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonGroupUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lesson?: LessonUpdateOneRequiredWithoutGroupsNestedInput
  }

  export type LessonGroupUncheckedUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonGroupUncheckedUpdateManyWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExternalGroupMappingCreateManyIntegrationInput = {
    id?: string
    externalGroupId: string
    externalGroupName: string
    externalGroupType?: string | null
    groupId?: string | null
    syncMembers?: boolean
    syncLeaders?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SyncLogCreateManyIntegrationInput = {
    id?: string
    status: $Enums.SyncStatus
    startedAt?: Date | string
    completedAt?: Date | string | null
    durationMs?: number | null
    peopleAdded?: number
    peopleUpdated?: number
    peopleRemoved?: number
    groupsAdded?: number
    groupsUpdated?: number
    groupsSkipped?: number
    errorMessage?: string | null
    errorCode?: string | null
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ExternalGroupMappingUpdateWithoutIntegrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalGroupId?: StringFieldUpdateOperationsInput | string
    externalGroupName?: StringFieldUpdateOperationsInput | string
    externalGroupType?: NullableStringFieldUpdateOperationsInput | string | null
    syncMembers?: BoolFieldUpdateOperationsInput | boolean
    syncLeaders?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: GroupUpdateOneWithoutMappingsNestedInput
  }

  export type ExternalGroupMappingUncheckedUpdateWithoutIntegrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalGroupId?: StringFieldUpdateOperationsInput | string
    externalGroupName?: StringFieldUpdateOperationsInput | string
    externalGroupType?: NullableStringFieldUpdateOperationsInput | string | null
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    syncMembers?: BoolFieldUpdateOperationsInput | boolean
    syncLeaders?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExternalGroupMappingUncheckedUpdateManyWithoutIntegrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalGroupId?: StringFieldUpdateOperationsInput | string
    externalGroupName?: StringFieldUpdateOperationsInput | string
    externalGroupType?: NullableStringFieldUpdateOperationsInput | string | null
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    syncMembers?: BoolFieldUpdateOperationsInput | boolean
    syncLeaders?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyncLogUpdateWithoutIntegrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    peopleAdded?: IntFieldUpdateOperationsInput | number
    peopleUpdated?: IntFieldUpdateOperationsInput | number
    peopleRemoved?: IntFieldUpdateOperationsInput | number
    groupsAdded?: IntFieldUpdateOperationsInput | number
    groupsUpdated?: IntFieldUpdateOperationsInput | number
    groupsSkipped?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SyncLogUncheckedUpdateWithoutIntegrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    peopleAdded?: IntFieldUpdateOperationsInput | number
    peopleUpdated?: IntFieldUpdateOperationsInput | number
    peopleRemoved?: IntFieldUpdateOperationsInput | number
    groupsAdded?: IntFieldUpdateOperationsInput | number
    groupsUpdated?: IntFieldUpdateOperationsInput | number
    groupsSkipped?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SyncLogUncheckedUpdateManyWithoutIntegrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSyncStatusFieldUpdateOperationsInput | $Enums.SyncStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    peopleAdded?: IntFieldUpdateOperationsInput | number
    peopleUpdated?: IntFieldUpdateOperationsInput | number
    peopleRemoved?: IntFieldUpdateOperationsInput | number
    groupsAdded?: IntFieldUpdateOperationsInput | number
    groupsUpdated?: IntFieldUpdateOperationsInput | number
    groupsSkipped?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type LessonGroupCreateManyLessonInput = {
    id?: string
    groupId: string
    createdAt?: Date | string
  }

  export type LessonGroupUpdateWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: GroupUpdateOneRequiredWithoutLessonsNestedInput
  }

  export type LessonGroupUncheckedUpdateWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonGroupUncheckedUpdateManyWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIFilterMetricCreateManyFilterInput = {
    id?: string
    organizationId?: string | null
    query: string
    detectedCategory: $Enums.FilterCategory
    actionTaken: $Enums.FilterAction
    userId?: string | null
    groupId?: string | null
    featureName?: string | null
    leaderNotified?: boolean
    leaderResponse?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AIFilterMetricUpdateWithoutFilterInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    query?: StringFieldUpdateOperationsInput | string
    detectedCategory?: EnumFilterCategoryFieldUpdateOperationsInput | $Enums.FilterCategory
    actionTaken?: EnumFilterActionFieldUpdateOperationsInput | $Enums.FilterAction
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    featureName?: NullableStringFieldUpdateOperationsInput | string | null
    leaderNotified?: BoolFieldUpdateOperationsInput | boolean
    leaderResponse?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIFilterMetricUncheckedUpdateWithoutFilterInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    query?: StringFieldUpdateOperationsInput | string
    detectedCategory?: EnumFilterCategoryFieldUpdateOperationsInput | $Enums.FilterCategory
    actionTaken?: EnumFilterActionFieldUpdateOperationsInput | $Enums.FilterAction
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    featureName?: NullableStringFieldUpdateOperationsInput | string | null
    leaderNotified?: BoolFieldUpdateOperationsInput | boolean
    leaderResponse?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIFilterMetricUncheckedUpdateManyWithoutFilterInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    query?: StringFieldUpdateOperationsInput | string
    detectedCategory?: EnumFilterCategoryFieldUpdateOperationsInput | $Enums.FilterCategory
    actionTaken?: EnumFilterActionFieldUpdateOperationsInput | $Enums.FilterAction
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    featureName?: NullableStringFieldUpdateOperationsInput | string | null
    leaderNotified?: BoolFieldUpdateOperationsInput | boolean
    leaderResponse?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ThemeMetricCreateManyThemeInput = {
    id?: string
    organizationId: string
    viewCount?: number
    lastViewedAt?: Date | string
    userId?: string | null
    featureContext?: string | null
    timeSpentMs?: number | null
    usedInLesson?: boolean
    lessonId?: string | null
    createdAt?: Date | string
  }

  export type ThemeMetricUpdateWithoutThemeInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    viewCount?: IntFieldUpdateOperationsInput | number
    lastViewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    featureContext?: NullableStringFieldUpdateOperationsInput | string | null
    timeSpentMs?: NullableIntFieldUpdateOperationsInput | number | null
    usedInLesson?: BoolFieldUpdateOperationsInput | boolean
    lessonId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ThemeMetricUncheckedUpdateWithoutThemeInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    viewCount?: IntFieldUpdateOperationsInput | number
    lastViewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    featureContext?: NullableStringFieldUpdateOperationsInput | string | null
    timeSpentMs?: NullableIntFieldUpdateOperationsInput | number | null
    usedInLesson?: BoolFieldUpdateOperationsInput | boolean
    lessonId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ThemeMetricUncheckedUpdateManyWithoutThemeInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    viewCount?: IntFieldUpdateOperationsInput | number
    lastViewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    featureContext?: NullableStringFieldUpdateOperationsInput | string | null
    timeSpentMs?: NullableIntFieldUpdateOperationsInput | number | null
    usedInLesson?: BoolFieldUpdateOperationsInput | boolean
    lessonId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}